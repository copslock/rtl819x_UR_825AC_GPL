diff -uprN rtl8367r.old/rtk_api.c rtl8367r/rtk_api.c
--- rtl8367r.old/rtk_api.c	2015-11-16 12:26:58.560262000 +0300
+++ rtl8367r/rtk_api.c	2016-01-29 19:05:46.226131768 +0300
@@ -54,21 +54,14 @@
 
 #include <linux/string.h>
 
-#define ENHANCE_ETH_COMPATILITY		1
-#define REG1301_8367R_VB				0x1010
-#define REG1301_8367RB					0x1000
-
-#define CONFIG_LAN_WAN_ISOLATION 1
-#define CONFIG_RTK_REFINE_PORT_DUPLEX_MODE 1
-
-#define RTL8367RB_USE_ONE_LED_PER_PORT		1
-
 #define DELAY_800MS_FOR_CHIP_STATABLE() {  }
 
 rtk_uint16      (*init_para)[2];
 rtk_uint16      init_size;
 
-#if defined(CHIP_RTL8363SB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)
+#define EEE_OCP_PHY_ADDR    (0xA5D0)
+
+#if defined(CHIP_RTL8363SB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT) || defined(CONFIG_RTL8367B_ASICDRV_TEST)
 rtk_uint16 ChipData00[][2]= {
 /*Code of Func*/
 {0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x0301, 0x0026}, {0x1722, 0x0E14},
@@ -330,7 +323,7 @@ rtk_uint16 ChipData01[][2]= {
 /*End of ChipData01[][2]*/
 #endif
 
-#if defined(CHIP_RTL8365MB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)
+#if defined(CHIP_RTL8365MB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT) || defined(CHIP_AUTO_DETECT)  || defined(CONFIG_RTL8367B_ASICDRV_TEST)
 rtk_uint16 ChipData10[][2]= {
 /*Code of Func*/
 {0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x0301, 0x0026}, {0x1722, 0x0E14},
@@ -589,9 +582,14 @@ rtk_uint16 ChipData11[][2]= {
 };
 /*End of ChipData11[][2]*/
 
+rtk_uint16 ChipData12[][2]= {
+{0x1d32, 0x0002}, {0x0018, 0x0F00}, {0x0038, 0x0F00}, {0x0058, 0x0F00},
+{0x0078, 0x0F00}, {0x0098, 0x0F00}, {0x1200, 0x7FCB}
+};/*End of ChipData12[][2]*/
+
 #endif
 
-#if defined(CHIP_RTL8367_VB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)
+#if defined(CHIP_RTL8367_VB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)  || defined(CONFIG_RTL8367B_ASICDRV_TEST)
 rtk_uint16 ChipData20[][2]= {
 /*Code of Func*/
 {0x1B03, 0x0876}, {0x205F, 0x0002}, {0x2059, 0x1A00}, {0x205F, 0x0000},
@@ -853,7 +851,7 @@ rtk_uint16 ChipData21[][2]= {
 
 #endif
 
-#if defined(CHIP_RTL8367RB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)
+#if defined(CHIP_RTL8367RB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)  || defined(CONFIG_RTL8367B_ASICDRV_TEST)
 rtk_uint16 ChipData30[][2]= {
 /*Code of Func*/
 {0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x0301, 0x0026}, {0x1722, 0x0E14},
@@ -1070,7 +1068,7 @@ rtk_uint16 ChipData30[][2]= {
 /*End of ChipData30[][2]*/
 #endif
 
-#ifdef ENHANCE_ETH_COMPATILITY
+#if defined(CHIP_RTL8367RB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)  || defined(CONFIG_RTL8367B_ASICDRV_TEST) || defined(CONFIG_RTL_8367R_SUPPORT)
 rtk_uint16 ChipData31[][2]= {
 /*Code of Func*/
 {0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x1305, 0xC000}, {0x121E, 0x03CA},
@@ -1113,9 +1111,14 @@ rtk_uint16 ChipData31[][2]= {
 {0x133E, 0x000E}, {0x133F, 0x0010}, };
 /*End of ChipData21[][2]*/
 
+rtk_uint16 ChipData32[][2]= {
+/*Code of Func*/
+{0x1d32, 0x0002}, {0x0018, 0x0F00}, {0x0038, 0x0F00}, {0x0058, 0x0F00},
+{0x0078, 0x0F00}, {0x0098, 0x0F00}, {0x1200, 0x7FCB}
+};/*End of ChipData32[][2]*/
 #endif
 
-#if defined(CHIP_RTL8367R_VB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)
+#if defined(CHIP_RTL8367R_VB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT) || defined(CONFIG_RTL8367B_ASICDRV_TEST)
 rtk_uint16 ChipData40[][2]= {
 /*Code of Func*/
 {0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x0301, 0x0026}, {0x1722, 0x0E14},
@@ -1332,7 +1335,7 @@ rtk_uint16 ChipData40[][2]= {
 /*End of ChipData40[][2]*/
 #endif
 
-#ifdef ENHANCE_ETH_COMPATILITY
+#if defined(CHIP_RTL8367R_VB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT) || defined(CONFIG_RTL8367B_ASICDRV_TEST) || defined(CONFIG_RTL_8367R_SUPPORT)
 rtk_uint16 ChipData41[][2]= {
 /*Code of Func*/
 {0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x1305, 0xC000}, {0x121E, 0x03CA},
@@ -1377,7 +1380,7 @@ rtk_uint16 ChipData41[][2]= {
 
 #endif
 
-#if defined(CHIP_RTL8367MB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)
+#if defined(CHIP_RTL8367MB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)  || defined(CONFIG_RTL8367B_ASICDRV_TEST)
 rtk_uint16 ChipData50[][2]= { };
 
 rtk_uint16 ChipData51[][2]= {
@@ -1425,7 +1428,7 @@ rtk_uint16 ChipData51[][2]= {
 /*End of ChipData51[][2]*/
 #endif
 
-#if defined(CHIP_RTL8367M_VB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)
+#if defined(CHIP_RTL8367M_VB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)  || defined(CONFIG_RTL8367B_ASICDRV_TEST)
 rtk_uint16 ChipData60[][2]= {
 /*Code of Func*/
 {0x1B00, 0x14F1}, {0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x0301, 0x0026},
@@ -1685,7 +1688,7 @@ rtk_uint16 ChipData61[][2]= {
 
 #endif
 
-#if defined(CHIP_RTL8368MB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)
+#if defined(CHIP_RTL8368MB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)  || defined(CONFIG_RTL8367B_ASICDRV_TEST)
 rtk_uint16 ChipData70[][2]= {
 /*Code of Func*/
 {0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x0301, 0x0026}, {0x1722, 0x0E14},
@@ -1945,7 +1948,7 @@ rtk_uint16 ChipData71[][2]= {
 
 #endif
 
-#if defined(CHIP_RTL8305MB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)
+#if defined(CHIP_RTL8305MB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT) || defined(CHIP_AUTO_DETECT) || defined(CONFIG_RTL8367B_ASICDRV_TEST)
 rtk_uint16 ChipData80[][2]= {
 /*Code of Func*/
 {0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x0301, 0x0026}, {0x1722, 0x0E14},
@@ -2207,7 +2210,7 @@ rtk_uint16 ChipData81[][2]= {
 /*End of ChipData81[][2]*/
 #endif
 
-#if defined(CHIP_RTL8307M_VB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)
+#if defined(CHIP_RTL8307M_VB) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)  || defined(CONFIG_RTL8367B_ASICDRV_TEST)
 rtk_uint16 ChipData90[][2]= {
 /*Code of Func*/
 };
@@ -2261,6 +2264,252 @@ rtk_uint16 ChipData91[][2]= {
 
 #endif
 
+#if defined(CHIP_RTL8367N) || defined(RTK_X86_ASICDRV) || defined(RTK_ASICDRV_INIT)  || defined(CONFIG_RTL8367B_ASICDRV_TEST)
+rtk_uint16 ChipData100[][2]= {
+/*Code of Func*/
+};
+/*End of ChipData100[][2]*/
+
+rtk_uint16 ChipData101[][2]= {
+/*Code of Func*/
+{0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x1305, 0xC000}, {0x121E, 0x03CA},
+{0x1233, 0x0352}, {0x1234, 0x0064}, {0x1237, 0x0096}, {0x1238, 0x0078},
+{0x1239, 0x0084}, {0x123A, 0x0030}, {0x205F, 0x0002}, {0x2059, 0x1A00},
+{0x205F, 0x0000}, {0x207F, 0x0002}, {0x2077, 0x0000}, {0x2078, 0x0000},
+{0x2079, 0x0000}, {0x207A, 0x0000}, {0x207B, 0x0000}, {0x207F, 0x0000},
+{0x205F, 0x0002}, {0x2053, 0x0000}, {0x2054, 0x0000}, {0x2055, 0x0000},
+{0x2056, 0x0000}, {0x2057, 0x0000}, {0x205F, 0x0000}, {0x12A3, 0x2200},
+{0x6107, 0xE58B}, {0x6103, 0xA970}, {0x133F, 0x0030}, {0x133E, 0x000E},
+{0x221F, 0x0007}, {0x221E, 0x002C}, {0x2219, 0x0504}, {0x221F, 0x0000},
+{0x133F, 0x0010}, {0x0018, 0x0F00}, {0x0038, 0x0F00}, {0x0058, 0x0F00},
+{0x0078, 0x0F00}, {0x0098, 0x0F00}, {0x13EB, 0x11BB}, {0x207F, 0x0002},
+{0x2073, 0x1D22}, {0x207F, 0x0000}, {0x133F, 0x0030}, {0x133E, 0x000E},
+{0x2200, 0x1940}, {0x221F, 0x0005}, {0x2205, 0x8B6E}, {0x2206, 0x0000},
+{0x220F, 0x0100}, {0x2205, 0xFFF6}, {0x2206, 0x0080}, {0x221F, 0x0007},
+{0x221E, 0x002D}, {0x2218, 0xF030}, {0x221F, 0x0007}, {0x221E, 0x0023},
+{0x2216, 0x0005}, {0x2215, 0x0095}, {0x2219, 0x001A}, {0x2215, 0x009A},
+{0x2219, 0x0017}, {0x2215, 0x009D}, {0x2219, 0x000E}, {0x2215, 0x009F},
+{0x2219, 0x0003}, {0x2215, 0x00A2}, {0x2219, 0x0050}, {0x2215, 0x00A3},
+{0x2219, 0x0081}, {0x2215, 0x00A4}, {0x2219, 0x00BC}, {0x2215, 0x00A5},
+{0x2219, 0x001B}, {0x2215, 0x00A6}, {0x2219, 0x00EE}, {0x2215, 0x00A7},
+{0x2219, 0x00A4}, {0x2215, 0x00A8}, {0x2219, 0x002B}, {0x2215, 0x00A9},
+{0x2219, 0x00EB}, {0x2215, 0x00AA}, {0x2219, 0x00C7}, {0x2215, 0x00AB},
+{0x2219, 0x0050}, {0x2215, 0x00AC}, {0x2219, 0x0080}, {0x2215, 0x00AD},
+{0x2219, 0x00E0}, {0x2215, 0x00AE}, {0x2219, 0x0094}, {0x2215, 0x00AF},
+{0x2219, 0x00E0}, {0x2215, 0x00B0}, {0x2219, 0x0000}, {0x2215, 0x00B1},
+{0x2219, 0x0044}, {0x2215, 0x00B2}, {0x2219, 0x0021}, {0x2215, 0x00B3},
+{0x2219, 0x0044}, {0x2215, 0x00B4}, {0x2219, 0x0020}, {0x2215, 0x00B5},
+{0x2219, 0x0094}, {0x2215, 0x00B6}, {0x2219, 0x00FF}, {0x2215, 0x00B7},
+{0x2219, 0x004A}, {0x2215, 0x00B8}, {0x2219, 0x0001}, {0x2215, 0x00B9},
+{0x2219, 0x002A}, {0x2215, 0x00BA}, {0x2219, 0x0094}, {0x2215, 0x00BB},
+{0x2219, 0x007F}, {0x2215, 0x0171}, {0x2219, 0x004B}, {0x2215, 0x0172},
+{0x2219, 0x0019}, {0x2215, 0x0174}, {0x2219, 0x0041}, {0x2215, 0x0175},
+{0x2219, 0x0039}, {0x2215, 0x0178}, {0x2219, 0x0079}, {0x2215, 0x017E},
+{0x2219, 0x009C}, {0x2215, 0x018F}, {0x2219, 0x0071}, {0x2215, 0x0192},
+{0x2219, 0x0079}, {0x2215, 0x0197}, {0x2219, 0x0079}, {0x2215, 0x01AD},
+{0x2219, 0x009D}, {0x2215, 0x01B4}, {0x2219, 0x009C}, {0x2215, 0x01C0},
+{0x2219, 0x0042}, {0x2215, 0x01C1}, {0x2219, 0x0037}, {0x2215, 0x01C2},
+{0x2219, 0x00E1}, {0x2215, 0x01C3}, {0x2219, 0x00D7}, {0x2215, 0x01C4},
+{0x2219, 0x00E1}, {0x2215, 0x01C5}, {0x2219, 0x00D7}, {0x2215, 0x01C6},
+{0x2219, 0x00E1}, {0x2215, 0x01C7}, {0x2219, 0x00D7}, {0x2215, 0x01C8},
+{0x2219, 0x00E1}, {0x2215, 0x01C9}, {0x2219, 0x00D7}, {0x2215, 0x01CA},
+{0x2219, 0x00E1}, {0x2215, 0x01CB}, {0x2219, 0x00D7}, {0x2215, 0x01CC},
+{0x2219, 0x00E1}, {0x2215, 0x01CD}, {0x2219, 0x00D7}, {0x2215, 0x01CE},
+{0x2219, 0x00E1}, {0x2215, 0x01CF}, {0x2219, 0x00D7}, {0x2215, 0x01D0},
+{0x2219, 0x00E1}, {0x2215, 0x01D1}, {0x2219, 0x00D7}, {0x2215, 0x01D2},
+{0x2219, 0x00E1}, {0x2215, 0x01D3}, {0x2219, 0x00D7}, {0x2215, 0x01D4},
+{0x2219, 0x00E1}, {0x2215, 0x01D5}, {0x2219, 0x00D7}, {0x2215, 0x01D6},
+{0x2219, 0x00C1}, {0x2215, 0x01D7}, {0x2219, 0x009D}, {0x2215, 0x01D8},
+{0x2219, 0x0095}, {0x2215, 0x01D9}, {0x2219, 0x009E}, {0x2215, 0x01DA},
+{0x2219, 0x009A}, {0x2215, 0x01DB}, {0x2219, 0x0089}, {0x2215, 0x01DC},
+{0x2219, 0x007B}, {0x2215, 0x01DD}, {0x2219, 0x00A4}, {0x2215, 0x01DE},
+{0x2219, 0x002B}, {0x2215, 0x01DF}, {0x2219, 0x00F8}, {0x2215, 0x01E0},
+{0x2219, 0x00A2}, {0x2215, 0x01E1}, {0x2219, 0x001C}, {0x2215, 0x01E2},
+{0x2219, 0x0009}, {0x2215, 0x01E3}, {0x2219, 0x00E0}, {0x2215, 0x01E4},
+{0x2219, 0x0081}, {0x2215, 0x01E5}, {0x2219, 0x00E0}, {0x2215, 0x01E6},
+{0x2219, 0x0081}, {0x2215, 0x01E7}, {0x2219, 0x00E0}, {0x2215, 0x01E8},
+{0x2219, 0x0081}, {0x2215, 0x01E9}, {0x2219, 0x00E0}, {0x2215, 0x01EA},
+{0x2219, 0x0081}, {0x2215, 0x01F3}, {0x2219, 0x00D7}, {0x2216, 0x0000},
+{0x221F, 0x0007}, {0x221E, 0x0040}, {0x2218, 0x0004}, {0x221F, 0x0000},
+{0x2217, 0x2160}, {0x221F, 0x0007}, {0x221E, 0x0040}, {0x2218, 0x0874},
+{0x2219, 0x8C00}, {0x2218, 0x08A4}, {0x2219, 0x4000}, {0x2218, 0x08B4},
+{0x2219, 0x0400}, {0x2218, 0x08C4}, {0x2219, 0xFF00}, {0x2218, 0x08D4},
+{0x2219, 0x0500}, {0x2218, 0x08E4}, {0x2219, 0x8500}, {0x2218, 0x08F4},
+{0x2219, 0x8C00}, {0x2218, 0x0904}, {0x2219, 0xFA00}, {0x2218, 0x0914},
+{0x2219, 0xE000}, {0x2218, 0x0924}, {0x2219, 0x0000}, {0x2218, 0x0934},
+{0x2219, 0x4000}, {0x2218, 0x0944}, {0x2219, 0x4400}, {0x2218, 0x0954},
+{0x2219, 0x5400}, {0x2218, 0x0964}, {0x2219, 0xFF00}, {0x2218, 0x0994},
+{0x2219, 0x1400}, {0x2218, 0x0A84}, {0x2219, 0x1400}, {0x2218, 0x0B84},
+{0x2219, 0x1400}, {0x2218, 0x1944}, {0x2219, 0x8C00}, {0x2218, 0x1974},
+{0x2219, 0x4000}, {0x2218, 0x1984}, {0x2219, 0x0400}, {0x2218, 0x1994},
+{0x2219, 0xFF00}, {0x2218, 0x19A4}, {0x2219, 0x0500}, {0x2218, 0x19B4},
+{0x2219, 0x8500}, {0x2218, 0x19C4}, {0x2219, 0x8C00}, {0x2218, 0x19D4},
+{0x2219, 0xFA00}, {0x2218, 0x19E4}, {0x2219, 0xE000}, {0x2218, 0x19F4},
+{0x2219, 0x0000}, {0x2218, 0x1A04}, {0x2219, 0x4000}, {0x2218, 0x1A14},
+{0x2219, 0x4400}, {0x2218, 0x1A24}, {0x2219, 0x5400}, {0x2218, 0x1A34},
+{0x2219, 0xFF00}, {0x2218, 0x1A64}, {0x2219, 0x1400}, {0x2218, 0x1B54},
+{0x2219, 0x1400}, {0x2218, 0x1C54}, {0x2219, 0x1400}, {0x221F, 0x0000},
+{0x2217, 0x2100}, {0x221F, 0x0007}, {0x221E, 0x0040}, {0x2218, 0x0000},
+{0x221F, 0x0007}, {0x221E, 0x0042}, {0x2215, 0x0F00}, {0x221F, 0x0000},
+{0x2217, 0x2160}, {0x221F, 0x0001}, {0x2210, 0xF25E}, {0x221F, 0x0007},
+{0x221E, 0x0042}, {0x2215, 0x0F02}, {0x2216, 0x9406}, {0x2215, 0x0E02},
+{0x2215, 0x0F02}, {0x2215, 0x0F06}, {0x2216, 0x950A}, {0x2215, 0x0E06},
+{0x2215, 0x0F06}, {0x2215, 0x0F07}, {0x2216, 0x7408}, {0x2215, 0x0E07},
+{0x2215, 0x0F07}, {0x2215, 0x0F08}, {0x2216, 0x5808}, {0x2215, 0x0E08},
+{0x2215, 0x0F08}, {0x2215, 0x0F09}, {0x2216, 0x080C}, {0x2215, 0x0E09},
+{0x2215, 0x0F09}, {0x2215, 0x0F0A}, {0x2216, 0x7408}, {0x2215, 0x0E0A},
+{0x2215, 0x0F0A}, {0x2215, 0x0F0B}, {0x2216, 0x5800}, {0x2215, 0x0E0B},
+{0x2215, 0x0F0B}, {0x2215, 0x0F0C}, {0x2216, 0x9400}, {0x2215, 0x0E0C},
+{0x2215, 0x0F0C}, {0x2215, 0x0F0D}, {0x2216, 0x0803}, {0x2215, 0x0E0D},
+{0x2215, 0x0F0D}, {0x221F, 0x0001}, {0x2210, 0xF05E}, {0x221F, 0x0007},
+{0x221E, 0x0042}, {0x2215, 0x0D00}, {0x2215, 0x0100}, {0x221F, 0x0000},
+{0x2217, 0x2100}, {0x221F, 0x0007}, {0x221E, 0x002D}, {0x2218, 0xF010},
+{0x221F, 0x0005}, {0x2205, 0x8000}, {0x2206, 0x0280}, {0x2206, 0x28F7},
+{0x2206, 0x00E0}, {0x2206, 0xFFF7}, {0x2206, 0xA080}, {0x2206, 0x02AE},
+{0x2206, 0xF602}, {0x2206, 0x0153}, {0x2206, 0x0201}, {0x2206, 0x6602},
+{0x2206, 0x8074}, {0x2206, 0xE08B}, {0x2206, 0x8CE1}, {0x2206, 0x8B8D},
+{0x2206, 0x1E01}, {0x2206, 0xE18B}, {0x2206, 0x8E1E}, {0x2206, 0x01A0},
+{0x2206, 0x00E7}, {0x2206, 0xAEDB}, {0x2206, 0xEE85}, {0x2206, 0xDE00},
+{0x2206, 0xEE85}, {0x2206, 0xDF00}, {0x2206, 0xEE8A}, {0x2206, 0xFC07},
+{0x2206, 0xEE8A}, {0x2206, 0xFD73}, {0x2206, 0xD483}, {0x2206, 0x83E4},
+{0x2206, 0x8B92}, {0x2206, 0xE58B}, {0x2206, 0x93D4}, {0x2206, 0x837A},
+{0x2206, 0xE48B}, {0x2206, 0x94E5}, {0x2206, 0x8B95}, {0x2206, 0xD483},
+{0x2206, 0x71E4}, {0x2206, 0x8B96}, {0x2206, 0xE58B}, {0x2206, 0x97EE},
+{0x2206, 0xE144}, {0x2206, 0x77EE}, {0x2206, 0xE145}, {0x2206, 0x85EE},
+{0x2206, 0xE150}, {0x2206, 0xFFEE}, {0x2206, 0xE151}, {0x2206, 0xFEEE},
+{0x2206, 0x8B82}, {0x2206, 0x85EE}, {0x2206, 0x8B87}, {0x2206, 0x80EE},
+{0x2206, 0xFFF6}, {0x2206, 0x00EE}, {0x2206, 0xFFF7}, {0x2206, 0xFE04},
+{0x2206, 0xF8E0}, {0x2206, 0x8B8E}, {0x2206, 0xAD20}, {0x2206, 0x26F6},
+{0x2206, 0x20E4}, {0x2206, 0x8B8E}, {0x2206, 0x0229}, {0x2206, 0x2102},
+{0x2206, 0x2671}, {0x2206, 0x0227}, {0x2206, 0x4B02}, {0x2206, 0x8155},
+{0x2206, 0x0282}, {0x2206, 0x3302}, {0x2206, 0x02B0}, {0x2206, 0x0228},
+{0x2206, 0x9B02}, {0x2206, 0x8102}, {0x2206, 0x0229}, {0x2206, 0xFB02},
+{0x2206, 0x2BA2}, {0x2206, 0x0229}, {0x2206, 0x91E0}, {0x2206, 0x8B8E},
+{0x2206, 0xAD21}, {0x2206, 0x08F6}, {0x2206, 0x21E4}, {0x2206, 0x8B8E},
+{0x2206, 0x0202}, {0x2206, 0x8FE0}, {0x2206, 0x8B8E}, {0x2206, 0xAD22},
+{0x2206, 0x05F6}, {0x2206, 0x22E4}, {0x2206, 0x8B8E}, {0x2206, 0xE08B},
+{0x2206, 0x8EAD}, {0x2206, 0x2305}, {0x2206, 0xF623}, {0x2206, 0xE48B},
+{0x2206, 0x8EE0}, {0x2206, 0x8B8E}, {0x2206, 0xAD24}, {0x2206, 0x08F6},
+{0x2206, 0x24E4}, {0x2206, 0x8B8E}, {0x2206, 0x0228}, {0x2206, 0x14E0},
+{0x2206, 0x8B8E}, {0x2206, 0xAD25}, {0x2206, 0x05F6}, {0x2206, 0x25E4},
+{0x2206, 0x8B8E}, {0x2206, 0xE08B}, {0x2206, 0x8EAD}, {0x2206, 0x260B},
+{0x2206, 0xF626}, {0x2206, 0xE48B}, {0x2206, 0x8E02}, {0x2206, 0x069E},
+{0x2206, 0x021E}, {0x2206, 0x15E0}, {0x2206, 0x8B8E}, {0x2206, 0xAD27},
+{0x2206, 0x05F6}, {0x2206, 0x27E4}, {0x2206, 0x8B8E}, {0x2206, 0x0204},
+{0x2206, 0x1902}, {0x2206, 0x0488}, {0x2206, 0xFC04}, {0x2206, 0xF8F9},
+{0x2206, 0xE08B}, {0x2206, 0x85AD}, {0x2206, 0x2548}, {0x2206, 0xE08A},
+{0x2206, 0xE4E1}, {0x2206, 0x8AE5}, {0x2206, 0x7C00}, {0x2206, 0x009E},
+{0x2206, 0x35EE}, {0x2206, 0x8AE4}, {0x2206, 0x00EE}, {0x2206, 0x8AE5},
+{0x2206, 0x00E0}, {0x2206, 0x8AFC}, {0x2206, 0xE18A}, {0x2206, 0xFDE2},
+{0x2206, 0x85DE}, {0x2206, 0xE385}, {0x2206, 0xDF02}, {0x2206, 0x2DAC},
+{0x2206, 0xAD20}, {0x2206, 0x12EE}, {0x2206, 0x8AE4}, {0x2206, 0x03EE},
+{0x2206, 0x8AE5}, {0x2206, 0xB7EE}, {0x2206, 0x85DE}, {0x2206, 0x00EE},
+{0x2206, 0x85DF}, {0x2206, 0x00AE}, {0x2206, 0x1115}, {0x2206, 0xE685},
+{0x2206, 0xDEE7}, {0x2206, 0x85DF}, {0x2206, 0xAE08}, {0x2206, 0xEE85},
+{0x2206, 0xDE00}, {0x2206, 0xEE85}, {0x2206, 0xDF00}, {0x2206, 0xFDFC},
+{0x2206, 0x04F8}, {0x2206, 0xFAEF}, {0x2206, 0x69E0}, {0x2206, 0x8B85},
+{0x2206, 0xAD21}, {0x2206, 0x3FE0}, {0x2206, 0xE022}, {0x2206, 0xE1E0},
+{0x2206, 0x2358}, {0x2206, 0xC059}, {0x2206, 0x021E}, {0x2206, 0x01E1},
+{0x2206, 0x8B72}, {0x2206, 0x1F10}, {0x2206, 0x9E2C}, {0x2206, 0xE48B},
+{0x2206, 0x72AD}, {0x2206, 0x2120}, {0x2206, 0xE18B}, {0x2206, 0x70F7},
+{0x2206, 0x29E5}, {0x2206, 0x8B70}, {0x2206, 0xAC27}, {0x2206, 0x0DAC},
+{0x2206, 0x2605}, {0x2206, 0x0205}, {0x2206, 0x58AE}, {0x2206, 0x1302},
+{0x2206, 0x056A}, {0x2206, 0xAE0E}, {0x2206, 0x0281}, {0x2206, 0xA302},
+{0x2206, 0x8300}, {0x2206, 0xAE06}, {0x2206, 0x0205}, {0x2206, 0x0E02},
+{0x2206, 0x8346}, {0x2206, 0xEF96}, {0x2206, 0xFEFC}, {0x2206, 0x04D1},
+{0x2206, 0x02BF}, {0x2206, 0x351E}, {0x2206, 0x022E}, {0x2206, 0x88BF},
+{0x2206, 0x2A58}, {0x2206, 0x022E}, {0x2206, 0xC6AC}, {0x2206, 0x280B},
+{0x2206, 0x0281}, {0x2206, 0xEED1}, {0x2206, 0x01BF}, {0x2206, 0x3533},
+{0x2206, 0x022E}, {0x2206, 0x88D0}, {0x2206, 0x1102}, {0x2206, 0x2D33},
+{0x2206, 0x5903}, {0x2206, 0xEF01}, {0x2206, 0xD100}, {0x2206, 0xA000},
+{0x2206, 0x02D1}, {0x2206, 0x01BF}, {0x2206, 0x3521}, {0x2206, 0x022E},
+{0x2206, 0x88D1}, {0x2206, 0x11AD}, {0x2206, 0x2002}, {0x2206, 0x0C11},
+{0x2206, 0xAD21}, {0x2206, 0x020C}, {0x2206, 0x12BF}, {0x2206, 0x3524},
+{0x2206, 0x022E}, {0x2206, 0x8802}, {0x2206, 0x2AB0}, {0x2206, 0x0206},
+{0x2206, 0x5B04}, {0x2206, 0xF8E0}, {0x2206, 0x8B80}, {0x2206, 0xAD27},
+{0x2206, 0x3CEE}, {0x2206, 0xE232}, {0x2206, 0x00EE}, {0x2206, 0xE233},
+{0x2206, 0x07EE}, {0x2206, 0xE230}, {0x2206, 0x00EE}, {0x2206, 0xE231},
+{0x2206, 0xBDE0}, {0x2206, 0xEACA}, {0x2206, 0xE1EA}, {0x2206, 0xCBAD},
+{0x2206, 0x2A13}, {0x2206, 0xE0EA}, {0x2206, 0xCCE1}, {0x2206, 0xEACD},
+{0x2206, 0xAD2A}, {0x2206, 0x0AEE}, {0x2206, 0xE238}, {0x2206, 0x00EE},
+{0x2206, 0xE239}, {0x2206, 0x3BAE}, {0x2206, 0x08EE}, {0x2206, 0xE238},
+{0x2206, 0x00EE}, {0x2206, 0xE239}, {0x2206, 0x0CEE}, {0x2206, 0xE232},
+{0x2206, 0x00EE}, {0x2206, 0xE233}, {0x2206, 0x00FC}, {0x2206, 0x04F8},
+{0x2206, 0xE08B}, {0x2206, 0x85AD}, {0x2206, 0x2730}, {0x2206, 0xE0E0},
+{0x2206, 0x36E1}, {0x2206, 0xE037}, {0x2206, 0xE18B}, {0x2206, 0x731F},
+{0x2206, 0x109E}, {0x2206, 0x23E4}, {0x2206, 0x8B73}, {0x2206, 0xAC20},
+{0x2206, 0x0BAC}, {0x2206, 0x210D}, {0x2206, 0xAC25}, {0x2206, 0x0FAC},
+{0x2206, 0x2711}, {0x2206, 0xAE12}, {0x2206, 0x022C}, {0x2206, 0x88AE},
+{0x2206, 0x0D02}, {0x2206, 0x826C}, {0x2206, 0xAE08}, {0x2206, 0x0282},
+{0x2206, 0x73AE}, {0x2206, 0x0302}, {0x2206, 0x2CA7}, {0x2206, 0xFC04},
+{0x2206, 0x0282}, {0x2206, 0xBD02}, {0x2206, 0x2CF7}, {0x2206, 0x04F8},
+{0x2206, 0xF901}, {0x2206, 0x11E0}, {0x2206, 0x8B87}, {0x2206, 0xAD26},
+{0x2206, 0x08D1}, {0x2206, 0x01BF}, {0x2206, 0x2D30}, {0x2206, 0x022E},
+{0x2206, 0x88FD}, {0x2206, 0xFC04}, {0x2206, 0xF8FA}, {0x2206, 0xEF69},
+{0x2206, 0xE08B}, {0x2206, 0x87AD}, {0x2206, 0x2726}, {0x2206, 0xD00B},
+{0x2206, 0x022D}, {0x2206, 0x33AC}, {0x2206, 0x2A05}, {0x2206, 0xBF83},
+{0x2206, 0xF2AE}, {0x2206, 0x03BF}, {0x2206, 0x83F5}, {0x2206, 0x022E},
+{0x2206, 0xC6AC}, {0x2206, 0x2810}, {0x2206, 0xD101}, {0x2206, 0xBF83},
+{0x2206, 0xF802}, {0x2206, 0x2E88}, {0x2206, 0xD100}, {0x2206, 0xBF83},
+{0x2206, 0xF802}, {0x2206, 0x2E88}, {0x2206, 0xEF96}, {0x2206, 0xFEFC},
+{0x2206, 0x04F8}, {0x2206, 0xF9E0}, {0x2206, 0x8B85}, {0x2206, 0xAD26},
+{0x2206, 0x38D0}, {0x2206, 0x0B02}, {0x2206, 0x2D33}, {0x2206, 0x5882},
+{0x2206, 0x7882}, {0x2206, 0x9F2D}, {0x2206, 0xE08B}, {0x2206, 0x68E1},
+{0x2206, 0x8B69}, {0x2206, 0x1F10}, {0x2206, 0x9E23}, {0x2206, 0x10E4},
+{0x2206, 0x8B68}, {0x2206, 0xE0E0}, {0x2206, 0x00E1}, {0x2206, 0xE001},
+{0x2206, 0xF727}, {0x2206, 0xE4E0}, {0x2206, 0x00E5}, {0x2206, 0xE001},
+{0x2206, 0xE2E0}, {0x2206, 0x20E3}, {0x2206, 0xE021}, {0x2206, 0xAD30},
+{0x2206, 0xF7F6}, {0x2206, 0x27E4}, {0x2206, 0xE000}, {0x2206, 0xE5E0},
+{0x2206, 0x01FD}, {0x2206, 0xFC04}, {0x2206, 0xF8FA}, {0x2206, 0xEF69},
+{0x2206, 0xE08B}, {0x2206, 0x82AD}, {0x2206, 0x2737}, {0x2206, 0xBF83},
+{0x2206, 0xEC02}, {0x2206, 0x2EC6}, {0x2206, 0xAC28}, {0x2206, 0x2ED1},
+{0x2206, 0x01BF}, {0x2206, 0x83EF}, {0x2206, 0x022E}, {0x2206, 0x88BF},
+{0x2206, 0x83E9}, {0x2206, 0x022E}, {0x2206, 0xC6E5}, {0x2206, 0x85DD},
+{0x2206, 0xE0E0}, {0x2206, 0x22E1}, {0x2206, 0xE023}, {0x2206, 0xAC2E},
+{0x2206, 0x04D1}, {0x2206, 0x01AE}, {0x2206, 0x02D1}, {0x2206, 0x00BF},
+{0x2206, 0x83E9}, {0x2206, 0x022E}, {0x2206, 0x88D1}, {0x2206, 0x01BF},
+{0x2206, 0x83EC}, {0x2206, 0x022E}, {0x2206, 0x88EF}, {0x2206, 0x96FE},
+{0x2206, 0xFC04}, {0x2206, 0xF8FA}, {0x2206, 0xEF69}, {0x2206, 0xBF83},
+{0x2206, 0xEF02}, {0x2206, 0x2EC6}, {0x2206, 0xAD28}, {0x2206, 0x19D1},
+{0x2206, 0x00BF}, {0x2206, 0x83EC}, {0x2206, 0x022E}, {0x2206, 0x88E1},
+{0x2206, 0x85DD}, {0x2206, 0xBF83}, {0x2206, 0xE902}, {0x2206, 0x2E88},
+{0x2206, 0xD100}, {0x2206, 0xBF83}, {0x2206, 0xEF02}, {0x2206, 0x2E88},
+{0x2206, 0xEF96}, {0x2206, 0xFEFC}, {0x2206, 0x04EE}, {0x2206, 0xE08E},
+{0x2206, 0x32EE}, {0x2206, 0xE08F}, {0x2206, 0x2105}, {0x2206, 0xEEE0},
+{0x2206, 0x8E32}, {0x2206, 0xEEE0}, {0x2206, 0x8F20}, {0x2206, 0x05F8},
+{0x2206, 0xE0E0}, {0x2206, 0x38E1}, {0x2206, 0xE039}, {0x2206, 0xAD2F},
+{0x2206, 0x10E0}, {0x2206, 0xE034}, {0x2206, 0xE1E0}, {0x2206, 0x35F7},
+{0x2206, 0x26E4}, {0x2206, 0xE034}, {0x2206, 0xE5E0}, {0x2206, 0x35AE},
+{0x2206, 0x0EE0}, {0x2206, 0xE2D6}, {0x2206, 0xE1E2}, {0x2206, 0xD7F7},
+{0x2206, 0x28E4}, {0x2206, 0xE2D6}, {0x2206, 0xE5E2}, {0x2206, 0xD7E0},
+{0x2206, 0xE232}, {0x2206, 0xE1E2}, {0x2206, 0x33F7}, {0x2206, 0x2DE4},
+{0x2206, 0xE232}, {0x2206, 0xE5E2}, {0x2206, 0x33D0}, {0x2206, 0x7DB0},
+{0x2206, 0xFEE0}, {0x2206, 0xE232}, {0x2206, 0xE1E2}, {0x2206, 0x33F6},
+{0x2206, 0x2DE4}, {0x2206, 0xE232}, {0x2206, 0xE5E2}, {0x2206, 0x33E0},
+{0x2206, 0xE034}, {0x2206, 0xE1E0}, {0x2206, 0x35F6}, {0x2206, 0x26E4},
+{0x2206, 0xE034}, {0x2206, 0xE5E0}, {0x2206, 0x35E0}, {0x2206, 0xE2D6},
+{0x2206, 0xE1E2}, {0x2206, 0xD7F6}, {0x2206, 0x28E4}, {0x2206, 0xE2D6},
+{0x2206, 0xE5E2}, {0x2206, 0xD7FC}, {0x2206, 0x0555}, {0x2206, 0xE020},
+{0x2206, 0x55E2}, {0x2206, 0xD600}, {0x2206, 0xE24A}, {0x2206, 0x65E0},
+{0x2206, 0x0887}, {0x2206, 0xE008}, {0x2206, 0x44E0}, {0x2206, 0x2800},
+{0x2205, 0xE142}, {0x2206, 0x0701}, {0x2205, 0xE140}, {0x2206, 0x0405},
+{0x220F, 0x0000}, {0x221F, 0x0007}, {0x221E, 0x0041}, {0x2216, 0x1345},
+{0x221F, 0x0000}, {0x133E, 0x000E}, {0x133F, 0x0010}, {0x133F, 0x0030},
+{0x133E, 0x000E}, {0x221F, 0x0005}, {0x2205, 0x8B86}, {0x2206, 0x808E},
+{0x221F, 0x0003}, {0x2218, 0x8001}, {0x2205, 0x8B80}, {0x2206, 0x4890},
+{0x221F, 0x0000}, {0x133F, 0x0010}, {0x2000, 0x1340}, {0x2020, 0x1340},
+{0x2040, 0x1340}, {0x2060, 0x1340}, {0x2080, 0x1340}
+};
+/*End of ChipData101[][2]*/
+
+rtk_uint16 ChipData102[][2]= {
+{0x1d32, 0x0002}, {0x0018, 0x0F00}, {0x0038, 0x0F00}, {0x0058, 0x0F00},
+{0x0078, 0x0F00}, {0x0098, 0x0F00}, {0x1200, 0x7FCB}
+};
+/*End of ChipData102[][2]*/
+
+#endif
+
 CONST_T rtk_uint8 filter_templateField[RTL8367B_ACLTEMPLATENO][RTL8367B_ACLRULEFIELDNO] = {
     {ACL_DMAC0,   			ACL_DMAC1, 		 	ACL_DMAC2, 	 		ACL_SMAC0,   		ACL_SMAC1, 			ACL_SMAC2, 			ACL_ETHERTYPE, 		ACL_FIELD_SELECT15},
     {ACL_IP4SIP0, 			ACL_IP4SIP1, 		ACL_IP4DIP0, 		ACL_IP4DIP1, 		ACL_FIELD_SELECT13, ACL_FIELD_SELECT14, ACL_FIELD_SELECT02, ACL_FIELD_SELECT15},
@@ -2847,7 +3096,7 @@ rtk_api_ret_t rtk_qos_init(rtk_queue_num
             {0, 0,0,0,1,1,7,7},
             {0, 0,1,1,2,2,7,7},
             {0, 0,1,1,2,3,7,7},
-            {0, 0,1,1,2,3,4,7},
+            {0, 0,1,2,3,4,7,7},
             {0, 0,1,2,3,4,5,7},
             {0,1,2,3,4,5,6,7}
     };
@@ -2878,9 +3127,9 @@ rtk_api_ret_t rtk_qos_init(rtk_queue_num
     }
 
     /*Set Priority to Qid*/
-    for (priority = 0; priority < RTL8367B_PRIMAX; priority++)
+    for (priority = 0; priority <= RTL8367B_PRIMAX; priority++)
     {
-        if ((retVal = rtl8367b_setAsicPriorityToQIDMappingTable(qmapidx, priority, g_prioritytToQid[qmapidx][priority])) != RT_ERR_OK)
+        if ((retVal = rtl8367b_setAsicPriorityToQIDMappingTable((queueNum - 1), priority, g_prioritytToQid[queueNum - 1][priority])) != RT_ERR_OK)
             return retVal;
     }
 
@@ -2915,7 +3164,7 @@ rtk_api_ret_t rtk_qos_init(rtk_queue_num
         return retVal;
 
     /*Set 1p & DSCP  Priority Remapping & Remarking*/
-    for (priority = 0; priority < RTL8367B_PRIMAX; priority++)
+    for (priority = 0; priority <= RTL8367B_PRIMAX; priority++)
     {
         if ((retVal = rtl8367b_setAsicPriorityDot1qRemapping(priority, g_prioritytRemap[priority])) != RT_ERR_OK)
             return retVal;
@@ -2928,7 +3177,7 @@ rtk_api_ret_t rtk_qos_init(rtk_queue_num
     }
 
     /*Set DSCP Priority*/
-    for (dscp = 0; dscp < 63; dscp++)
+    for (dscp = 0; dscp <= 63; dscp++)
     {
         if ((retVal = rtl8367b_setAsicPriorityDscpBased(dscp, 0)) != RT_ERR_OK)
             return retVal;
@@ -4995,33 +5244,76 @@ rtk_api_ret_t rtk_storm_bypass_get(rtk_s
 static rtk_api_ret_t _rtk_port_FiberModeAbility_set(rtk_port_t port, rtk_port_phy_ability_t *pAbility)
 {
     rtk_api_ret_t   retVal;
+    rtk_uint32 data;
 
     if (port != RTK_PORT_COMBO_ID)
         return RT_ERR_PORT_ID;
 
-    if( (pAbility->Full_1000 == 1) && (pAbility->Full_100 == 1) && (pAbility->AutoNegotiation == 1) )
-    {
-        if ((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_SDS_CFG4, RTL8367B_CFG_FRC_SDS_MODE_MASK, RTK_FIBER_FORCE_100M1000M)) != RT_ERR_OK)
-            return retVal;
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
 
-        if ((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_SDS_CFG4, RTL8367B_CFG_FRC_SDS_MODE_EN_MASK, 1)) != RT_ERR_OK)
-            return retVal;
-    }
-    else if(pAbility->Full_1000 == 1)
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data)) != RT_ERR_OK)
+        return retVal;
+
+    if( (data == 0x0276) || (data == 0x0597) || (data == 0x6367) )
     {
-        if ((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_SDS_CFG4, RTL8367B_CFG_FRC_SDS_MODE_MASK, RTK_FIBER_FORCE_1000M)) != RT_ERR_OK)
-            return retVal;
+        if( (pAbility->Full_1000 == 1) && (pAbility->Full_100 == 1) && (pAbility->AutoNegotiation == 1) )
+        {
+            if ((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_FIBER_CFG_1, RTL8367B_SDS_FRC_MODE_OFFSET, 0)) != RT_ERR_OK)
+                return retVal;
 
-        if ((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_SDS_CFG4, RTL8367B_CFG_FRC_SDS_MODE_EN_MASK, 1)) != RT_ERR_OK)
-            return retVal;
+            if ((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_FIBER_CFG_1, RTL8367B_SDS_MODE_MASK, 0)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367b_setAsicRegBit(0x6200, 12, 1)) != RT_ERR_OK)
+                return retVal;
+        }
+        else if(pAbility->Full_1000 == 1)
+        {
+            if ((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_FIBER_CFG_1, RTL8367B_SDS_FRC_MODE_OFFSET, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_FIBER_CFG_1, RTL8367B_SDS_MODE_MASK, 4)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367b_setAsicRegBit(0x6200, 12, 1)) != RT_ERR_OK)
+                return retVal;
+        }
+        else if(pAbility->Full_100 == 1)
+        {
+            if ((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_FIBER_CFG_1, RTL8367B_SDS_FRC_MODE_OFFSET, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_FIBER_CFG_1, RTL8367B_SDS_MODE_MASK, 5)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367b_setAsicRegBit(0x6200, 12, 0)) != RT_ERR_OK)
+                return retVal;
+        }
     }
-    else if(pAbility->Full_100 == 1)
+    else
     {
-        if ((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_SDS_CFG4, RTL8367B_CFG_FRC_SDS_MODE_MASK, RTK_FIBER_FORCE_100M)) != RT_ERR_OK)
-            return retVal;
+        if( (pAbility->Full_1000 == 1) && (pAbility->Full_100 == 1) && (pAbility->AutoNegotiation == 1) )
+        {
+            if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_FIBER_CFG_1, 0x000F)) != RT_ERR_OK)
+                return retVal;
+        }
+        else if(pAbility->Full_1000 == 1)
+        {
+            if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_FIBER_CFG_1, 0x000C)) != RT_ERR_OK)
+                return retVal;
 
-        if ((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_SDS_CFG4, RTL8367B_CFG_FRC_SDS_MODE_EN_MASK, 0)) != RT_ERR_OK)
-            return retVal;
+            if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_FIB_CFG00, 0x1140)) != RT_ERR_OK)
+                return retVal;
+        }
+        else if(pAbility->Full_100 == 1)
+        {
+            if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_FIBER_CFG_1, 0x000D)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_FIB_CFG00, 0x2100)) != RT_ERR_OK)
+                return retVal;
+        }
     }
 
     return RT_ERR_OK;
@@ -5030,33 +5322,59 @@ static rtk_api_ret_t _rtk_port_FiberMode
 static rtk_api_ret_t _rtk_port_FiberModeAbility_get(rtk_port_t port, rtk_port_phy_ability_t *pAbility)
 {
     rtk_api_ret_t   retVal;
-    rtk_uint32      speed, auto_detect;
+    rtk_uint32      data, speed;
 
     if (port != RTK_PORT_COMBO_ID)
         return RT_ERR_PORT_ID;
 
     memset(pAbility, 0x00, sizeof(rtk_port_phy_ability_t));
 
-    if ((retVal = rtl8367b_getAsicRegBits(RTL8367B_REG_SDS_CFG4, RTL8367B_CFG_FRC_SDS_MODE_MASK, &speed)) != RT_ERR_OK)
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data)) != RT_ERR_OK)
         return retVal;
 
-    if(speed == RTK_FIBER_FORCE_100M1000M)
+    if( (data == 0x0276) || (data == 0x0597) || (data == 0x6367) )
     {
-        pAbility->Full_1000 = 1;
-        pAbility->Full_100 = 1;
-    }
-    else if(speed == RTK_FIBER_FORCE_1000M)
-        pAbility->Full_1000 = 1;
-    else if(speed == RTK_FIBER_FORCE_100M)
-        pAbility->Full_100 = 1;
+        if ((retVal = rtl8367b_getAsicRegBit(RTL8367B_REG_FIBER_CFG_1, RTL8367B_SDS_FRC_MODE_OFFSET, &data)) != RT_ERR_OK)
+            return retVal;
 
-    if ((retVal = rtl8367b_getAsicRegBits(RTL8367B_REG_SDS_CFG4, RTL8367B_CFG_FRC_SDS_MODE_EN_MASK, &auto_detect)) != RT_ERR_OK)
-        return retVal;
+        if(data == 0)
+        {
+            pAbility->AutoNegotiation = 1;
+            pAbility->Full_1000 = 1;
+            pAbility->Full_100 = 1;
+        }
+        else
+        {
+            if ((retVal = rtl8367b_getAsicRegBits(RTL8367B_REG_FIBER_CFG_1, RTL8367B_SDS_MODE_MASK, &data)) != RT_ERR_OK)
+                return retVal;
 
-    if(auto_detect == 1)
-        pAbility->AutoNegotiation = 1;
+            if(data == 4)
+                pAbility->Full_1000 = 1;
+            else if(data == 5)
+                pAbility->Full_100 = 1;
+            else
+                return RT_ERR_FAILED;
+        }
+    }
     else
-        pAbility->AutoNegotiation = 0;
+    {
+        if ((retVal = rtl8367b_getAsicRegBits(RTL8367B_REG_SDS_CFG4, RTL8367B_CFG_FRC_SDS_MODE_MASK, &speed)) != RT_ERR_OK)
+            return retVal;
+
+        if(speed == 0x000F)
+        {
+            pAbility->Full_1000 = 1;
+            pAbility->Full_100 = 1;
+            pAbility->AutoNegotiation = 1;
+        }
+        else if(speed == 0x000C)
+            pAbility->Full_1000 = 1;
+        else if(speed == 0x000D)
+            pAbility->Full_100 = 1;
+    }
 
     return RT_ERR_OK;
 }
@@ -5192,7 +5510,7 @@ rtk_api_ret_t rtk_port_phyAutoNegoAbilit
         /* 00= 10Mpbs*/
         phyEnMsk0 = phyEnMsk0 | (1 << 6);
         phyEnMsk0 = phyEnMsk0 & (~(1 << 13));
-
+        phyEnMsk0 = phyEnMsk0 | (1 << 8);
 
         /*Auto-Negotiation setting in reg 0.12*/
         phyEnMsk0 = phyEnMsk0 | (1 << 12);
@@ -5478,26 +5796,6 @@ rtk_api_ret_t rtk_port_phyForceModeAbili
          phyEnMsk0 = phyEnMsk0 | (1 << 8);
      }
 
-
-     if (1 == pAbility->Full_1000)
-     {
-         /*1000 BASE-T FULL duplex capable setting in reg 9.9*/
-         phyEnMsk9 = phyEnMsk9 | (1 << 9);
-
-         /*Speed selection [1:0] */
-         /* 11=Reserved*/
-         /* 10= 1000Mpbs*/
-         /* 01= 100Mpbs*/
-         /* 00= 10Mpbs*/
-         phyEnMsk0 = phyEnMsk0 | (1 << 6);
-         phyEnMsk0 = phyEnMsk0 & (~(1 << 13));
-
-
-         /*Auto-Negotiation setting in reg 0.12*/
-         phyEnMsk0 = phyEnMsk0 | (1 << 12);
-
-     }
-
      if (1 == pAbility->AsyFC)
      {
          /*Asymetric flow control in reg 4.11*/
@@ -5668,10 +5966,17 @@ rtk_api_ret_t rtk_port_phyStatus_get(rtk
 {
     rtk_api_ret_t retVal;
     rtk_uint32 phyData;
+    rtk_uint32 data;
 
     if (port > RTK_PORT_ID_MAX)
         return RT_ERR_PORT_ID;
 
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data)) != RT_ERR_OK)
+        return retVal;
+
     if ((retVal = rtl8367b_setAsicPHYReg(port, RTL8367B_PHY_PAGE_ADDRESS, 0)) != RT_ERR_OK)
         return retVal;
 
@@ -5687,19 +5992,34 @@ rtk_api_ret_t rtk_port_phyStatus_get(rtk
     {
         *pLinkStatus = 1;
 
-        /*Get PHY resolved register*/
-        if ((retVal = rtl8367b_getAsicPHYReg(port, PHY_RESOLVED_REG, &phyData)) != RT_ERR_OK)
-            return retVal;
+        if( (data == 0x0276) || (data == 0x0597) || (data == 0x6367) )
+        {
+            /*Get PHY resolved register*/
+            if ((retVal = rtl8367b_getAsicPHYReg(port, 26, &phyData)) != RT_ERR_OK)
+                return retVal;
 
-        /*check resolution is complete or not*/
-        if (!(phyData&(1 << 11)))
-            return RT_ERR_BUSYWAIT_TIMEOUT;
+            /*check link speed*/
+            *pSpeed = (phyData&0x0030) >> 4;
 
-        /*check link speed*/
-        *pSpeed = (phyData&0xC000) >> 14;
+            /*check link duplex*/
+            *pDuplex = (phyData&0x0008) >> 3;
+        }
+        else
+        {
+            /*Get PHY resolved register*/
+            if ((retVal = rtl8367b_getAsicPHYReg(port, PHY_RESOLVED_REG, &phyData)) != RT_ERR_OK)
+                return retVal;
 
-        /*check link duplex*/
-        *pDuplex = (phyData&0x2000) >> 13;
+            /*check resolution is complete or not*/
+            if (!(phyData&(1 << 11)))
+                return RT_ERR_BUSYWAIT_TIMEOUT;
+
+            /*check link speed*/
+            *pSpeed = (phyData&0xC000) >> 14;
+
+            /*check link duplex*/
+            *pDuplex = (phyData&0x2000) >> 13;
+        }
     }
     else
     {
@@ -5712,12 +6032,13 @@ rtk_api_ret_t rtk_port_phyStatus_get(rtk
 }
 
 /* Function Name:
- *      rtk_port_phyTestMode_set
+ *      rtk_port_phy1000BaseTMasterSlave_set
  * Description:
- *      Set PHY in test mode.
+ *      Set PHY control enable MASTER/SLAVE manual configuration.
  * Input:
  *      port - port id.
- *      mode - PHY test mode 0:normal 1:test mode 1 2:test mode 2 3: test mode 3 4:test mode 4 5~7:reserved
+ *      enable - Manual configuration function 1:enable 0:disable.
+ *      masterslave - Manual config mode 1:master 0: slave
  * Output:
  *      None
  * Return:
@@ -5726,185 +6047,68 @@ rtk_api_ret_t rtk_port_phyStatus_get(rtk
  *      RT_ERR_SMI             	- SMI access error
  *      RT_ERR_PORT_ID 			- Invalid port number.
  *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
- *      RT_ERR_NOT_ALLOWED      - The Setting is not allowed, caused by set more than 1 port in Test mode.
+ *      RT_ERR_ENABLE 			- Invalid enable input.
  * Note:
- *      Set PHY in test mode and only one PHY can be in test mode at the same time.
- *      It means API will return FAILED if other PHY is in test mode.
- *      This API only provide test mode 1 & 4 setup, and if users want other test modes,
- *      please contact realtek FAE.
+ *      Set enable/disable MASTER/SLAVE manual configuration under 1000Base-T with register 9.12-9.11. If MASTER/SLAVE manual configuration is enabled with MASTER, the
+ *      link partner must be set as SLAVE or auto negotiation will fail.
  */
-rtk_api_ret_t rtk_port_phyTestMode_set(rtk_port_t port, rtk_port_phy_test_mode_t mode)
+rtk_api_ret_t rtk_port_phy1000BaseTMasterSlave_set(rtk_port_t port, rtk_enable_t enable, rtk_enable_t masterslave)
 {
-    rtk_uint32          data, i, index, phy, reg;
-    rtk_api_ret_t       retVal;
-    CONST_T rtk_uint16 ParaTM_1[][2] = { {0x205F,0x0002}, {0x2053,0xAA00}, {0x2054,0xAA00}, {0x2055,0xAA00},
-                                         {0x2056,0xAA00}, {0x2057,0xAA00}, {0x205F,0x0002} };
+    rtk_api_ret_t retVal;
+    rtk_uint32 phyData;
 
-    if (port > RTK_PHY_ID_MAX)
+    if (port > RTK_PORT_ID_MAX)
         return RT_ERR_PORT_ID;
 
-    if ( (mode == PHY_TEST_MODE_2) || (mode == PHY_TEST_MODE_3) )
-        return RT_ERR_FAILED;
-
-    if (PHY_TEST_MODE_NORMAL != mode)
-    {
-        /* Other port should be Normal mode */
-        for(i = 0; i <= RTK_PHY_ID_MAX; i++)
-        {
-            if(i != port)
-            {
-                if ((retVal = rtl8367b_setAsicPHYReg(i, 31, 0)) != RT_ERR_OK)
-                    return retVal;
+    if ((retVal = rtl8367b_setAsicPHYReg(port, RTL8367B_PHY_PAGE_ADDRESS, 0)) != RT_ERR_OK)
+        return retVal;
 
-                if ((retVal = rtl8367b_getAsicPHYReg(i, 9, &data)) != RT_ERR_OK)
-                    return retVal;
+    if ((retVal = rtl8367b_getAsicPHYReg(port, PHY_1000_BASET_CONTROL_REG, &phyData)) != RT_ERR_OK)
+        return retVal;
 
-                if((data & 0xE000) != 0)
-                    return RT_ERR_NOT_ALLOWED;
-            }
-        }
-    }
+    phyData = (phyData & (~(0x3 << 11))) | (enable << 12) | (masterslave << 11);
 
-    if (PHY_TEST_MODE_1 == mode)
-    {
-        for (index = 0; index < (sizeof(ParaTM_1) / ((sizeof(rtk_uint16))*2)); index++)
-        {
-            phy = (ParaTM_1[index][0] - 0x2000) / 0x0020;
-            reg = (ParaTM_1[index][0] - 0x2000) % 0x0020;
-            if ((retVal = rtl8367b_setAsicPHYReg(phy, reg, ParaTM_1[index][1])) != RT_ERR_OK)
-                return retVal;
-        }
-    }
+    if ((retVal = rtl8367b_setAsicPHYReg(port, PHY_1000_BASET_CONTROL_REG, phyData)) != RT_ERR_OK)
+        return retVal;
 
-    if ((retVal = rtl8367b_setAsicPHYReg(port, 31, 0)) != RT_ERR_OK)
+    if ((retVal = rtl8367b_setAsicPHYReg(port, PHY_1000_BASET_CONTROL_REG, phyData)) != RT_ERR_OK)
         return retVal;
 
-    if ((retVal = rtl8367b_getAsicPHYReg(port, 9, &data)) != RT_ERR_OK)
+    /*Restart N-way*/
+    if ((retVal = rtl8367b_getAsicPHYReg(port, PHY_CONTROL_REG, &phyData)) != RT_ERR_OK)
         return retVal;
 
-    data &= ~0xE000;
-    data |= (mode << 13);
-    if ((retVal = rtl8367b_setAsicPHYReg(port, 9, data)) != RT_ERR_OK)
+
+    phyData = phyData | (1 << 9);
+    if ((retVal = rtl8367b_setAsicPHYReg(port, PHY_CONTROL_REG, phyData)) != RT_ERR_OK)
         return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_port_phyTestMode_get
+ *      rtk_port_macForceLink_set
  * Description:
- *      Get PHY in which test mode.
+ *      Set port force linking configuration.
  * Input:
- *      port - Port id.
+ *      port            - port id.
+ *      pPortability    - port ability configuration
  * Output:
- *      mode - PHY test mode 0:normal 1:test mode 1 2:test mode 2 3: test mode 3 4:test mode 4 5~7:reserved
+ *      None
  * Return:
- *      RT_ERR_OK              	- OK
- *      RT_ERR_FAILED          	- Failed
- *      RT_ERR_SMI             	- SMI access error
- *      RT_ERR_PORT_ID 			- Invalid port number.
- *      RT_ERR_INPUT 			- Invalid input parameters.
- *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID 		- Invalid port number.
  * Note:
- *      Get test mode of PHY from register setting 9.15 to 9.13.
+ *      This API can set Port/MAC force mode properties.
  */
-rtk_api_ret_t rtk_port_phyTestMode_get(rtk_port_t port, rtk_port_phy_test_mode_t *pMode)
+rtk_api_ret_t rtk_port_macForceLink_set(rtk_port_t port, rtk_port_mac_ability_t *pPortability)
 {
-    rtk_uint32      data;
-    rtk_api_ret_t   retVal;
+    rtk_api_ret_t retVal;
+    rtl8367b_port_ability_t ability;
 
-    if (port > RTK_PHY_ID_MAX)
-        return RT_ERR_PORT_ID;
-
-    if ((retVal = rtl8367b_setAsicPHYReg(port, 31, 0)) != RT_ERR_OK)
-        return retVal;
-
-    if ((retVal = rtl8367b_getAsicPHYReg(port, 9, &data)) != RT_ERR_OK)
-        return retVal;
-
-    *pMode = (data & 0xE000) >> 13;
-
-    return RT_ERR_OK;
-}
-
-/* Function Name:
- *      rtk_port_phy1000BaseTMasterSlave_set
- * Description:
- *      Set PHY control enable MASTER/SLAVE manual configuration.
- * Input:
- *      port - port id.
- *      enable - Manual configuration function 1:enable 0:disable.
- *      masterslave - Manual config mode 1:master 0: slave
- * Output:
- *      None
- * Return:
- *      RT_ERR_OK              	- OK
- *      RT_ERR_FAILED          	- Failed
- *      RT_ERR_SMI             	- SMI access error
- *      RT_ERR_PORT_ID 			- Invalid port number.
- *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
- *      RT_ERR_ENABLE 			- Invalid enable input.
- * Note:
- *      Set enable/disable MASTER/SLAVE manual configuration under 1000Base-T with register 9.12-9.11. If MASTER/SLAVE manual configuration is enabled with MASTER, the
- *      link partner must be set as SLAVE or auto negotiation will fail.
- */
-rtk_api_ret_t rtk_port_phy1000BaseTMasterSlave_set(rtk_port_t port, rtk_enable_t enable, rtk_enable_t masterslave)
-{
-    rtk_api_ret_t retVal;
-    rtk_uint32 phyData;
-
-    if (port > RTK_PORT_ID_MAX)
-        return RT_ERR_PORT_ID;
-
-    if ((retVal = rtl8367b_setAsicPHYReg(port, RTL8367B_PHY_PAGE_ADDRESS, 0)) != RT_ERR_OK)
-        return retVal;
-
-    if ((retVal = rtl8367b_getAsicPHYReg(port, PHY_1000_BASET_CONTROL_REG, &phyData)) != RT_ERR_OK)
-        return retVal;
-
-    phyData = (phyData & (~(0x3 << 11))) | (enable << 12) | (masterslave << 11);
-
-    if ((retVal = rtl8367b_setAsicPHYReg(port, PHY_1000_BASET_CONTROL_REG, phyData)) != RT_ERR_OK)
-        return retVal;
-
-    if ((retVal = rtl8367b_setAsicPHYReg(port, PHY_1000_BASET_CONTROL_REG, phyData)) != RT_ERR_OK)
-        return retVal;
-
-    /*Restart N-way*/
-    if ((retVal = rtl8367b_getAsicPHYReg(port, PHY_CONTROL_REG, &phyData)) != RT_ERR_OK)
-        return retVal;
-
-
-    phyData = phyData | (1 << 9);
-    if ((retVal = rtl8367b_setAsicPHYReg(port, PHY_CONTROL_REG, phyData)) != RT_ERR_OK)
-        return retVal;
-
-    return RT_ERR_OK;
-}
-
-/* Function Name:
- *      rtk_port_macForceLink_set
- * Description:
- *      Set port force linking configuration.
- * Input:
- *      port            - port id.
- *      pPortability    - port ability configuration
- * Output:
- *      None
- * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_PORT_ID 		- Invalid port number.
- * Note:
- *      This API can set Port/MAC force mode properties.
- */
-rtk_api_ret_t rtk_port_macForceLink_set(rtk_port_t port, rtk_port_mac_ability_t *pPortability)
-{
-    rtk_api_ret_t retVal;
-    rtl8367b_port_ability_t ability;
-
-    if (port > RTK_PORT_ID_MAX)
+    if (port > RTK_PORT_ID_MAX)
         return RT_ERR_PORT_ID;
 
     if (pPortability->forcemode >1|| pPortability->speed > 2 || pPortability->duplex > 1 ||
@@ -5992,7 +6196,6 @@ rtk_api_ret_t rtk_port_macForceLink_get(
  *      - MODE_EXT_TMII_PHY,
  *      - MODE_EXT_GMII,
  *      - MODE_EXT_RMII_MAC,
- *      - MODE_EXT_RMII_PHY,
  */
 rtk_api_ret_t rtk_port_macForceLinkExt0_set(rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability)
 {
@@ -6047,7 +6250,6 @@ rtk_api_ret_t rtk_port_macForceLinkExt0_
  *      - MODE_EXT_TMII_PHY,
  *      - MODE_EXT_GMII,
  *      - MODE_EXT_RMII_MAC,
- *      - MODE_EXT_RMII_PHY,
  */
 rtk_api_ret_t rtk_port_macForceLinkExt1_set(rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability)
 {
@@ -6102,7 +6304,6 @@ rtk_api_ret_t rtk_port_macForceLinkExt1_
  *      - MODE_EXT_TMII_PHY,
  *      - MODE_EXT_GMII,
  *      - MODE_EXT_RMII_MAC,
- *      - MODE_EXT_RMII_PHY,
  */
 rtk_api_ret_t rtk_port_macForceLinkExt_set(rtk_ext_port_t port, rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability)
 {
@@ -6116,7 +6317,7 @@ rtk_api_ret_t rtk_port_macForceLinkExt_s
     if (mode >=MODE_EXT_END)
         return RT_ERR_INPUT;
 
-    if (mode == MODE_EXT_RGMII_33V)
+    if ((mode == MODE_EXT_RGMII_33V) || (mode == MODE_EXT_RMII_PHY))
         return RT_ERR_INPUT;
 
     if (pPortability->forcemode > 1 || pPortability->speed > 2 || pPortability->duplex > 1 ||
@@ -6141,22 +6342,34 @@ rtk_api_ret_t rtk_port_macForceLinkExt_s
     else
         return RT_ERR_INPUT;
 
-    if ((retVal = rtl8367b_setAsicPortExtMode(port, mode)) != RT_ERR_OK)
-        return retVal;
+    if(mode == MODE_EXT_DISABLE)
+    {
+        memset(&ability, 0x00, sizeof(rtl8367b_port_ability_t));
+        if ((retVal = rtl8367b_setAsicPortForceLinkExt( (rtk_uint32)port, &ability)) != RT_ERR_OK)
+            return retVal;
 
-    if ((retVal = rtl8367b_getAsicPortForceLinkExt( (rtk_uint32)port, &ability)) != RT_ERR_OK)
-        return retVal;
+        if ((retVal = rtl8367b_setAsicPortExtMode(port, mode)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        if ((retVal = rtl8367b_setAsicPortExtMode(port, mode)) != RT_ERR_OK)
+            return retVal;
 
-    ability.forcemode = pPortability->forcemode;
-    ability.speed     = pPortability->speed;
-    ability.duplex    = pPortability->duplex;
-    ability.link      = pPortability->link;
-    ability.nway      = pPortability->nway;
-    ability.txpause   = pPortability->txpause;
-    ability.rxpause   = pPortability->rxpause;
+        if ((retVal = rtl8367b_getAsicPortForceLinkExt( (rtk_uint32)port, &ability)) != RT_ERR_OK)
+            return retVal;
 
-    if ((retVal = rtl8367b_setAsicPortForceLinkExt( (rtk_uint32)port, &ability)) != RT_ERR_OK)
-        return retVal;
+        ability.forcemode = pPortability->forcemode;
+        ability.speed     = pPortability->speed;
+        ability.duplex    = pPortability->duplex;
+        ability.link      = pPortability->link;
+        ability.nway      = pPortability->nway;
+        ability.txpause   = pPortability->txpause;
+        ability.rxpause   = pPortability->rxpause;
+
+        if ((retVal = rtl8367b_setAsicPortForceLinkExt( (rtk_uint32)port, &ability)) != RT_ERR_OK)
+            return retVal;
+    }
 
     return RT_ERR_OK;
 }
@@ -6740,6 +6953,7 @@ rtk_api_ret_t rtk_port_rgmiiDelayExt1_ge
  * Description:
  *      Set RGMII interface delay value for TX and RX.
  * Input:
+ *      port    - EXT port
  *      txDelay - TX delay value, 1 for delay 2ns and 0 for no-delay
  *      rxDelay - RX delay value, 0~7 for delay setup.
  * Output:
@@ -6792,6 +7006,7 @@ rtk_api_ret_t rtk_port_rgmiiDelayExt_set
  * Input:
  *      None
  * Output:
+ *      port     - EXT port
  *      pTxDelay - TX delay value
  *      pRxDelay - RX delay value
  * Return:
@@ -6852,13 +7067,43 @@ rtk_api_ret_t rtk_port_rgmiiDelayExt_get
 rtk_api_ret_t rtk_port_phyEnableAll_set(rtk_enable_t enable)
 {
     rtk_api_ret_t retVal;
+    rtk_uint32 data;
+    rtk_uint32 port;
 
     if (enable >= RTK_ENABLE_END)
         return RT_ERR_ENABLE;
 
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data)) != RT_ERR_OK)
+        return retVal;
+
     if ((retVal = rtl8367b_setAsicPortEnableAll(enable)) != RT_ERR_OK)
         return retVal;
 
+    if( (data == 0x0276) || (data == 0x0597) || (data == 0x6367) )
+    {
+        for(port = 0; port <= RTK_PHY_ID_MAX; port++)
+        {
+            if ((retVal = rtk_port_phyReg_get(port, PHY_CONTROL_REG, &data)) != RT_ERR_OK)
+                return retVal;
+
+            if (ENABLED == enable)
+            {
+                data &= 0xF7FF;
+                data |= 0x0200;
+            }
+            else
+            {
+                data |= 0x0800;
+            }
+
+            if ((retVal = rtk_port_phyReg_set(port, PHY_CONTROL_REG, data)) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+
     return RT_ERR_OK;
 
 }
@@ -6978,6 +7223,7 @@ rtk_api_ret_t rtk_port_efid_get(rtk_port
 rtk_api_ret_t rtk_port_phyComboPortMedia_set(rtk_port_t port, rtk_port_media_t media)
 {
     rtk_api_ret_t retVal;
+    rtk_uint32 data;
 
     if (port != RTK_PORT_COMBO_ID)
         return RT_ERR_PORT_ID;
@@ -6985,21 +7231,55 @@ rtk_api_ret_t rtk_port_phyComboPortMedia
     if (media >= PORT_MEDIA_END)
         return RT_ERR_INPUT;
 
-    if(media == PORT_MEDIA_FIBER)
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data)) != RT_ERR_OK)
+        return retVal;
+
+    if( (data == 0x0276) || (data == 0x0597) || (data == 0x6367) )
     {
-        if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_FIBER_CFG_2, 0x3945))!=RT_ERR_OK)
+        if(media == PORT_MEDIA_FIBER)
+        {
+            if ((retVal = rtl8367b_setAsicReg(0x6602, 0x8CD3))!=RT_ERR_OK)
             return retVal;
 
-        if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_UTP_FIB_DET, 0xd5b9))!=RT_ERR_OK)
-            return retVal;
+            if ((retVal = rtl8367b_setAsicReg(0x6601, 0x0426))!=RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367b_setAsicReg(0x6600, 0x00C0))!=RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_UTP_FIB_DET, RTL8367B_UTP_FIRST_OFFSET, 0))!=RT_ERR_OK)
+                return retVal;
+        }
+        else
+        {
+            if ((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_UTP_FIB_DET, RTL8367B_UTP_FIRST_OFFSET, 1))!=RT_ERR_OK)
+                return retVal;
+        }
     }
     else
     {
-        if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_FIBER_CFG_2, 0x3000))!=RT_ERR_OK)
-            return retVal;
+        if(media == PORT_MEDIA_FIBER)
+        {
+            if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_FIBER_CFG_2, 0x3f55))!=RT_ERR_OK)
+                return retVal;
 
-        if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_UTP_FIB_DET, 0x11bb))!=RT_ERR_OK)
-            return retVal;
+            if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_UTP_FIB_DET, 0xd1b9))!=RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_SDS_EXT_CFG15, 14, 1))!=RT_ERR_OK)
+                return retVal;
+        }
+        else
+        {
+            if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_FIBER_CFG_2, 0x35ff))!=RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367b_setAsicReg(RTL8367B_REG_UTP_FIB_DET, 0x11bb))!=RT_ERR_OK)
+                return retVal;
+        }
     }
 
     return RT_ERR_OK;
@@ -7025,21 +7305,40 @@ rtk_api_ret_t rtk_port_phyComboPortMedia
 rtk_api_ret_t rtk_port_phyComboPortMedia_get(rtk_port_t port, rtk_port_media_t *pMedia)
 {
     rtk_api_ret_t   retVal;
-    rtk_uint32      data1, data2;
+    rtk_uint32      data, data1, data2;
 
     if (port != RTK_PORT_COMBO_ID)
         return RT_ERR_PORT_ID;
 
-    if ((retVal = rtl8367b_getAsicReg(RTL8367B_REG_FIBER_CFG_2, &data1))!=RT_ERR_OK)
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
         return retVal;
 
-    if ((retVal = rtl8367b_getAsicReg(RTL8367B_REG_UTP_FIB_DET, &data2))!=RT_ERR_OK)
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data)) != RT_ERR_OK)
         return retVal;
 
-    if ((data1 == 0x3945) && (data2 == 0xd5b9))
-        *pMedia = PORT_MEDIA_FIBER;
+    if( (data == 0x0276) || (data == 0x0597) || (data == 0x6367) )
+    {
+        if ((retVal = rtl8367b_getAsicRegBit(RTL8367B_REG_UTP_FIB_DET, RTL8367B_UTP_FIRST_OFFSET, &data))!=RT_ERR_OK)
+            return retVal;
+
+        if(data == 1)
+            *pMedia = PORT_MEDIA_COPPER;
+        else
+            *pMedia = PORT_MEDIA_FIBER;
+    }
     else
-        *pMedia = PORT_MEDIA_COPPER;
+    {
+        if ((retVal = rtl8367b_getAsicReg(RTL8367B_REG_FIBER_CFG_2, &data1))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367b_getAsicReg(RTL8367B_REG_UTP_FIB_DET, &data2))!=RT_ERR_OK)
+            return retVal;
+
+        if ((data1 == 0x3f55) && (data2 == 0xd1b9))
+            *pMedia = PORT_MEDIA_FIBER;
+        else
+            *pMedia = PORT_MEDIA_COPPER;
+    }
 
     return RT_ERR_OK;
 }
@@ -8665,41 +8964,6 @@ rtk_api_ret_t rtk_vlan_protoAndPortBased
     return RT_ERR_OK;
 }
 
-#if defined CONFIG_RTL_CUSTOM_PASSTHRU
-
-int rtl8367_setProtocolBasedVLAN(rtk_vlan_proto_type_t proto_type,rtk_vlan_t cvid, int cmdFlag)
-{
-	rtk_port_t port;
-	int ret;
-	rtk_vlan_protoAndPortInfo_t info;
-	info.proto_type=proto_type;
-   	info.frame_type=FRAME_TYPE_ETHERNET;
-    info.cvid=cvid;
-    info.cpri=0;
-	
-	if(cmdFlag==TRUE)
-	{
-		//printk("ADD[%s]:[%d].\n",__FUNCTION__,__LINE__);
-		/*add */
-		for(port=0;port<5;port++){
-			
-			ret=rtk_vlan_protoAndPortBasedVlan_add(port, info);
-			
-		}
-	}
-	else
-	{
-		//printk("DEL[%s]:[%d].\n",__FUNCTION__,__LINE__);
-		/*delete */
-		for(port=0;port<5;port++){
-			
-			ret=rtk_vlan_protoAndPortBasedVlan_del(port,  proto_type, FRAME_TYPE_ETHERNET);
-		}
-	}
-	return ret;
-}
-#endif
-
 /* Function Name:
  *      rtk_vlan_tagMode_set
  * Description:
@@ -9205,6 +9469,15 @@ rtk_api_ret_t rtk_l2_addr_add(rtk_mac_t
     if (pL2_data->efid> RTL8367B_EFIDMAX)
         return RT_ERR_INPUT;
 
+    if (pL2_data->priority > RTL8367B_PRIMAX)
+        return RT_ERR_INPUT;
+
+    if (pL2_data->sa_pri_en >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (pL2_data->fwd_pri_en >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
     memset(&l2Table, 0, sizeof(rtl8367b_luttb));
 
     /* fill key (MAC,FID) to get L2 entry */
@@ -9229,6 +9502,9 @@ rtk_api_ret_t rtk_l2_addr_add(rtk_mac_t
         l2Table.l3lookup    = 0;
         l2Table.auth        = pL2_data->auth;
         l2Table.age         = 6;
+        l2Table.lut_pri     = pL2_data->priority;
+        l2Table.sa_en       = pL2_data->sa_pri_en;
+        l2Table.fwd_en      = pL2_data->fwd_pri_en;
         retVal = rtl8367b_setAsicL2LookupTb(&l2Table);
 
         return retVal;
@@ -9248,6 +9524,9 @@ rtk_api_ret_t rtk_l2_addr_add(rtk_mac_t
         l2Table.l3lookup    = 0;
         l2Table.auth        = pL2_data->auth;
         l2Table.age         = 6;
+        l2Table.lut_pri     = pL2_data->priority;
+        l2Table.sa_en       = pL2_data->sa_pri_en;
+        l2Table.fwd_en      = pL2_data->fwd_pri_en;
 
         if ((retVal = rtl8367b_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
             return retVal;
@@ -9320,6 +9599,9 @@ rtk_api_ret_t rtk_l2_addr_get(rtk_mac_t
     pL2_data->auth      = l2Table.auth;
     pL2_data->sa_block  = l2Table.sa_block;
     pL2_data->da_block  = l2Table.da_block;
+    pL2_data->priority  = l2Table.lut_pri;
+    pL2_data->sa_pri_en = l2Table.sa_en;
+    pL2_data->fwd_pri_en= l2Table.fwd_en;
 
     return RT_ERR_OK;
 }
@@ -9393,6 +9675,9 @@ rtk_api_ret_t rtk_l2_addr_next_get(rtk_l
     pL2_data->auth      = l2Table.auth;
     pL2_data->sa_block  = l2Table.sa_block;
     pL2_data->da_block  = l2Table.da_block;
+    pL2_data->priority  = l2Table.lut_pri;
+    pL2_data->sa_pri_en = l2Table.sa_en;
+    pL2_data->fwd_pri_en= l2Table.fwd_en;
 
     *pAddress = l2Table.address;
 
@@ -9457,6 +9742,9 @@ rtk_api_ret_t rtk_l2_addr_del(rtk_mac_t
         l2Table.da_block = 0;
         l2Table.auth = 0;
         l2Table.age = 0;
+        l2Table.lut_pri = 0;
+        l2Table.sa_en = 0;
+        l2Table.fwd_en = 0;
         retVal = rtl8367b_setAsicL2LookupTb(&l2Table);
         return retVal;
     }
@@ -11639,6 +11927,7 @@ rtk_api_ret_t rtk_svlan_c2s_add(rtk_vlan
     rtk_uint32 empty_idx;
     rtk_uint32 evid, pmsk, svidx, c2s_svidx;
     rtl8367b_svlan_memconf_t svlanMemConf;
+    rtk_uint16 doneFlag;
 
     if (vid > RTL8367B_VIDMAX)
         return RT_ERR_VLAN_VID;
@@ -11651,6 +11940,7 @@ rtk_api_ret_t rtk_svlan_c2s_add(rtk_vlan
 
     empty_idx = 0xFFFF;
     svidx = 0xFFFF;
+    doneFlag = FALSE;
 
     for (i = 0; i<= RTL8367B_SVIDXMAX; i++)
     {
@@ -11687,38 +11977,44 @@ rtk_api_ret_t rtk_svlan_c2s_add(rtk_vlan
                 {
                     /* New svidx, remove src_port and find a new slot to add a new enrty */
                     pmsk = pmsk & ~(1 << src_port);
-                    if ((retVal = rtl8367b_setAsicSvlanC2SConf(i, vid, pmsk, svidx)) != RT_ERR_OK)
+                    if(pmsk == 0)
+                        c2s_svidx = 0;
+
+                    if ((retVal = rtl8367b_setAsicSvlanC2SConf(i, vid, pmsk, c2s_svidx)) != RT_ERR_OK)
                         return retVal;
                 }
             }
             else
             {
-                if(c2s_svidx == svidx)
+                if(c2s_svidx == svidx && doneFlag == FALSE)
                 {
                     pmsk = pmsk | (1 << src_port);
                     if ((retVal = rtl8367b_setAsicSvlanC2SConf(i, vid, pmsk, svidx)) != RT_ERR_OK)
                         return retVal;
 
-                    return RT_ERR_OK;
+                    doneFlag = TRUE;
                 }
             }
         }
-        else if (evid==0&&pmsk==0&&c2s_svidx==0)
+        else if (evid==0&&pmsk==0)
         {
             empty_idx = i;
         }
     }
 
-    if (0xFFFF != empty_idx)
+    if (0xFFFF != empty_idx && doneFlag ==FALSE)
     {
        if ((retVal = rtl8367b_setAsicSvlanC2SConf(empty_idx, vid, (1<<src_port), svidx)) != RT_ERR_OK)
            return retVal;
        return RT_ERR_OK;
     }
+    else if(doneFlag == TRUE)
+    {
+       return RT_ERR_OK;
+    }
 
     return RT_ERR_OUT_OF_RANGE;
 }
-
 /* Function Name:
  *      rtk_svlan_c2s_del
  * Description:
@@ -13887,9 +14183,13 @@ rtk_uint32 r8367_cpu_port = RTL8367B_POR
 rtk_api_ret_t rtk_switch_init(void)
 {
     rtk_uint16      i;
-    rtk_uint32      data;
+    rtk_uint32      data, data2, regData;
     rtk_api_ret_t   retVal;
     rtk_uint32      phy;
+#if defined(CHIP_AUTO_DETECT)
+    rtk_uint32      polling_time;
+    rtk_uint32      chip_idx = 0;
+#endif
 
     if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
         return retVal;
@@ -13897,26 +14197,124 @@ rtk_api_ret_t rtk_switch_init(void)
     if((retVal = rtl8367b_getAsicReg(0x1301, &data)) != RT_ERR_OK)
         return retVal;
 
-#if defined(RTK_X86_ASICDRV)
-    if(init_para == ChipData00)
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data2)) != RT_ERR_OK)
+        return retVal;
+
+#if defined(CHIP_AUTO_DETECT)
+    if((retVal = rtl8367b_setAsicReg(0x1371, 0x000F)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367b_setAsicReg(0x1370, 0x0002)) != RT_ERR_OK)
+        return retVal;
+
+    polling_time = 0;
+    while(polling_time < 10000)
     {
-        if(data & 0xF000)
-        {
-            init_para = ChipData01;
-            init_size = (sizeof(ChipData01) / ((sizeof(rtk_uint16))*2));
-        }
-        else
-            init_size = (sizeof(ChipData00) / ((sizeof(rtk_uint16))*2));
+        if((retVal = rtl8367b_getAsicReg(0x1370, &data)) != RT_ERR_OK)
+            return retVal;
+
+        if((data & 0x0004) == 0)
+            break;
+
+        polling_time++;
     }
-    else if(init_para == ChipData10)
+
+    if(polling_time >= 10000)
+        return RT_ERR_BUSYWAIT_TIMEOUT;
+
+    if((retVal = rtl8367b_getAsicReg(0x1373, &data)) != RT_ERR_OK)
+        return retVal;
+
+    chip_idx |= ((data & 0x000F) << 4);
+
+    if((retVal = rtl8367b_setAsicReg(0x1371, 0x000D)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367b_setAsicReg(0x1370, 0x0002)) != RT_ERR_OK)
+        return retVal;
+
+    polling_time = 0;
+    while(polling_time < 10000)
     {
-        if(data & 0xF000)
-        {
-            init_para = ChipData11;
-            init_size = (sizeof(ChipData11) / ((sizeof(rtk_uint16))*2));
+        if((retVal = rtl8367b_getAsicReg(0x1370, &data)) != RT_ERR_OK)
+            return retVal;
+
+        if((data & 0x0004) == 0)
+            break;
+
+        polling_time++;
+    }
+
+    if(polling_time >= 10000)
+        return RT_ERR_BUSYWAIT_TIMEOUT;
+
+    if((retVal = rtl8367b_getAsicReg(0x1373, &data)) != RT_ERR_OK)
+        return retVal;
+
+    chip_idx |= (data & 0x000F);
+
+
+    if((chip_idx & 0x00F0) == 0x0000)
+    {
+        /* RTL8365MB & RTL8305MB */
+        if((chip_idx & 0x000F) >> 3)
+        {
+            /* RTL8305MB */
+            init_para = ChipData81;
+            init_size = (sizeof(ChipData81) / ((sizeof(rtk_uint16))*2));
+        }
+        else if((chip_idx & 0x000F) >> 2)
+        {
+            /* RTL8365MB */
+            init_para = ChipData11;
+            init_size = (sizeof(ChipData11) / ((sizeof(rtk_uint16))*2));
+        }
+        else if((chip_idx & 0x000F) >> 1)
+        {
+            /* RTL8305MB */
+            init_para = ChipData81;
+            init_size = (sizeof(ChipData81) / ((sizeof(rtk_uint16))*2));
+        }
+        else if(chip_idx & 0x000F)
+        {
+            /* RTL8365MB */
+            init_para = ChipData11;
+            init_size = (sizeof(ChipData11) / ((sizeof(rtk_uint16))*2));
         }
         else
-            init_size = (sizeof(ChipData10) / ((sizeof(rtk_uint16))*2));
+            return RT_ERR_CHIP_NOT_SUPPORTED;
+    }
+    else
+        return RT_ERR_CHIP_NOT_SUPPORTED;
+
+#elif defined(RTK_X86_ASICDRV)
+    if(init_para == ChipData00)
+    {
+        if(data & 0xF000)
+        {
+            init_para = ChipData01;
+            init_size = (sizeof(ChipData01) / ((sizeof(rtk_uint16))*2));
+        }
+        else
+            init_size = (sizeof(ChipData00) / ((sizeof(rtk_uint16))*2));
+    }
+    else if(init_para == ChipData10)
+    {
+        if( (data2 == 0x0276) || (data2 == 0x0597) || (data2 == 0x6367))
+        {
+            init_para = ChipData12;
+            init_size = (sizeof(ChipData12) / ((sizeof(rtk_uint16))*2));
+        }
+        else
+        {
+            if(data & 0xF000)
+            {
+                init_para = ChipData11;
+                init_size = (sizeof(ChipData11) / ((sizeof(rtk_uint16))*2));
+            }
+            else
+                init_size = (sizeof(ChipData10) / ((sizeof(rtk_uint16))*2));
+        }
     }
     else if(init_para == ChipData20)
     {
@@ -13930,13 +14328,21 @@ rtk_api_ret_t rtk_switch_init(void)
     }
     else if(init_para == ChipData30)
     {
-        if(data & 0xF000)
+        if( (data2 == 0x0276) || (data2 == 0x0597) || (data2 == 0x6367))
         {
-            init_para = ChipData31;
-            init_size = (sizeof(ChipData31) / ((sizeof(rtk_uint16))*2));
+            init_para = ChipData32;
+            init_size = (sizeof(ChipData32) / ((sizeof(rtk_uint16))*2));
         }
         else
-            init_size = (sizeof(ChipData30) / ((sizeof(rtk_uint16))*2));
+        {
+            if(data & 0xF000)
+            {
+                init_para = ChipData31;
+                init_size = (sizeof(ChipData31) / ((sizeof(rtk_uint16))*2));
+            }
+            else
+                init_size = (sizeof(ChipData30) / ((sizeof(rtk_uint16))*2));
+        }
     }
     else if(init_para == ChipData40)
     {
@@ -13998,6 +14404,24 @@ rtk_api_ret_t rtk_switch_init(void)
         else
             init_size = (sizeof(ChipData90) / ((sizeof(rtk_uint16))*2));
     }
+    else if(init_para == ChipData100)
+    {
+        if( (data2 == 0x0276) || (data2 == 0x0597) || (data2 == 0x6367))
+        {
+            init_para = ChipData102;
+            init_size = (sizeof(ChipData102) / ((sizeof(rtk_uint16))*2));
+        }
+        else
+        {
+            if(data & 0xF000)
+            {
+                init_para = ChipData101;
+                init_size = (sizeof(ChipData101) / ((sizeof(rtk_uint16))*2));
+            }
+            else
+                init_size = (sizeof(ChipData100) / ((sizeof(rtk_uint16))*2));
+        }
+    }
 
 #elif defined(CHIP_RTL8363SB)
     if(data & 0xF000)
@@ -14012,15 +14436,23 @@ rtk_api_ret_t rtk_switch_init(void)
     }
 
 #elif defined(CHIP_RTL8365MB)
-    if(data & 0xF000)
+    if( (data2 == 0x0276) || (data2 == 0x0597) || (data2 == 0x6367))
     {
-        init_para = ChipData11;
-        init_size = (sizeof(ChipData11) / ((sizeof(rtk_uint16))*2));
+        init_para = ChipData12;
+        init_size = (sizeof(ChipData12) / ((sizeof(rtk_uint16))*2));
     }
     else
     {
-        init_para = ChipData10;
-        init_size = (sizeof(ChipData10) / ((sizeof(rtk_uint16))*2));
+        if(data & 0xF000)
+        {
+            init_para = ChipData11;
+            init_size = (sizeof(ChipData11) / ((sizeof(rtk_uint16))*2));
+        }
+        else
+        {
+            init_para = ChipData10;
+            init_size = (sizeof(ChipData10) / ((sizeof(rtk_uint16))*2));
+        }
     }
 
 #elif defined(CHIP_RTL8367_VB)
@@ -14036,15 +14468,23 @@ rtk_api_ret_t rtk_switch_init(void)
     }
 
 #elif defined(CHIP_RTL8367RB)
-    if(data & 0xF000)
+    if( (data2 == 0x0276) || (data2 == 0x0597) || (data2 == 0x6367))
     {
-        init_para = ChipData31;
-        init_size = (sizeof(ChipData31) / ((sizeof(rtk_uint16))*2));
+        init_para = ChipData32;
+        init_size = (sizeof(ChipData32) / ((sizeof(rtk_uint16))*2));
     }
     else
     {
-        init_para = ChipData30;
-        init_size = (sizeof(ChipData30) / ((sizeof(rtk_uint16))*2));
+        if(data & 0xF000)
+        {
+            init_para = ChipData31;
+            init_size = (sizeof(ChipData31) / ((sizeof(rtk_uint16))*2));
+        }
+        else
+        {
+            init_para = ChipData30;
+            init_size = (sizeof(ChipData30) / ((sizeof(rtk_uint16))*2));
+        }
     }
 
 #elif defined(CHIP_RTL8367R_VB)
@@ -14117,24 +14557,49 @@ rtk_api_ret_t rtk_switch_init(void)
         init_para = ChipData90;
         init_size = (sizeof(ChipData90) / ((sizeof(rtk_uint16))*2));
     }
-
+#elif defined(CHIP_RTL8367N)
+    if( (data2 == 0x0276) || (data2 == 0x0597) || (data2 == 0x6367))
+    {
+        init_para = ChipData102;
+        init_size = (sizeof(ChipData102) / ((sizeof(rtk_uint16))*2));
+    }
+    else
+    {
+        if(data & 0xF000)
+        {
+            init_para = ChipData101;
+            init_size = (sizeof(ChipData101) / ((sizeof(rtk_uint16))*2));
+        }
+        else
+        {
+            init_para = ChipData100;
+            init_size = (sizeof(ChipData100) / ((sizeof(rtk_uint16))*2));
+        }
+    }
 #else
     /* Not define CHIP, Error */
     init_para = NULL;
 #endif
 
-#ifdef ENHANCE_ETH_COMPATILITY
+#ifdef CONFIG_RTL_8367R_SUPPORT
 	if ((data & 0x00F0) == 0x0010) {  // RTL8367R_VB
 		r8367_cpu_port = RTL8367B_PORT5_ENABLE_OFFSET;
 
 		init_para = ChipData41;
 		init_size = (sizeof(ChipData41) / ((sizeof(rtk_uint16))*2));
 	}	
-	else  {	// RTL8367RB
+	else  {	// RTL8367RB or RTL8367RB-VB
+		if( (data2 == 0x0276) || (data2 == 0x0597) || (data2 == 0x6367))	// RTL8367RB-VB
+		{
+			init_para = ChipData32;
+			init_size = (sizeof(ChipData32) / ((sizeof(rtk_uint16))*2));
+		}
+		else	// RTL8367RB
+		{
+			init_para = ChipData31;
+			init_size = (sizeof(ChipData31) / ((sizeof(rtk_uint16))*2));
+		}	
 		r8367_cpu_port = RTL8367B_PORT6_ENABLE_OFFSET;
-
-		init_para = ChipData31;
-		init_size = (sizeof(ChipData31) / ((sizeof(rtk_uint16))*2));
 	}
 #else
 	if ((data & 0x00F0) == 0x0010) {  // RTL8367R_VB
@@ -14148,20 +14613,39 @@ rtk_api_ret_t rtk_switch_init(void)
         return RT_ERR_CHIP_NOT_SUPPORTED;
 #endif
 
-    /* Analog parameter update. ID:0001 */
-    for(phy = 0; phy <= RTK_PHY_ID_MAX; phy++)
+    if( (data2 == 0x0276) || (data2 == 0x0597) || (data2 == 0x6367) )
     {
-        if((retVal = rtl8367b_setAsicPHYReg(phy, 31, 0x7)) != RT_ERR_OK)
-            return retVal;
+        for(phy = 0; phy <= RTK_PHY_ID_MAX; phy++)
+        {
+            if((retVal = rtl8367b_getAsicPHYOCPReg(phy, 0xA428, &regData)) != RT_ERR_OK)
+                return retVal;
 
-        if((retVal = rtl8367b_setAsicPHYReg(phy, 30, 0x2c)) != RT_ERR_OK)
-            return retVal;
+            regData &= ~(0x0200);
+            if((retVal = rtl8367b_setAsicPHYOCPReg(phy, 0xA428, regData)) != RT_ERR_OK)
+                return retVal;
+        }
 
-        if((retVal = rtl8367b_setAsicPHYReg(phy, 25, 0x0504)) != RT_ERR_OK)
+        if((retVal = rtl8367b_setAsicReg(RTL8367B_REG_UTP_FIB_DET, 0x15BB)) != RT_ERR_OK)
             return retVal;
+    }
 
-        if((retVal = rtl8367b_setAsicPHYReg(phy, 31, 0x0)) != RT_ERR_OK)
-            return retVal;
+    if( (data2 != 0x0276) && (data2 != 0x0597) && (data2 != 0x6367) )
+    {
+        /* Analog parameter update. ID:0001 */
+        for(phy = 0; phy <= RTK_PHY_ID_MAX; phy++)
+        {
+            if((retVal = rtl8367b_setAsicPHYReg(phy, 31, 0x7)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367b_setAsicPHYReg(phy, 30, 0x2c)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367b_setAsicPHYReg(phy, 25, 0x0504)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367b_setAsicPHYReg(phy, 31, 0x0)) != RT_ERR_OK)
+                return retVal;
+        }
     }
 
     for(i = 0; i < init_size; i++)
@@ -14170,1122 +14654,719 @@ rtk_api_ret_t rtk_switch_init(void)
             return retVal;
     }
 
-    /* Analog parameter update. ID:0002 */
-    if((retVal = rtl8367b_setAsicPHYReg(1, 31, 0x2)) != RT_ERR_OK)
-        return retVal;
+    if( (data2 != 0x0276) && (data2 != 0x0597) && (data2 != 0x6367) )
+    {
+        /* Analog parameter update. ID:0002 */
+        if((retVal = rtl8367b_setAsicPHYReg(1, 31, 0x2)) != RT_ERR_OK)
+            return retVal;
 
-    if((retVal = rtl8367b_getAsicPHYReg(1, 17, &data)) != RT_ERR_OK)
-        return retVal;
+        if((retVal = rtl8367b_getAsicPHYReg(1, 17, &data)) != RT_ERR_OK)
+            return retVal;
 
-    data |= 0x01E0;
+        data |= 0x01E0;
 
-    if((retVal = rtl8367b_setAsicPHYReg(1, 17, data)) != RT_ERR_OK)
-        return retVal;
+        if((retVal = rtl8367b_setAsicPHYReg(1, 17, data)) != RT_ERR_OK)
+            return retVal;
 
-    if((retVal = rtl8367b_setAsicPHYReg(1, 31, 0x0)) != RT_ERR_OK)
-        return retVal;
+        if((retVal = rtl8367b_setAsicPHYReg(1, 31, 0x0)) != RT_ERR_OK)
+            return retVal;
+
+        /* Analog parameter update. ID:0003 */
+        for(phy = 0; phy <= 4; phy++)
+        {
+            if ((retVal = rtl8367b_setAsicPHYReg(phy, 0x1F, 0x0007)) != RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367b_setAsicPHYReg(phy, 0x1E, 0x002C)) != RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367b_setAsicPHYReg(phy, 0x18, 0x008B)) != RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367b_setAsicPHYReg(phy, 0x19, 0x0504)) != RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367b_setAsicPHYReg(phy, 0x1F, 0)) != RT_ERR_OK)
+                return retVal;
+        }
 
+    }
 
     if((retVal = rtl8367b_setAsicRegBit(0x18e0, 0, 0)) != RT_ERR_OK)
         return retVal;
 
-    if((retVal = rtl8367b_setAsicReg(0x1303, 0x0778)) != RT_ERR_OK)
-        return retVal;
-    if((retVal = rtl8367b_setAsicReg(0x1304, 0x7777)) != RT_ERR_OK)
-        return retVal;
-    if((retVal = rtl8367b_setAsicReg(0x13E2, 0x01FE)) != RT_ERR_OK)
-        return retVal;
+    if( (data2 != 0x0276) && (data2 != 0x0597) && (data2 != 0x6367) )
+    {
+        if((retVal = rtl8367b_setAsicReg(0x1303, 0x0778)) != RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367b_setAsicReg(0x1304, 0x7777)) != RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367b_setAsicReg(0x13E2, 0x01FE)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        if((retVal = rtl8367b_setAsicReg(0x1303, 0x06D6)) != RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367b_setAsicReg(0x1304, 0x0700)) != RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367b_setAsicReg(0x13E2, 0x003F)) != RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367b_setAsicReg(0x13F9, 0x0090)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367b_setAsicReg(0x121e, 0x03CA)) != RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367b_setAsicReg(0x1233, 0x0352)) != RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367b_setAsicReg(0x1237, 0x00a0)) != RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367b_setAsicReg(0x123a, 0x0030)) != RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367b_setAsicReg(0x1239, 0x0084)) != RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367b_setAsicReg(0x0301, 0x1000)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367b_setAsicReg(0x09DA, 0x0017)) != RT_ERR_OK)
+            return retVal;
+
+    }
 
     return RT_ERR_OK;
 }
 
-#define ENABLE_8367RB_RGMII2	1
-
-#ifdef ENABLE_8367RB_RGMII2
-// for tr181
-int rtk_rgmii_set(int enable)
+/* Function Name:
+ *      rtk_switch_maxPktLen_set
+ * Description:
+ *      Set the max packet length of the specific unit
+ * Input:
+ *      len - max packet length
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT 		- Invalid input parameters.
+ * Note:
+ *      The API can set max packet length of the specific unit to
+ *      - MAXPKTLEN_1522B,
+ *      - MAXPKTLEN_1536B,
+ *      - MAXPKTLEN_1552B,
+ *      - MAXPKTLEN_16000B.
+ */
+rtk_api_ret_t rtk_switch_maxPktLen_set(rtk_switch_maxPktLen_t len)
 {
-    rtk_port_mac_ability_t mac_cfg;
+    rtk_api_ret_t retVal;
 
-    mac_cfg.forcemode = MAC_FORCE;
-    mac_cfg.speed = SPD_1000M;
-    mac_cfg.duplex = FULL_DUPLEX;
-    if (enable == TRUE)
-        mac_cfg.link = PORT_LINKUP;
-    else		
-        mac_cfg.link = PORT_LINKDOWN;
-    mac_cfg.nway = DISABLED;
-    mac_cfg.txpause = ENABLED;
-    mac_cfg.rxpause = ENABLED;
-    rtk_port_macForceLinkExt_set(EXT_PORT_2, MODE_EXT_RGMII, &mac_cfg);
+    if (len>=MAXPKTLEN_END)
+        return RT_ERR_INPUT;
 
-    return 0;
+    if ((retVal = rtl8367b_setAsicMaxLengthInRx(len)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
 }
-#endif
 
-int RTL8367R_init(void)
+/* Function Name:
+ *      rtk_switch_maxPktLen_get
+ * Description:
+ *      Get the max packet length of the specific unit
+ * Input:
+ *      None
+ * Output:
+ *      pLen - pointer to the max packet length
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      The API can set max packet length of the specific unit.
+ */
+rtk_api_ret_t rtk_switch_maxPktLen_get(rtk_switch_maxPktLen_t *pLen)
 {
-    rtk_portmask_t portmask;
-    unsigned int ret;
-    //unsigned int regData;
+    rtk_api_ret_t retVal;
 
-    /* Set external interface 0 to RGMII with Force mode, 1000M, Full-duple, enable TX&RX pause*/
-    rtk_port_mac_ability_t mac_cfg;
-    rtk_mode_ext_t mode ;
- 
-    /* Initial Chip */
-    ret = rtk_switch_init();
- 
-    /* Enable LED Group 0&1 from P0 to P4 */
-    portmask.bits[0]=0x1F;
-    rtk_led_enable_set(LED_GROUP_0, portmask);
-    rtk_led_enable_set(LED_GROUP_1, portmask);
- 
-    mode = MODE_EXT_RGMII ;
-    mac_cfg.forcemode = MAC_FORCE;
-    mac_cfg.speed = SPD_1000M;
-    mac_cfg.duplex = FULL_DUPLEX;
-    mac_cfg.link = PORT_LINKUP;
-    mac_cfg.nway = DISABLED;
-    mac_cfg.txpause = ENABLED;
-    mac_cfg.rxpause = ENABLED;
-    rtk_port_macForceLinkExt_set(EXT_PORT_1,mode,&mac_cfg);
- 
-#ifdef ENABLE_8367RB_RGMII2
-    mode = MODE_EXT_RGMII ;
-    mac_cfg.forcemode = MAC_FORCE;
-    mac_cfg.speed = SPD_1000M;
-    mac_cfg.duplex = FULL_DUPLEX;
-    mac_cfg.link = PORT_LINKUP;
-    mac_cfg.nway = DISABLED;
-    mac_cfg.txpause = ENABLED;
-    mac_cfg.rxpause = ENABLED;
-    rtk_port_macForceLinkExt_set(EXT_PORT_2,mode,&mac_cfg);
-#endif
+    if ((retVal = rtl8367b_getAsicMaxLengthInRx(pLen)) != RT_ERR_OK)
+        return retVal;
 
-    /* Set RGMII Interface 0 TX delay to 2ns and RX to step 4 */
-    // set the tx/rx delay in 8197D site
-    //rtk_port_rgmiiDelayExt_set(EXT_PORT_1, 1, 4);
-    //rtk_port_rgmiiDelayExt_set(EXT_PORT_1, 0, 0);
-    rtk_port_rgmiiDelayExt_set(EXT_PORT_1, 0, 2); // change rxDelay to 2 to enhance the compatibility of 8197D and 8367RB
- 
-    /* set port 5 as CPU port */
-    rtk_cpu_enable_set(ENABLE);
-    rtk_cpu_tagPort_set(RTK_EXT_1_MAC, CPU_INSERT_TO_NONE);
- 
-    // for LED on Realtek 8197D+8367RB
-    if (r8367_cpu_port == RTL8367B_PORT6_ENABLE_OFFSET) {    // 8367RB
-#ifdef RTL8367RB_USE_ONE_LED_PER_PORT
-        rtl8367b_setAsicReg(0x1B03, 0x0222);
-#else
-        /* demo board use 2 LEDs for each port */	
-        rtl8367b_setAsicReg(0x1B03, 0x0936);
-#endif
-    }
+    return RT_ERR_OK;
+}
 
-#if 1
-    // for 802.11ac logo 4.2.40 test (udp test item)
-    rtl8367b_setAsicReg(0x121f, 0x01D6);
-    rtl8367b_setAsicReg(0x1220, 0x01B8);
-    rtl8367b_setAsicReg(0x1221, 0x01CC);
-    rtl8367b_setAsicReg(0x1222, 0x01AE);
-    rtl8367b_setAsicReg(0x1223, 0x0302);
-    rtl8367b_setAsicReg(0x1224, 0x02E4);
-    rtl8367b_setAsicReg(0x1225, 0x02D0);
-    rtl8367b_setAsicReg(0x1226, 0x02A8);	
-#endif
+/* Function Name:
+ *      rtk_switch_portMaxPktLen_set
+ * Description:
+ *      Set 2nd max packet length configuration
+ * Input:
+ *      port    - Port ID
+ *      length  - Length(1522 bytes, 1536 bytes, 1552 bytes, 16000 bytes)
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      The API can set 2nd max packet length configuration.
+ *      The parameter "port" indicates which port would follow 2nd configuration.
+ *      If the paramter "length" is as same as 1st configuration, this API
+ *      would set the port back to 1st configuration. Users should always use
+ *      rtk_switch_maxPktLen_set to setup 1st configuration for whole system
+ *      setting and then use rtk_switch_portMaxPktLen_set to setup a per port
+ *      configuration.
+ */
+rtk_api_ret_t rtk_switch_portMaxPktLen_set(rtk_port_t port, rtk_uint32 length)
+{
+    rtk_switch_maxPktLen_t  pkt_len, curr_pkt_len;
+    rtk_api_ret_t           retVal;
+    rtk_uint32              maxLength, pmaskGiga, pmask100M;
 
-#if defined(CONFIG_RTK_REFINE_PORT_DUPLEX_MODE)
-	rtk_forceFull_init();
-#endif
+    if(port > RTK_PORT_ID_MAX)
+        return RT_ERR_PORT_ID;
 
-#if defined(CONFIG_LAN_WAN_ISOLATION)
-	{
-	rtk_portmask_t pm;
-	
-	pm.bits[0] = 0xff;
-	rtk_port_isolation_set(0, pm);
-	rtk_port_isolation_set(1, pm);
-	rtk_port_isolation_set(2, pm);
-	rtk_port_isolation_set(3, pm);
-	rtk_port_isolation_set(4, pm);
-	}
-#endif
+    if(length == 1522)
+        pkt_len = MAXPKTLEN_1522B;
+    else if(length == 1536)
+        pkt_len = MAXPKTLEN_1536B;
+    else if(length == 1552)
+        pkt_len = MAXPKTLEN_1552B;
+    else if(length == 16000)
+        pkt_len = MAXPKTLEN_16000B;
+    else
+        return RT_ERR_INPUT;
 
-    return ret; 
-}
+    if ((retVal = rtl8367b_getAsicMaxLengthInRx(&curr_pkt_len)) != RT_ERR_OK)
+        return retVal;
 
-#define BIT(nr)			(1UL << (nr))
-#define WAN_VID			8
-#define LAN_VID			9
-#if defined(CONFIG_RTL_EXCHANGE_PORTMASK)
-#define	RTL8367R_WAN			0		// WAN port is set to 8367R port 0
-#else
-#define	RTL8367R_WAN			4		// WAN port is set to 8367R port 4
-#endif
+    if(curr_pkt_len == pkt_len)
+    {
+        if ((retVal = rtl8367b_getAsicMaxLengthAltTxRx(&maxLength, &pmaskGiga, &pmask100M)) != RT_ERR_OK)
+            return retVal;
 
-#define	RTL_WANPORT_MASK		(0x1 << RTL8367R_WAN)
-#define	RTL_LANPORT_MASK		(0x1f & (~RTL_WANPORT_MASK))
+        pmaskGiga &= ~(0x0001 << port);
+        pmask100M &= ~(0x0001 << port);
 
-#define GATEWAY_MODE				0
-#define BRIDGE_MODE				1
+        if ((retVal = rtl8367b_setAsicMaxLengthAltTxRx(maxLength, pmaskGiga, pmask100M)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        if ((retVal = rtl8367b_getAsicMaxLengthAltTxRx(&maxLength, &pmaskGiga, &pmask100M)) != RT_ERR_OK)
+            return retVal;
 
-static  int rtl8197d_op_mode = 0;
-extern rtk_uint32 r8367_cpu_port;
+        pmaskGiga |= (0x0001 << port);
+        pmask100M |= (0x0001 << port);
 
-int RTL8367R_vlan_init(void)
+        if ((retVal = rtl8367b_setAsicMaxLengthAltTxRx(pkt_len, pmaskGiga, pmask100M)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_portMaxPktLen_get
+ * Description:
+ *      Get 2nd max packet length configuration
+ * Input:
+ *      port    - Port ID
+ * Output:
+ *      pLength  - Length(1522 bytes, 1536 bytes, 1552 bytes, 16000 bytes)
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      The API can get 2nd max packet length configuration.
+ *      If "port" is not in the 2nd configuration, the setting of
+ *      1st configuration woill be returned.
+ */
+rtk_api_ret_t rtk_switch_portMaxPktLen_get(rtk_port_t port, rtk_uint32 *pLength)
 {
-	int i, retval;
-	rtk_portmask_t mbrmsk, untagmsk;
+    rtk_switch_maxPktLen_t  curr_pkt_len;
+    rtk_api_ret_t           retVal;
+    rtk_uint32              maxLength, pmaskGiga, pmask100M;
 
-	/* for lan */
-	mbrmsk.bits[0] = RTL_LANPORT_MASK|BIT(r8367_cpu_port);
-	untagmsk.bits[0] = RTL_LANPORT_MASK;
-	retval = rtk_vlan_set(LAN_VID, mbrmsk, untagmsk, 0);
+    if(port > RTK_PORT_ID_MAX)
+        return RT_ERR_PORT_ID;
 
-	for(i=0;i<5;i++) {
-		if  ((1<<i)&RTL_LANPORT_MASK)
-		{
-			retval = rtk_vlan_portPvid_set(i, LAN_VID, 0);			
-		}
-	}
-		
-	/* for wan */
-	mbrmsk.bits[0] = RTL_WANPORT_MASK|BIT(r8367_cpu_port);
-	untagmsk.bits[0] = RTL_WANPORT_MASK;
-	retval = rtk_vlan_set(WAN_VID, mbrmsk, untagmsk, 1);
+    if ((retVal = rtl8367b_getAsicMaxLengthAltTxRx(&maxLength, &pmaskGiga, &pmask100M)) != RT_ERR_OK)
+        return retVal;
 
-	for(i=0;i<5;i++) {
-		if  ((1<<i)&RTL_WANPORT_MASK)
-		{
-			retval = rtk_vlan_portPvid_set(i, WAN_VID, 0);
-		}
-	}
+    if ((retVal = rtl8367b_getAsicMaxLengthInRx(&curr_pkt_len)) != RT_ERR_OK)
+        return retVal;
 
-	rtl8197d_op_mode = GATEWAY_MODE;
-	return 0;
+    if(pmaskGiga & (0x0001 << port))
+    {
+        if(maxLength == MAXPKTLEN_1522B)
+            *pLength = 1522;
+        else if(maxLength == MAXPKTLEN_1536B)
+            *pLength = 1536;
+        else if(maxLength == MAXPKTLEN_1552B)
+            *pLength = 1552;
+        else if(maxLength == MAXPKTLEN_16000B)
+            *pLength = 16000;
+        else
+            return RT_ERR_FAILED;
+    }
+    else
+    {
+        if(curr_pkt_len == MAXPKTLEN_1522B)
+            *pLength = 1522;
+        else if(curr_pkt_len == MAXPKTLEN_1536B)
+            *pLength = 1536;
+        else if(curr_pkt_len == MAXPKTLEN_1552B)
+            *pLength = 1552;
+        else if(curr_pkt_len == MAXPKTLEN_16000B)
+            *pLength = 16000;
+        else
+            return RT_ERR_FAILED;
+    }
+
+    return RT_ERR_OK;
 }
 
-int RTL8367R_vlan_reinit(int mode)
+/* Function Name:
+ *      rtk_switch_greenEthernet_set
+ * Description:
+ *      Set all Ports Green Ethernet state.
+ * Input:
+ *      enable - Green Ethernet state.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - OK
+ *      RT_ERR_FAILED   - Failed
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_ENABLE   - Invalid enable input.
+ * Note:
+ *      This API can set all Ports Green Ethernet state.
+ *      The configuration is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+rtk_api_ret_t rtk_switch_greenEthernet_set(rtk_enable_t enable)
 {
-	int i, retval;
-	rtk_portmask_t mbrmsk, untagmsk;
+    rtk_api_ret_t retVal;
+    rtk_uint32 phy;
 
-	if (mode==rtl8197d_op_mode) // no need tio do the re-initialization
-		return 0;
+    if ((retVal = rtl8367b_setAsicGreenEthernet(enable))!=RT_ERR_OK)
+        return retVal;
 
-	rtk_vlan_init();
-	
-	if (mode==GATEWAY_MODE)
-	{
-		/* for lan */
-		mbrmsk.bits[0] = RTL_LANPORT_MASK|BIT(r8367_cpu_port);
-		untagmsk.bits[0] = RTL_LANPORT_MASK;
-		retval = rtk_vlan_set(LAN_VID, mbrmsk, untagmsk, 0);
-
-		for(i=0;i<5;i++) {
-			if  ((1<<i)&RTL_LANPORT_MASK)
-			{
-				retval = rtk_vlan_portPvid_set(i, LAN_VID, 0);			
-			}
-		}
-	
-		/* for wan */
-		mbrmsk.bits[0] = RTL_WANPORT_MASK|BIT(r8367_cpu_port);
-		untagmsk.bits[0] = RTL_WANPORT_MASK;
-		retval = rtk_vlan_set(WAN_VID, mbrmsk, untagmsk, 1);
-
-		for(i=0;i<5;i++) {
-			if  ((1<<i)&RTL_WANPORT_MASK)
-			{
-				retval = rtk_vlan_portPvid_set(i, WAN_VID, 0);
-			}
-		}		
-	} 
-	else {
-		/* for lan */
-		mbrmsk.bits[0] = (RTL_LANPORT_MASK | RTL_WANPORT_MASK) |BIT(r8367_cpu_port);
-		untagmsk.bits[0] = (RTL_LANPORT_MASK | RTL_WANPORT_MASK);
-		retval = rtk_vlan_set(LAN_VID, mbrmsk, untagmsk, 0);
+    for (phy=0;phy<=RTK_PHY_ID_MAX;phy++)
+    {
+        if ((retVal = rtl8367b_setAsicPowerSaving(phy,enable))!=RT_ERR_OK)
+            return retVal;
+    }
 
-		for(i=0;i<5;i++) {
-			if  ((1<<i)&(RTL_LANPORT_MASK | RTL_WANPORT_MASK))
-			{
-				retval = rtk_vlan_portPvid_set(i, LAN_VID, 0);			
-			}
-		}		
-	}
-	rtl8197d_op_mode = mode;
-	
-	return 0;
+    return RT_ERR_OK;
 }
 
-#define RTL8367R_WAN_PORT_BITMAP 		(1<<RTL8367R_WAN)
-#define RTL8367R_LAN_PORT_BITMAP 		(0x1f - RTL8367R_WAN_PORT_BITMAP)
-#define RTL8367R_LAN_EFID				2
-extern int rtl865x_curOpMode;
-
-#if defined(CONFIG_RTL_VLAN_8021Q) && defined(CONFIG_RTL_8367R_SUPPORT)
-int rtl_vlan_RTL8367R_set(unsigned short vid, unsigned int tagmask, unsigned int mask)
+/* Function Name:
+ *      rtk_switch_greenEthernet_get
+ * Description:
+ *      Get all Ports Green Ethernet state.
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - Green Ethernet state.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API can get Green Ethernet state.
+ */
+rtk_api_ret_t rtk_switch_greenEthernet_get(rtk_enable_t *pEnable)
 {
-	rtk_portmask_t mbrmsk, untag;
-	rtk_api_ret_t retVal;
-	int i;
-    unsigned untagmask;
+    rtk_api_ret_t retVal;
+    rtk_data_t value;
+    rtk_uint32 phy;
 
-    if(vid==WAN_VID || vid == LAN_VID)
-        return 0;
+    if ((retVal = rtl8367b_getAsicGreenEthernet(&value))!=RT_ERR_OK)
+        return retVal;
 
-    untagmask = mask&(~tagmask);
-    
-    mbrmsk.bits[0] = (BIT(r8367_cpu_port)|RTL8367R_WAN_PORT_BITMAP|RTL8367R_LAN_PORT_BITMAP);
+    if (value!=1)
+    {
+        *pEnable = DISABLED;
+        return RT_ERR_OK;
+    }
 
-    //panic_printk("untagmsk is 0x%x\n", (untagmask&RTL8367R_LAN_PORT_BITMAP));
-    
-    if(tagmask&RTL8367R_WAN_PORT_BITMAP)
-        untag.bits[0] = 0;
-    else
-        untag.bits[0] = (BIT(r8367_cpu_port)|RTL8367R_WAN_PORT_BITMAP|(untagmask&RTL8367R_LAN_PORT_BITMAP));
+    for (phy=0;phy<=RTK_PHY_ID_MAX;phy++)
+    {
+        if ((retVal = rtl8367b_getAsicPowerSaving(phy,&value))!=RT_ERR_OK)
+            return retVal;
+        if (value!=1)
+        {
+            *pEnable = DISABLED;
+            return RT_ERR_OK;
+        }
+    }
 
-    retVal=rtk_vlan_set(vid, mbrmsk, untag, 0); 
-    
-	return 0;
+    *pEnable = ENABLED;
+
+    return RT_ERR_OK;
 }
-#endif
 
-int RTL8367R_vlan_set(void)
+/* Function Name:
+ *      rtk_mirror_portBased_set
+ * Description:
+ *      Set port mirror function.
+ * Input:
+ *      mirroring_port          - Monitor port.
+ *      pMirrored_rx_portmask   - Rx mirror port mask.
+ *      pMirrored_tx_portmask   - Tx mirror port mask.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_PORT_MASK    - Invalid portmask.
+ * Note:
+ *      The API is to set mirror function of source port and mirror port.
+ *      The mirror port can only be set to one port and the TX and RX mirror ports
+ *      should be identical.
+ */
+rtk_api_ret_t rtk_mirror_portBased_set(rtk_port_t mirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask)
 {
-	rtk_portmask_t mbrmsk, untag;
-	rtk_api_ret_t retVal;
-	int i;
-	
- 	for(i=0;i<4096;i++)
- 	{ 	
- 		//if (i==WAN_VID ||i==LAN_VID)
- 		#if CONFIG_RTL_VLAN_8021Q
- 		if (i==WAN_VID || i==LAN_VID
-		#if defined CONFIG_RTL_CUSTOM_PASSTHRU	
-			||i==PASSTHRU_VLAN_ID
-		#endif	
-			)
-        #else
- 		if (i==WAN_VID ||i==LAN_VID || (i==10) || (i==11) || (i==12)	
-		#if defined CONFIG_RTL_CUSTOM_PASSTHRU	
-			||i==PASSTHRU_VLAN_ID
-		#endif	
-		) /* RTK VLAN */
-        #endif
- 		{
- 			mbrmsk.bits[0] = (BIT(r8367_cpu_port)|RTL8367R_WAN_PORT_BITMAP|RTL8367R_LAN_PORT_BITMAP);
- 			untag.bits[0] = (BIT(r8367_cpu_port)|RTL8367R_WAN_PORT_BITMAP|RTL8367R_LAN_PORT_BITMAP);
- 		}
- 		else
- 		{
- 			mbrmsk.bits[0] = (BIT(r8367_cpu_port)|RTL8367R_WAN_PORT_BITMAP|RTL8367R_LAN_PORT_BITMAP);
- 			untag.bits[0] = 0;
- 		} 	
- 		retVal=rtk_vlan_set(i, mbrmsk, untag, 0); //all vlan's fid is 0 
- 	}
-
-	/* set pvid :  wan:8   lan:9  */	
-	for(i=0;i<5;i++)
-	{
-		#if defined (CONFIG_RTL_IVL_SUPPORT)
-		if (i == RTL8367R_WAN)
-			retVal=rtk_vlan_portPvid_set(i, WAN_VID,0);
-		else
-			retVal=rtk_vlan_portPvid_set(i, LAN_VID,0);
-		#else
-		if(rtl865x_curOpMode==GATEWAY_MODE){
-			if (i == RTL8367R_WAN)
-				retVal=rtk_vlan_portPvid_set(i, WAN_VID,0);
-			else
-				retVal=rtk_vlan_portPvid_set(i, LAN_VID,0);
-		}else{
-			retVal=rtk_vlan_portPvid_set(i, LAN_VID,0);
-		}
-		#endif
-	}       
-	
-	/* set wan port efid=1, other ports efid=2 */
-	for(i=0;i<5;i++)
-	{
-		#if defined (CONFIG_RTL_IVL_SUPPORT)
-		if (i == RTL8367R_WAN)
-			retVal = rtk_port_efid_set(i,1);
-		else
-			retVal = rtk_port_efid_set(i,RTL8367R_LAN_EFID);
-		#else
-		if(rtl865x_curOpMode==GATEWAY_MODE){
-			if (i == RTL8367R_WAN)
-				retVal = rtk_port_efid_set(i,1);
-			else
-				retVal = rtk_port_efid_set(i,RTL8367R_LAN_EFID);
-		}else{
-			retVal = rtk_port_efid_set(i,RTL8367R_LAN_EFID);
-		}
-		#endif
-	}
+    rtk_api_ret_t retVal;
+    rtk_enable_t mirRx, mirTx;
+    rtk_uint32 i;
+      rtk_port_t source_port;
 
-#if defined (CONFIG_RTL_IVL_SUPPORT)
-	if (rtl865x_curOpMode != GATEWAY_MODE) {
-		rtk_l2_limitLearningCnt_set(RTL8367R_WAN, 0);
-		rtk_l2_flushType_set(FLUSH_TYPE_BY_PORT, WAN_VID, RTL8367R_WAN);		
-	}
-#endif
+    if (mirroring_port > RTK_PORT_ID_MAX)
+        return RT_ERR_PORT_ID;
 
-	/* disable cpu port's mac addr learning ability */
-	rtl8367b_setAsicLutLearnLimitNo(r8367_cpu_port,0);
-	
-	/* disable unknown unicast/mcast/bcast flooding between LAN ports */
-	smi_write(RTL8367B_REG_UNDA_FLOODING_PMSK, BIT(r8367_cpu_port));
-	smi_write(RTL8367B_REG_UNMCAST_FLOADING_PMSK, BIT(r8367_cpu_port));
-	smi_write(RTL8367B_REG_BCAST_FLOADING_PMSK, BIT(r8367_cpu_port));
-	
-	return 0;
-}
+    if (pMirrored_rx_portmask->bits[0] > RTK_MAX_PORT_MASK)
+        return RT_ERR_PORT_MASK;
 
-void RTL8367R_cpu_tag(int enable)
-{
-	if(enable){
-		rtl8367b_setAsicReg(RTL8367B_REG_CPU_PORT_MASK,1<<r8367_cpu_port); //set CPU port
-		rtl8367b_setAsicReg(RTL8367B_REG_CPU_CTRL,0x281|(r8367_cpu_port)<<RTL8367B_CPU_TRAP_PORT_OFFSET);
-	}
-	else{
-		rtl8367b_setAsicReg(RTL8367B_REG_CPU_CTRL,0x280|(r8367_cpu_port)<<RTL8367B_CPU_TRAP_PORT_OFFSET);
-	}
-}
+    if (pMirrored_tx_portmask->bits[0] > RTK_MAX_PORT_MASK)
+        return RT_ERR_PORT_MASK;
 
-void del_8367r_L2(rtk_mac_t *pMac)
-{
-	rtk_l2_ucastAddr_t L2_data;
+    /*Only one port for tx & rx mirror*/
+    if (pMirrored_tx_portmask->bits[0]!=pMirrored_rx_portmask->bits[0]&&pMirrored_tx_portmask->bits[0]!=0&&pMirrored_rx_portmask->bits[0]!=0)
+        return RT_ERR_PORT_MASK;
 
-	memset(&L2_data, 0, sizeof(rtk_l2_ucastAddr_t));
-	L2_data.fid = 0;
-	L2_data.efid = RTL8367R_LAN_EFID;
-	
-	if (rtk_l2_addr_get(pMac, &L2_data) == RT_ERR_OK)
-		rtk_l2_addr_del(pMac, &L2_data);
+     /*mirror port != source port*/
+    if ((pMirrored_tx_portmask->bits[0]&(1<<mirroring_port))>0||(pMirrored_rx_portmask->bits[0]&(1<<mirroring_port))>0)
+        return RT_ERR_PORT_MASK;
 
-	return;
-}
+   source_port = 0;
 
-#if 0
-void get_all_L2(void)
-{
-	int i, ret;
-	rtk_l2_addr_table_t p;
-		
-	for (i=1; i<=RTK_MAX_NUM_OF_LEARN_LIMIT;i++)
-	{
-		p.index = i;
-		ret = rtk_l2_entry_get(&p);
-		if (ret == RT_ERR_OK)
-		{
-			printk(" [%d] mac: %02x:%02x:%02x:%02x:%02x:%02x, portmask: 0x%x, age: %d, fid: %d\n", i,
-				p.mac.octet[0],p.mac.octet[1],p.mac.octet[2],p.mac.octet[3],p.mac.octet[4],p.mac.octet[5],
-				p.portmask, p.age, p.fid);			
-		}
-	}
-	return;
-}
-#endif
+   for (i = 0; i< RTK_MAX_NUM_OF_PORT; i++)
+   {
+        if (pMirrored_tx_portmask->bits[0]&(1<<i))
+        {
+            source_port = i;
+            break;
+        }
 
-enum 
-{
-	PORT_DOWN=0,
-	HALF_DUPLEX_10M,
-	HALF_DUPLEX_100M,
-	HALF_DUPLEX_1000M,
-	DUPLEX_10M,
-	DUPLEX_100M,
-	DUPLEX_1000M,
-	PORT_AUTO
-};
+        if (pMirrored_rx_portmask->bits[0]&(1<<i))
+        {
+            source_port = i;
+            break;
+        }
+    }
 
-rtk_api_ret_t set_8367r_speed_mode(int port, int mode)
-{
-	rtk_port_phy_ability_t phyAbility;
+    if ((retVal = rtl8367b_setAsicPortMirror(source_port, mirroring_port)) != RT_ERR_OK)
+        return retVal;
+    if(pMirrored_rx_portmask->bits[0] != 0)
+    {
+        if ((retVal = rtl8367b_setAsicPortMirrorMask(pMirrored_rx_portmask->bits[0])) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        if ((retVal = rtl8367b_setAsicPortMirrorMask(pMirrored_tx_portmask->bits[0])) != RT_ERR_OK)
+            return retVal;
+    }
 
-	memset(&phyAbility, 0, sizeof(rtk_port_phy_ability_t));
 
-	phyAbility.FC = 1;
-	phyAbility.AsyFC = 1;
-	phyAbility.AutoNegotiation = 1;
+    if (pMirrored_rx_portmask->bits[0])
+        mirRx = ENABLED;
+    else
+        mirRx = DISABLED;
 
-	if (mode == HALF_DUPLEX_10M) //10M half
-	{
-		phyAbility.Half_10 = 1;
-	}
-	else if (mode == DUPLEX_10M)	//10M full
-	{
-		phyAbility.Full_10 = 1;
-	}
-	else if (mode == HALF_DUPLEX_100M) // 100M half
-	{
-		phyAbility.Half_100 = 1;
-	}
-	else if (mode == DUPLEX_100M) // 100M full
-	{
-		phyAbility.Full_100 = 1;
-	}
-	else if (mode == DUPLEX_1000M) // 1000M
-	{
-		phyAbility.Full_1000 = 1;
-	}
-	else
-	{
-		phyAbility.Half_10 = 1;
-		phyAbility.Full_10 = 1;
-		phyAbility.Half_100 = 1;
-		phyAbility.Full_100 = 1;
-		phyAbility.Full_1000 = 1;
-	}
+    if ((retVal = rtl8367b_setAsicPortMirrorRxFunction(mirRx)) != RT_ERR_OK)
+        return retVal;
 
-	return (rtk_port_phyAutoNegoAbility_set(port, &phyAbility));
-}
+    if (pMirrored_tx_portmask->bits[0])
+        mirTx = ENABLED;
+    else
+        mirTx = DISABLED;
+
+    if ((retVal = rtl8367b_setAsicPortMirrorTxFunction(mirTx)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
 
-void rtl8367rb_reset(void)
-{
-	rtl8367b_setAsicReg(RTL8367B_REG_CHIP_RESET, (1<<RTL8367B_CHIP_RST_OFFSET));	
-	return;
 }
 
 /* Function Name:
- *      rtk_switch_maxPktLen_set
+ *      rtk_mirror_portBased_get
  * Description:
- *      Set the max packet length of the specific unit
+ *      Get port mirror function.
  * Input:
- *      len - max packet length
- * Output:
  *      None
+ * Output:
+ *      pMirroring_port         - Monitor port.
+ *      pMirrored_rx_portmask   - Rx mirror port mask.
+ *      pMirrored_tx_portmask   - Tx mirror port mask.
  * Return:
  *      RT_ERR_OK           - OK
  *      RT_ERR_FAILED       - Failed
  *      RT_ERR_SMI          - SMI access error
  *      RT_ERR_INPUT 		- Invalid input parameters.
  * Note:
- *      The API can set max packet length of the specific unit to
- *      - MAXPKTLEN_1522B,
- *      - MAXPKTLEN_1536B,
- *      - MAXPKTLEN_1552B,
- *      - MAXPKTLEN_16000B.
+ *      The API is to get mirror function of source port and mirror port.
  */
-rtk_api_ret_t rtk_switch_maxPktLen_set(rtk_switch_maxPktLen_t len)
+rtk_api_ret_t rtk_mirror_portBased_get(rtk_port_t* pMirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask)
 {
     rtk_api_ret_t retVal;
+    rtk_port_t source_port;
+    rtk_enable_t mirRx, mirTx;
+    rtk_portmask_t  src_portmask;
 
-    if (len>=MAXPKTLEN_END)
-        return RT_ERR_INPUT;
+    if ((retVal = rtl8367b_getAsicPortMirror(&source_port, pMirroring_port)) != RT_ERR_OK)
+        return retVal;
 
-    if ((retVal = rtl8367b_setAsicMaxLengthInRx(len)) != RT_ERR_OK)
+    if ((retVal = rtl8367b_getAsicPortMirrorRxFunction((rtk_uint32*)&mirRx)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367b_getAsicPortMirrorTxFunction((rtk_uint32*)&mirTx)) != RT_ERR_OK)
         return retVal;
 
+    if (DISABLED == mirRx)
+        pMirrored_rx_portmask->bits[0]=0;
+    else
+    {
+        pMirrored_rx_portmask->bits[0]=1<<source_port;
+
+        if ((retVal = rtl8367b_getAsicPortMirrorMask(&(src_portmask.bits[0]))) != RT_ERR_OK)
+            return retVal;
+
+        pMirrored_rx_portmask->bits[0] |= src_portmask.bits[0];
+    }
+
+     if (DISABLED == mirTx)
+        pMirrored_tx_portmask->bits[0]=0;
+    else
+    {
+        pMirrored_tx_portmask->bits[0]=1<<source_port;
+
+        if ((retVal = rtl8367b_getAsicPortMirrorMask(&(src_portmask.bits[0]))) != RT_ERR_OK)
+            return retVal;
+
+        pMirrored_tx_portmask->bits[0] |= src_portmask.bits[0];
+    }
+
     return RT_ERR_OK;
+
 }
 
 /* Function Name:
- *      rtk_switch_maxPktLen_get
+ *      rtk_mirror_portIso_set
  * Description:
- *      Get the max packet length of the specific unit
+ *      Set mirror port isolation.
  * Input:
- *      None
+ *      enable |Mirror isolation status.
  * Output:
- *      pLen - pointer to the max packet length
+ *      None
  * Return:
  *      RT_ERR_OK           - OK
  *      RT_ERR_FAILED       - Failed
  *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input
  * Note:
- *      The API can set max packet length of the specific unit.
+ *      The API is to set mirror isolation function that prevent normal forwarding packets to miror port.
  */
-rtk_api_ret_t rtk_switch_maxPktLen_get(rtk_switch_maxPktLen_t *pLen)
+rtk_api_ret_t rtk_mirror_portIso_set(rtk_enable_t enable)
 {
     rtk_api_ret_t retVal;
 
-    if ((retVal = rtl8367b_getAsicMaxLengthInRx(pLen)) != RT_ERR_OK)
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367b_setAsicPortMirrorIsolation(enable)) != RT_ERR_OK)
         return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_switch_portMaxPktLen_set
+ *      rtk_mirror_portIso_get
  * Description:
- *      Set 2nd max packet length configuration
+ *      Get mirror port isolation.
  * Input:
- *      port    - Port ID
- *      length  - Length(1522 bytes, 1536 bytes, 1552 bytes, 16000 bytes)
+ *      None
  * Output:
- *      None.
+ *      pEnable |Mirror isolation status.
  * Return:
  *      RT_ERR_OK           - OK
  *      RT_ERR_FAILED       - Failed
  *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT 		- Invalid input parameters.
  * Note:
- *      The API can set 2nd max packet length configuration.
- *      The parameter "port" indicates which port would follow 2nd configuration.
- *      If the paramter "length" is as same as 1st configuration, this API
- *      would set the port back to 1st configuration. Users should always use
- *      rtk_switch_maxPktLen_set to setup 1st configuration for whole system
- *      setting and then use rtk_switch_portMaxPktLen_set to setup a per port
- *      configuration.
+ *      The API is to get mirror isolation status.
  */
-rtk_api_ret_t rtk_switch_portMaxPktLen_set(rtk_port_t port, rtk_uint32 length)
+rtk_api_ret_t rtk_mirror_portIso_get(rtk_enable_t *pEnable)
 {
-    rtk_switch_maxPktLen_t  pkt_len, curr_pkt_len;
-    rtk_api_ret_t           retVal;
-    rtk_uint32              maxLength, pmaskGiga, pmask100M;
-
-    if(port > RTK_PORT_ID_MAX)
-        return RT_ERR_PORT_ID;
-
-    if(length == 1522)
-        pkt_len = MAXPKTLEN_1522B;
-    else if(length == 1536)
-        pkt_len = MAXPKTLEN_1536B;
-    else if(length == 1552)
-        pkt_len = MAXPKTLEN_1552B;
-    else if(length == 16000)
-        pkt_len = MAXPKTLEN_16000B;
-    else
-        return RT_ERR_INPUT;
+    rtk_api_ret_t retVal;
 
-    if ((retVal = rtl8367b_getAsicMaxLengthInRx(&curr_pkt_len)) != RT_ERR_OK)
+    if ((retVal = rtl8367b_getAsicPortMirrorIsolation(pEnable)) != RT_ERR_OK)
         return retVal;
 
-    if(curr_pkt_len == pkt_len)
-    {
-        if ((retVal = rtl8367b_getAsicMaxLengthAltTxRx(&maxLength, &pmaskGiga, &pmask100M)) != RT_ERR_OK)
-            return retVal;
-
-        pmaskGiga &= ~(0x0001 << port);
-        pmask100M &= ~(0x0001 << port);
-
-        if ((retVal = rtl8367b_setAsicMaxLengthAltTxRx(maxLength, pmaskGiga, pmask100M)) != RT_ERR_OK)
-            return retVal;
-    }
-    else
-    {
-        if ((retVal = rtl8367b_getAsicMaxLengthAltTxRx(&maxLength, &pmaskGiga, &pmask100M)) != RT_ERR_OK)
-            return retVal;
-
-        pmaskGiga |= (0x0001 << port);
-        pmask100M |= (0x0001 << port);
-
-        if ((retVal = rtl8367b_setAsicMaxLengthAltTxRx(pkt_len, pmaskGiga, pmask100M)) != RT_ERR_OK)
-            return retVal;
-    }
-
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_switch_portMaxPktLen_get
+ *      rtk_stat_global_reset
  * Description:
- *      Get 2nd max packet length configuration
+ *      Reset global MIB counter.
  * Input:
- *      port    - Port ID
+ *      None
  * Output:
- *      pLength  - Length(1522 bytes, 1536 bytes, 1552 bytes, 16000 bytes)
+ *      None
  * Return:
  *      RT_ERR_OK           - OK
  *      RT_ERR_FAILED       - Failed
  *      RT_ERR_SMI          - SMI access error
  * Note:
- *      The API can get 2nd max packet length configuration.
- *      If "port" is not in the 2nd configuration, the setting of
- *      1st configuration woill be returned.
+ *      Reset MIB counter of ports. API will use global reset while port mask is all-ports.
  */
-rtk_api_ret_t rtk_switch_portMaxPktLen_get(rtk_port_t port, rtk_uint32 *pLength)
+rtk_api_ret_t rtk_stat_global_reset(void)
 {
-    rtk_switch_maxPktLen_t  curr_pkt_len;
-    rtk_api_ret_t           retVal;
-    rtk_uint32              maxLength, pmaskGiga, pmask100M;
-
-    if(port > RTK_PORT_ID_MAX)
-        return RT_ERR_PORT_ID;
-
-    if ((retVal = rtl8367b_getAsicMaxLengthAltTxRx(&maxLength, &pmaskGiga, &pmask100M)) != RT_ERR_OK)
-        return retVal;
+    rtk_api_ret_t retVal;
 
-    if ((retVal = rtl8367b_getAsicMaxLengthInRx(&curr_pkt_len)) != RT_ERR_OK)
+    if ((retVal = rtl8367b_setAsicMIBsCounterReset(TRUE,FALSE, 0)) != RT_ERR_OK)
         return retVal;
 
-    if(pmaskGiga & (0x0001 << port))
-    {
-        if(maxLength == MAXPKTLEN_1522B)
-            *pLength = 1522;
-        else if(maxLength == MAXPKTLEN_1536B)
-            *pLength = 1536;
-        else if(maxLength == MAXPKTLEN_1552B)
-            *pLength = 1552;
-        else if(maxLength == MAXPKTLEN_16000B)
-            *pLength = 16000;
-        else
-            return RT_ERR_FAILED;
-    }
-    else
-    {
-        if(curr_pkt_len == MAXPKTLEN_1522B)
-            *pLength = 1522;
-        else if(curr_pkt_len == MAXPKTLEN_1536B)
-            *pLength = 1536;
-        else if(curr_pkt_len == MAXPKTLEN_1552B)
-            *pLength = 1552;
-        else if(curr_pkt_len == MAXPKTLEN_16000B)
-            *pLength = 16000;
-        else
-            return RT_ERR_FAILED;
-    }
-
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_switch_greenEthernet_set
+ *      rtk_stat_port_reset
  * Description:
- *      Set all Ports Green Ethernet state.
+ *      Reset per port MIB counter by port.
  * Input:
- *      enable - Green Ethernet state.
+ *      port - port id.
  * Output:
  *      None
  * Return:
- *      RT_ERR_OK       - OK
- *      RT_ERR_FAILED   - Failed
- *      RT_ERR_SMI      - SMI access error
- *      RT_ERR_ENABLE   - Invalid enable input.
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
  * Note:
- *      This API can set all Ports Green Ethernet state.
- *      The configuration is as following:
- *      - DISABLE
- *      - ENABLE
+ *      Reset MIB counter of ports. API will use global reset while port mask is all-ports.
  */
-rtk_api_ret_t rtk_switch_greenEthernet_set(rtk_enable_t enable)
+rtk_api_ret_t rtk_stat_port_reset(rtk_port_t port)
 {
     rtk_api_ret_t retVal;
-    rtk_uint32 phy;
 
-    if ((retVal = rtl8367b_setAsicGreenEthernet(enable))!=RT_ERR_OK)
-        return retVal;
+    if (port > RTK_PORT_ID_MAX)
+        return RT_ERR_PORT_ID;
 
-    for (phy=0;phy<=RTK_PHY_ID_MAX;phy++)
-    {
-        if ((retVal = rtl8367b_setAsicPowerSaving(phy,enable))!=RT_ERR_OK)
-            return retVal;
-    }
+    if ((retVal = rtl8367b_setAsicMIBsCounterReset(FALSE,FALSE,1<<port)) != RT_ERR_OK)
+        return retVal;
 
     return RT_ERR_OK;
 }
 
-/* Function Name:
- *      rtk_switch_greenEthernet_get
- * Description:
- *      Get all Ports Green Ethernet state.
- * Input:
- *      None
- * Output:
- *      pEnable - Green Ethernet state.
- * Return:
- *      RT_ERR_OK              - OK
- *      RT_ERR_FAILED          - Failed
- *      RT_ERR_SMI             - SMI access error
- * Note:
- *      This API can get Green Ethernet state.
- */
-rtk_api_ret_t rtk_switch_greenEthernet_get(rtk_enable_t *pEnable)
+#ifdef EMBEDDED_SUPPORT
+
+#if 0
+rtk_api_ret_t rtk_stat_global_get(rtk_stat_global_type_t cntr_idx, rtk_stat_counter_t *pCntrH, rtk_stat_counter_t *pCntrL)
 {
     rtk_api_ret_t retVal;
-    rtk_data_t value;
-    rtk_uint32 phy;
 
-    if ((retVal = rtl8367b_getAsicGreenEthernet(&value))!=RT_ERR_OK)
+    if (cntr_idx!=DOT1D_TP_LEARNED_ENTRY_DISCARDS_INDEX)
+            return RT_ERR_STAT_INVALID_GLOBAL_CNTR;
+
+    if ((retVal = rtl8370_getAsicMIBsCounter(0, cntr_idx, pCntrH, pCntrL)) != RT_ERR_OK)
         return retVal;
 
-    if (value!=1)
-    {
-        *pEnable = DISABLED;
-        return RT_ERR_OK;
-    }
+    return RT_ERR_OK;
+}
+#endif
 
-    for (phy=0;phy<=RTK_PHY_ID_MAX;phy++)
-    {
-        if ((retVal = rtl8367b_getAsicPowerSaving(phy,&value))!=RT_ERR_OK)
-            return retVal;
-        if (value!=1)
-        {
-            *pEnable = DISABLED;
-            return RT_ERR_OK;
-        }
-    }
+#if 0
+rtk_api_ret_t rtk_stat_port_get(rtk_port_t port, rtk_stat_port_type_t cntr_idx, rtk_stat_counter_t *pCntrH, rtk_stat_counter_t *pCntrL)
+{
+    rtk_api_ret_t retVal;
 
-    *pEnable = ENABLED;
+    if (port > RTK_PORT_ID_MAX)
+        return RT_ERR_PORT_ID;
+
+    if (cntr_idx>=STAT_PORT_CNTR_END)
+        return RT_ERR_STAT_INVALID_PORT_CNTR;
+
+    if ((retVal = rtl8370_getAsicMIBsCounter(port, cntr_idx, pCntrH, pCntrL)) != RT_ERR_OK)
+        return retVal;
 
     return RT_ERR_OK;
 }
+#endif
+
+#else
 
 /* Function Name:
- *      rtk_mirror_portBased_set
+ *      rtk_stat_global_get
  * Description:
- *      Set port mirror function.
+ *      Get global MIB counter
  * Input:
- *      mirroring_port          - Monitor port.
- *      pMirrored_rx_portmask   - Rx mirror port mask.
- *      pMirrored_tx_portmask   - Tx mirror port mask.
+ *      cntr_idx - global counter index.
  * Output:
- *      None
+ *      pCntr - global counter value.
  * Return:
  *      RT_ERR_OK           - OK
  *      RT_ERR_FAILED       - Failed
  *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_PORT_ID      - Invalid port number
- *      RT_ERR_PORT_MASK    - Invalid portmask.
+ *      RT_ERR_INPUT 		- Invalid input parameters.
  * Note:
- *      The API is to set mirror function of source port and mirror port.
- *      The mirror port can only be set to one port and the TX and RX mirror ports
- *      should be identical.
+ *      Get global MIB counter by index definition.
  */
-rtk_api_ret_t rtk_mirror_portBased_set(rtk_port_t mirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask)
+rtk_api_ret_t rtk_stat_global_get(rtk_stat_global_type_t cntr_idx, rtk_stat_counter_t *pCntr)
 {
     rtk_api_ret_t retVal;
-    rtk_enable_t mirRx, mirTx;
-    rtk_uint32 i;
-      rtk_port_t source_port;
-
-    if (mirroring_port > RTK_PORT_ID_MAX)
-        return RT_ERR_PORT_ID;
-
-    if (pMirrored_rx_portmask->bits[0] > RTK_MAX_PORT_MASK)
-        return RT_ERR_PORT_MASK;
-
-    if (pMirrored_tx_portmask->bits[0] > RTK_MAX_PORT_MASK)
-        return RT_ERR_PORT_MASK;
-
-    /*Only one port for tx & rx mirror*/
-    if (pMirrored_tx_portmask->bits[0]!=pMirrored_rx_portmask->bits[0]&&pMirrored_tx_portmask->bits[0]!=0&&pMirrored_rx_portmask->bits[0]!=0)
-        return RT_ERR_PORT_MASK;
-
-     /*mirror port != source port*/
-    if ((pMirrored_tx_portmask->bits[0]&(1<<mirroring_port))>0||(pMirrored_rx_portmask->bits[0]&(1<<mirroring_port))>0)
-        return RT_ERR_PORT_MASK;
-
-   source_port = 0;
-
-   for (i = 0; i< RTK_MAX_NUM_OF_PORT; i++)
-   {
-        if (pMirrored_tx_portmask->bits[0]&(1<<i))
-        {
-            source_port = i;
-            break;
-        }
-
-        if (pMirrored_rx_portmask->bits[0]&(1<<i))
-        {
-            source_port = i;
-            break;
-        }
-    }
-
-    if ((retVal = rtl8367b_setAsicPortMirror(source_port, mirroring_port)) != RT_ERR_OK)
-        return retVal;
-    if(pMirrored_rx_portmask->bits[0] != 0)
-    {
-        if ((retVal = rtl8367b_setAsicPortMirrorMask(pMirrored_rx_portmask->bits[0])) != RT_ERR_OK)
-            return retVal;
-    }
-    else
-    {
-        if ((retVal = rtl8367b_setAsicPortMirrorMask(pMirrored_tx_portmask->bits[0])) != RT_ERR_OK)
-            return retVal;
-    }
-
-
-    if (pMirrored_rx_portmask->bits[0])
-        mirRx = ENABLED;
-    else
-        mirRx = DISABLED;
 
-    if ((retVal = rtl8367b_setAsicPortMirrorRxFunction(mirRx)) != RT_ERR_OK)
-        return retVal;
-
-    if (pMirrored_tx_portmask->bits[0])
-        mirTx = ENABLED;
-    else
-        mirTx = DISABLED;
+    if (cntr_idx!=DOT1D_TP_LEARNED_ENTRY_DISCARDS_INDEX)
+        return RT_ERR_STAT_INVALID_GLOBAL_CNTR;
 
-    if ((retVal = rtl8367b_setAsicPortMirrorTxFunction(mirTx)) != RT_ERR_OK)
+    if ((retVal = rtl8367b_getAsicMIBsCounter(0, cntr_idx, pCntr)) != RT_ERR_OK)
         return retVal;
 
     return RT_ERR_OK;
-
 }
 
 /* Function Name:
- *      rtk_mirror_portBased_get
+ *      rtk_stat_global_getAll
  * Description:
- *      Get port mirror function.
+ *      Get all global MIB counter
  * Input:
  *      None
  * Output:
- *      pMirroring_port         - Monitor port.
- *      pMirrored_rx_portmask   - Rx mirror port mask.
- *      pMirrored_tx_portmask   - Tx mirror port mask.
+ *      pGlobal_cntrs - global counter structure.
  * Return:
  *      RT_ERR_OK           - OK
  *      RT_ERR_FAILED       - Failed
  *      RT_ERR_SMI          - SMI access error
  *      RT_ERR_INPUT 		- Invalid input parameters.
  * Note:
- *      The API is to get mirror function of source port and mirror port.
+ *      Get all global MIB counter by index definition.
  */
-rtk_api_ret_t rtk_mirror_portBased_get(rtk_port_t* pMirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask)
+rtk_api_ret_t rtk_stat_global_getAll(rtk_stat_global_cntr_t *pGlobal_cntrs)
 {
     rtk_api_ret_t retVal;
-    rtk_port_t source_port;
-    rtk_enable_t mirRx, mirTx;
-    rtk_portmask_t  src_portmask;
-
-    if ((retVal = rtl8367b_getAsicPortMirror(&source_port, pMirroring_port)) != RT_ERR_OK)
-        return retVal;
 
-    if ((retVal = rtl8367b_getAsicPortMirrorRxFunction((rtk_uint32*)&mirRx)) != RT_ERR_OK)
+    if ((retVal = rtl8367b_getAsicMIBsCounter(0,DOT1D_TP_LEARNED_ENTRY_DISCARDS_INDEX, &pGlobal_cntrs->dot1dTpLearnedEntryDiscards)) != RT_ERR_OK)
         return retVal;
 
-    if ((retVal = rtl8367b_getAsicPortMirrorTxFunction((rtk_uint32*)&mirTx)) != RT_ERR_OK)
-        return retVal;
+    return RT_ERR_OK;
+}
 
-    if (DISABLED == mirRx)
-        pMirrored_rx_portmask->bits[0]=0;
-    else
-    {
-        pMirrored_rx_portmask->bits[0]=1<<source_port;
-
-        if ((retVal = rtl8367b_getAsicPortMirrorMask(&(src_portmask.bits[0]))) != RT_ERR_OK)
-            return retVal;
-
-        pMirrored_rx_portmask->bits[0] |= src_portmask.bits[0];
-    }
-
-     if (DISABLED == mirTx)
-        pMirrored_tx_portmask->bits[0]=0;
-    else
-    {
-        pMirrored_tx_portmask->bits[0]=1<<source_port;
-
-        if ((retVal = rtl8367b_getAsicPortMirrorMask(&(src_portmask.bits[0]))) != RT_ERR_OK)
-            return retVal;
-
-        pMirrored_tx_portmask->bits[0] |= src_portmask.bits[0];
-    }
-
-    return RT_ERR_OK;
-
-}
-
-/* Function Name:
- *      rtk_mirror_portIso_set
- * Description:
- *      Set mirror port isolation.
- * Input:
- *      enable |Mirror isolation status.
- * Output:
- *      None
- * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_ENABLE       - Invalid enable input
- * Note:
- *      The API is to set mirror isolation function that prevent normal forwarding packets to miror port.
- */
-rtk_api_ret_t rtk_mirror_portIso_set(rtk_enable_t enable)
-{
-    rtk_api_ret_t retVal;
-
-    if (enable >= RTK_ENABLE_END)
-        return RT_ERR_ENABLE;
-
-    if ((retVal = rtl8367b_setAsicPortMirrorIsolation(enable)) != RT_ERR_OK)
-        return retVal;
-
-    return RT_ERR_OK;
-}
-
-/* Function Name:
- *      rtk_mirror_portIso_get
- * Description:
- *      Get mirror port isolation.
- * Input:
- *      None
- * Output:
- *      pEnable |Mirror isolation status.
- * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_INPUT 		- Invalid input parameters.
- * Note:
- *      The API is to get mirror isolation status.
- */
-rtk_api_ret_t rtk_mirror_portIso_get(rtk_enable_t *pEnable)
-{
-    rtk_api_ret_t retVal;
-
-    if ((retVal = rtl8367b_getAsicPortMirrorIsolation(pEnable)) != RT_ERR_OK)
-        return retVal;
-
-    return RT_ERR_OK;
-}
-
-/* Function Name:
- *      rtk_stat_global_reset
- * Description:
- *      Reset global MIB counter.
- * Input:
- *      None
- * Output:
- *      None
- * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- * Note:
- *      Reset MIB counter of ports. API will use global reset while port mask is all-ports.
- */
-rtk_api_ret_t rtk_stat_global_reset(void)
-{
-    rtk_api_ret_t retVal;
-
-    if ((retVal = rtl8367b_setAsicMIBsCounterReset(TRUE,FALSE, 0)) != RT_ERR_OK)
-        return retVal;
-
-    return RT_ERR_OK;
-}
-
-/* Function Name:
- *      rtk_stat_port_reset
- * Description:
- *      Reset per port MIB counter by port.
- * Input:
- *      port - port id.
- * Output:
- *      None
- * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- * Note:
- *      Reset MIB counter of ports. API will use global reset while port mask is all-ports.
- */
-rtk_api_ret_t rtk_stat_port_reset(rtk_port_t port)
-{
-    rtk_api_ret_t retVal;
-
-    if (port > RTK_PORT_ID_MAX)
-        return RT_ERR_PORT_ID;
-
-    if ((retVal = rtl8367b_setAsicMIBsCounterReset(FALSE,FALSE,1<<port)) != RT_ERR_OK)
-        return retVal;
-
-    return RT_ERR_OK;
-}
-
-#ifdef EMBEDDED_SUPPORT
-
-#if 0
-rtk_api_ret_t rtk_stat_global_get(rtk_stat_global_type_t cntr_idx, rtk_stat_counter_t *pCntrH, rtk_stat_counter_t *pCntrL)
-{
-    rtk_api_ret_t retVal;
-
-    if (cntr_idx!=DOT1D_TP_LEARNED_ENTRY_DISCARDS_INDEX)
-            return RT_ERR_STAT_INVALID_GLOBAL_CNTR;
-
-    if ((retVal = rtl8370_getAsicMIBsCounter(0, cntr_idx, pCntrH, pCntrL)) != RT_ERR_OK)
-        return retVal;
-
-    return RT_ERR_OK;
-}
-#endif
-
-#if 0
-rtk_api_ret_t rtk_stat_port_get(rtk_port_t port, rtk_stat_port_type_t cntr_idx, rtk_stat_counter_t *pCntrH, rtk_stat_counter_t *pCntrL)
-{
-    rtk_api_ret_t retVal;
-
-    if (port > RTK_PORT_ID_MAX)
-        return RT_ERR_PORT_ID;
-
-    if (cntr_idx>=STAT_PORT_CNTR_END)
-        return RT_ERR_STAT_INVALID_PORT_CNTR;
-
-    if ((retVal = rtl8370_getAsicMIBsCounter(port, cntr_idx, pCntrH, pCntrL)) != RT_ERR_OK)
-        return retVal;
-
-    return RT_ERR_OK;
-}
-#endif
-
-#else
-
-/* Function Name:
- *      rtk_stat_global_get
- * Description:
- *      Get global MIB counter
- * Input:
- *      cntr_idx - global counter index.
- * Output:
- *      pCntr - global counter value.
- * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_INPUT 		- Invalid input parameters.
- * Note:
- *      Get global MIB counter by index definition.
- */
-rtk_api_ret_t rtk_stat_global_get(rtk_stat_global_type_t cntr_idx, rtk_stat_counter_t *pCntr)
-{
-    rtk_api_ret_t retVal;
-
-    if (cntr_idx!=DOT1D_TP_LEARNED_ENTRY_DISCARDS_INDEX)
-        return RT_ERR_STAT_INVALID_GLOBAL_CNTR;
-
-    if ((retVal = rtl8367b_getAsicMIBsCounter(0, cntr_idx, pCntr)) != RT_ERR_OK)
-        return retVal;
-
-    return RT_ERR_OK;
-}
-
-/* Function Name:
- *      rtk_stat_global_getAll
- * Description:
- *      Get all global MIB counter
- * Input:
- *      None
- * Output:
- *      pGlobal_cntrs - global counter structure.
- * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_INPUT 		- Invalid input parameters.
- * Note:
- *      Get all global MIB counter by index definition.
- */
-rtk_api_ret_t rtk_stat_global_getAll(rtk_stat_global_cntr_t *pGlobal_cntrs)
-{
-    rtk_api_ret_t retVal;
-
-    if ((retVal = rtl8367b_getAsicMIBsCounter(0,DOT1D_TP_LEARNED_ENTRY_DISCARDS_INDEX, &pGlobal_cntrs->dot1dTpLearnedEntryDiscards)) != RT_ERR_OK)
-        return retVal;
-
-    return RT_ERR_OK;
-}
-
-#define MIB_NOT_SUPPORT     (0xFFFF)
-static rtk_api_ret_t _get_asic_mib_idx(rtk_stat_port_type_t cnt_idx, RTL8367B_MIBCOUNTER *pMib_idx)
-{
-    RTL8367B_MIBCOUNTER mib_asic_idx[STAT_PORT_CNTR_END]=
+#define MIB_NOT_SUPPORT     (0xFFFF)
+static rtk_api_ret_t _get_asic_mib_idx(rtk_stat_port_type_t cnt_idx, RTL8367B_MIBCOUNTER *pMib_idx)
+{
+    RTL8367B_MIBCOUNTER mib_asic_idx[STAT_PORT_CNTR_END]=
     {
         ifInOctets,                     /* STAT_IfInOctets */
         dot3StatsFCSErrors,             /* STAT_Dot3StatsFCSErrors */
@@ -16392,1458 +16473,1738 @@ rtk_api_ret_t rtk_led_serialMode_set(rtk
     if ( active >= LED_ACTIVE_END)
         return RT_ERR_INPUT;
 
-     if ((retVal = rtl8367b_setAsicLedSerialModeConfig(active,1))!=RT_ERR_OK)
-        return retVal;
+     if ((retVal = rtl8367b_setAsicLedSerialModeConfig(active,1))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_serialMode_get
+ * Description:
+ *      Get Led group congiuration mode
+ * Input:
+ *      group - LED group.
+ * Output:
+ *      pConfig - LED configuration.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT 		- Invalid input parameters.
+ * Note:
+ *       The API can get LED serial mode active configuration.
+ */
+rtk_api_ret_t rtk_led_serialMode_get(rtk_led_active_t *pActive)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData;
+
+    if ((retVal = rtl8367b_getAsicLedSerialModeConfig(pActive,&regData))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_init
+ * Description:
+ *      ACL initialization function
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - Pointer pFilter_field or pFilter_cfg point to NULL.
+ * Note:
+ *      This function enable and intialize ACL function
+ */
+rtk_api_ret_t rtk_filter_igrAcl_init(void)
+{
+    rtl8367b_acltemplate_t       aclTemp;
+    rtk_uint32                 i, j;
+    rtk_api_ret_t          ret;
+
+    if ((ret = rtk_filter_igrAcl_cfg_delAll()) != RT_ERR_OK)
+        return ret;
+
+    for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
+    {
+        for(j = 0; j < RTL8367B_ACLRULEFIELDNO;j++)
+            aclTemp.field[j] = filter_templateField[i][j];
+
+        if ((ret = rtl8367b_setAsicAclTemplate(i, &aclTemp)) != RT_ERR_OK)
+            return ret;
+    }
+
+    for(i = 0; i < RTL8367B_FIELDSEL_FORMAT_NUMBER; i++)
+    {
+        if ((ret = rtl8367b_setAsicFieldSelector(i, field_selector[i][0], field_selector[i][1])) != RT_ERR_OK)
+            return ret;
+    }
+
+    for(i=0; i < RTL8367B_PORTNO; i++)
+    {
+        if ((ret = rtl8367b_setAsicAcl(i, TRUE)) != RT_ERR_OK)
+            return ret;
+
+        if ((ret = rtl8367b_setAsicAclUnmatchedPermit(i, TRUE)) != RT_ERR_OK)
+            return ret;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_field_add
+ * Description:
+ *      Add comparison rule to an ACL configuration
+ * Input:
+ *      pFilter_cfg     - The ACL configuration that this function will add comparison rule
+ *      pFilter_field   - The comparison rule that will be added.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              	- OK
+ *      RT_ERR_FAILED          	- Failed
+ *      RT_ERR_SMI             	- SMI access error
+ *      RT_ERR_NULL_POINTER    	- Pointer pFilter_field or pFilter_cfg point to NULL.
+ *      RT_ERR_INPUT 			- Invalid input parameters.
+ * Note:
+ *      This function add a comparison rule (*pFilter_field) to an ACL configuration (*pFilter_cfg).
+ *      Pointer pFilter_cfg points to an ACL configuration structure, this structure keeps multiple ACL
+ *      comparison rules by means of linked list. Pointer pFilter_field will be added to linked
+ *      list keeped by structure that pFilter_cfg points to.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_field_add(rtk_filter_cfg_t* pFilter_cfg, rtk_filter_field_t* pFilter_field)
+{
+	rtk_uint32 i;
+	rtk_filter_field_t *tailPtr;
+
+    if(NULL == pFilter_cfg || NULL == pFilter_field)
+        return RT_ERR_NULL_POINTER;
+
+    if(pFilter_field->fieldType >= FILTER_FIELD_END)
+        return RT_ERR_ENTRY_INDEX;
+
+	if(0 == pFilter_field->fieldTemplateNo)
+	{
+		pFilter_field->fieldTemplateNo = filter_fieldSize[pFilter_field->fieldType];
+
+		for(i = 0; i < pFilter_field->fieldTemplateNo; i++)
+		{
+			pFilter_field->fieldTemplateIdx[i] = filter_fieldTemplateIndex[pFilter_field->fieldType][i];
+		}
+	}
+
+    if(NULL == pFilter_cfg->fieldHead)
+    {
+        pFilter_cfg->fieldHead = pFilter_field;
+    }
+    else
+    {
+        if (pFilter_cfg->fieldHead->next == NULL)
+        {
+            pFilter_cfg->fieldHead->next = pFilter_field;
+        }
+        else
+        {
+            tailPtr = pFilter_cfg->fieldHead->next;
+            while( tailPtr->next != NULL)
+            {
+                tailPtr = tailPtr->next;
+            }
+            tailPtr->next = pFilter_field;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+static rtk_api_ret_t _rtk_filter_igrAcl_writeDataField(rtl8367b_aclrule *aclRule, rtk_filter_field_t *fieldPtr)
+{
+    rtk_uint32 i, tempIdx,fieldIdx, ipValue, ipMask;
+    rtk_uint32 ip6addr[RTK_IPV6_ADDR_WORD_LENGTH];
+    rtk_uint32 ip6mask[RTK_IPV6_ADDR_WORD_LENGTH];
+
+	for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+	{
+		tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+
+		aclRule[tempIdx].valid = TRUE;
+	}
+
+    switch (fieldPtr->fieldType)
+    {
+    /* use DMAC structure as representative for mac structure */
+    case FILTER_FIELD_DMAC:
+    case FILTER_FIELD_SMAC:
+
+		for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+		{
+			tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+			fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+			aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.mac.value.octet[5 - i*2] | (fieldPtr->filter_pattern_union.mac.value.octet[5 - (i*2 + 1)] << 8);
+			aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.mac.mask.octet[5 - i*2] | (fieldPtr->filter_pattern_union.mac.mask.octet[5 - (i*2 + 1)] << 8);
+		}
+   		break;
+    case FILTER_FIELD_ETHERTYPE:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+			fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.etherType.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.etherType.mask;
+        }
+        break;
+    case FILTER_FIELD_IPV4_SIP:
+    case FILTER_FIELD_IPV4_DIP:
+
+		ipValue = fieldPtr->filter_pattern_union.sip.value;
+		ipMask = fieldPtr->filter_pattern_union.sip.mask;
+
+		for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+		{
+			tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+			fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+			aclRule[tempIdx].data_bits.field[fieldIdx] = (ipValue & (0xFFFF << (i << 4))) >> (i << 4);
+			aclRule[tempIdx].care_bits.field[fieldIdx] = (ipMask & (0xFFFF << (i << 4))) >> (i << 4);
+		}
+		break;
+    case FILTER_FIELD_IPV4_TOS:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.ipTos.value & 0xFF;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.ipTos.mask  & 0xFF;
+        }
+        break;
+    case FILTER_FIELD_IPV4_PROTOCOL:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.protocol.value & 0xFF;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.protocol.mask  & 0xFF;
+        }
+        break;
+    case FILTER_FIELD_IPV6_SIPV6:
+    case FILTER_FIELD_IPV6_DIPV6:
+        for(i = 0; i < RTK_IPV6_ADDR_WORD_LENGTH; i++)
+        {
+            ip6addr[i] = fieldPtr->filter_pattern_union.sipv6.value.addr[i];
+            ip6mask[i] = fieldPtr->filter_pattern_union.sipv6.mask.addr[i];
+        }
+
+		for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+		{
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+			fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            if(i < 2)
+            {
+                aclRule[tempIdx].data_bits.field[fieldIdx] = ((ip6addr[0] & (0xFFFF << (i * 16))) >> (i * 16));
+                aclRule[tempIdx].care_bits.field[fieldIdx] = ((ip6mask[0] & (0xFFFF << (i * 16))) >> (i * 16));
+            }
+            else
+            {
+                aclRule[tempIdx].data_bits.field[fieldIdx] = ((ip6addr[3] & (0xFFFF << ((i&1) * 16))) >> ((i&1) * 16));
+                aclRule[tempIdx].care_bits.field[fieldIdx] = ((ip6mask[3] & (0xFFFF << ((i&1) * 16))) >> ((i&1) * 16));
+            }
+		}
+
+		break;
+	case FILTER_FIELD_CTAG:
+    case FILTER_FIELD_STAG:
+
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.l2tag.pri.value << 13) | (fieldPtr->filter_pattern_union.l2tag.cfi.value << 12) | fieldPtr->filter_pattern_union.l2tag.vid.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.l2tag.pri.mask << 13) | (fieldPtr->filter_pattern_union.l2tag.cfi.mask << 12) | fieldPtr->filter_pattern_union.l2tag.vid.mask;
+        }
+        break;
+	case FILTER_FIELD_IPV4_FLAG:
+
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0x1FFF;
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.xf.value << 15);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.df.value << 14);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.mf.value << 13);
+
+            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0x1FFF;
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.xf.mask << 15);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.df.mask << 14);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.mf.mask << 13);
+        }
+
+        break;
+	case FILTER_FIELD_IPV4_OFFSET:
+
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0xE000;
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.inData.value;
+
+            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0xE000;
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.inData.mask;
+        }
+
+        break;
+
+	case FILTER_FIELD_IPV6_TRAFFIC_CLASS:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.value << 4;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.mask << 4;
+        }
+        break;
+	case FILTER_FIELD_IPV6_NEXT_HEADER:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.value << 8;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.mask << 8;
+        }
+        break;
+    case FILTER_FIELD_TCP_SPORT:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpSrcPort.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpSrcPort.mask;
+        }
+        break;
+    case FILTER_FIELD_TCP_DPORT:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpDstPort.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpDstPort.mask;
+        }
+        break;
+	case FILTER_FIELD_TCP_FLAG:
+
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.cwr.value << 7);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ece.value << 6);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.urg.value << 5);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ack.value << 4);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.psh.value << 3);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.rst.value << 2);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.syn.value << 1);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.tcpFlag.fin.value;
+
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.cwr.mask << 7);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ece.mask << 6);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.urg.mask << 5);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ack.mask << 4);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.psh.mask << 3);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.rst.mask << 2);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.syn.mask << 1);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.tcpFlag.fin.mask;
+        }
+        break;
+    case FILTER_FIELD_UDP_SPORT:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpSrcPort.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpSrcPort.mask;
+        }
+        break;
+    case FILTER_FIELD_UDP_DPORT:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpDstPort.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpDstPort.mask;
+        }
+        break;
+	case FILTER_FIELD_ICMP_CODE:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0xFF00;
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.icmpCode.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0xFF00;
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.icmpCode.mask;
+        }
+        break;
+	case FILTER_FIELD_ICMP_TYPE:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0x00FF;
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.icmpType.value << 8);
+            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0x00FF;
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.icmpType.mask << 8);
+        }
+        break;
+	case FILTER_FIELD_IGMP_TYPE:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.igmpType.value << 8);
+            aclRule[tempIdx].care_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.igmpType.mask << 8);
+        }
+        break;
+    case FILTER_FIELD_PATTERN_MATCH:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = ((fieldPtr->filter_pattern_union.pattern.value[i/2] >> (16 * (i%2))) & 0x0000FFFF );
+            aclRule[tempIdx].care_bits.field[fieldIdx] = ((fieldPtr->filter_pattern_union.pattern.mask[i/2] >> (16 * (i%2))) & 0x0000FFFF );
+        }
+        break;
+    case FILTER_FIELD_VID_RANGE:
+    case FILTER_FIELD_IP_RANGE:
+    case FILTER_FIELD_PORT_RANGE:
+    default:
+		tempIdx = (fieldPtr->fieldTemplateIdx[0] & 0xF0) >> 4;
+		fieldIdx = fieldPtr->fieldTemplateIdx[0] & 0x0F;
+
+        aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.value;
+        aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.mask;
+        break;
+    }
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_led_serialMode_get
+ *      rtk_filter_igrAcl_cfg_add
  * Description:
- *      Get Led group congiuration mode
+ *      Add an ACL configuration to ASIC
  * Input:
- *      group - LED group.
+ *      filter_id       - Start index of ACL configuration.
+ *      pFilter_cfg     - The ACL configuration that this function will add comparison rule
+ *      pFilter_action  - Action(s) of ACL configuration.
  * Output:
- *      pConfig - LED configuration.
+ *      ruleNum - number of rules written in acl table
  * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_INPUT 		- Invalid input parameters.
+ *      RT_ERR_OK              					- OK
+ *      RT_ERR_FAILED          					- Failed
+ *      RT_ERR_SMI             					- SMI access error
+ *      RT_ERR_NULL_POINTER    					- Pointer pFilter_field or pFilter_cfg point to NULL.
+ *      RT_ERR_INPUT 							- Invalid input parameters.
+ *      RT_ERR_ENTRY_INDEX 						- Invalid filter_id .
+ *      RT_ERR_NULL_POINTER 					- Pointer pFilter_action or pFilter_cfg point to NULL.
+ *      RT_ERR_FILTER_INACL_ACT_NOT_SUPPORT 	- Action is not supported in this chip.
+ *      RT_ERR_FILTER_INACL_RULE_NOT_SUPPORT 	- Rule is not supported.
  * Note:
- *       The API can get LED serial mode active configuration.
+ *      This function store pFilter_cfg, pFilter_action into ASIC. The starting
+ *      index(es) is filter_id.
  */
-rtk_api_ret_t rtk_led_serialMode_get(rtk_led_active_t *pActive)
+rtk_api_ret_t rtk_filter_igrAcl_cfg_add(rtk_filter_id_t filter_id, rtk_filter_cfg_t* pFilter_cfg, rtk_filter_action_t* pFilter_action, rtk_filter_number_t *ruleNum)
 {
-    rtk_api_ret_t retVal;
-    rtk_uint32 regData;
+    rtk_api_ret_t               retVal;
+    rtk_uint32                  careTagData, careTagMask;
+    rtk_uint32                  i,vidx, svidx, actType, ruleId;
+    rtk_uint32                  aclActCtrl;
+    rtk_uint32                  cpuPort;
+    rtk_filter_field_t*         fieldPtr;
+    rtl8367b_aclrule            aclRule[RTL8367B_ACLTEMPLATENO];
+    rtl8367b_aclrule            tempRule;
+    rtl8367b_acl_act_t          aclAct;
+    rtk_uint32                  noRulesAdd;
+    rtl8367b_vlanconfiguser     vlanMC;
+    rtk_uint8                   active_portmsk;
+    rtl8367b_user_vlan4kentry   vlan4K;
+    rtl8367b_svlan_memconf_t    svlan_cfg;
 
-    if ((retVal = rtl8367b_getAsicLedSerialModeConfig(pActive,&regData))!=RT_ERR_OK)
-        return retVal;
+    if(filter_id > RTL8367B_ACLRULEMAX )
+        return RT_ERR_ENTRY_INDEX;
 
-    return RT_ERR_OK;
-}
+    if(NULL == pFilter_cfg)
+        return RT_ERR_NULL_POINTER;
 
-/* Function Name:
- *      rtk_filter_igrAcl_init
- * Description:
- *      ACL initialization function
- * Input:
- *      None
- * Output:
- *      None
- * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_NULL_POINTER - Pointer pFilter_field or pFilter_cfg point to NULL.
- * Note:
- *      This function enable and intialize ACL function
- */
-rtk_api_ret_t rtk_filter_igrAcl_init(void)
-{
-    rtl8367b_acltemplate_t       aclTemp;
-    rtk_uint32                 i, j;
-    rtk_api_ret_t          ret;
+    if(NULL == pFilter_action )
+        return RT_ERR_NULL_POINTER;
 
-    if ((ret = rtk_filter_igrAcl_cfg_delAll()) != RT_ERR_OK)
-        return ret;
+    fieldPtr = pFilter_cfg->fieldHead;
 
+    /* init RULE */
     for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
     {
-        for(j = 0; j < RTL8367B_ACLRULEFIELDNO;j++)
-            aclTemp.field[j] = filter_templateField[i][j];
-
-        if ((ret = rtl8367b_setAsicAclTemplate(i, &aclTemp)) != RT_ERR_OK)
-            return ret;
-    }
+        memset(&aclRule[i], 0, sizeof(rtl8367b_aclrule));
 
-    for(i = 0; i < RTL8367B_FIELDSEL_FORMAT_NUMBER; i++)
-    {
-        if ((ret = rtl8367b_setAsicFieldSelector(i, field_selector[i][0], field_selector[i][1])) != RT_ERR_OK)
-            return ret;
+        aclRule[i].data_bits.type= i;
+        aclRule[i].care_bits.type= 0x7;
     }
 
-    for(i=0; i < RTL8367B_PORTNO; i++)
+    while(NULL != fieldPtr)
     {
-        if ((ret = rtl8367b_setAsicAcl(i, TRUE)) != RT_ERR_OK)
-            return ret;
+        _rtk_filter_igrAcl_writeDataField(aclRule, fieldPtr);
 
-        if ((ret = rtl8367b_setAsicAclUnmatchedPermit(i, TRUE)) != RT_ERR_OK)
-            return ret;
+        fieldPtr = fieldPtr->next;
     }
 
-    return RT_ERR_OK;
-}
-
-/* Function Name:
- *      rtk_filter_igrAcl_field_add
- * Description:
- *      Add comparison rule to an ACL configuration
- * Input:
- *      pFilter_cfg     - The ACL configuration that this function will add comparison rule
- *      pFilter_field   - The comparison rule that will be added.
- * Output:
- *      None
- * Return:
- *      RT_ERR_OK              	- OK
- *      RT_ERR_FAILED          	- Failed
- *      RT_ERR_SMI             	- SMI access error
- *      RT_ERR_NULL_POINTER    	- Pointer pFilter_field or pFilter_cfg point to NULL.
- *      RT_ERR_INPUT 			- Invalid input parameters.
- * Note:
- *      This function add a comparison rule (*pFilter_field) to an ACL configuration (*pFilter_cfg).
- *      Pointer pFilter_cfg points to an ACL configuration structure, this structure keeps multiple ACL
- *      comparison rules by means of linked list. Pointer pFilter_field will be added to linked
- *      list keeped by structure that pFilter_cfg points to.
- */
-rtk_api_ret_t rtk_filter_igrAcl_field_add(rtk_filter_cfg_t* pFilter_cfg, rtk_filter_field_t* pFilter_field)
-{
-	rtk_uint32 i;
-	rtk_filter_field_t *tailPtr;
+	/*set care tag mask in User Defined Field 15*/
+	/*Follow care tag should not be used while ACL template and User defined fields are fully control by system designer*/
+    /*those advanced packet type care tag is used in default template design structure only*/
+	careTagData = 0;
+	careTagMask = 0;
+        active_portmsk = 0;
 
-    if(NULL == pFilter_cfg || NULL == pFilter_field)
-        return RT_ERR_NULL_POINTER;
+	for(i = CARE_TAG_TCP; i < CARE_TAG_END; i++)
+    {
+		if(pFilter_cfg->careTag.tagType[i].mask)
+			careTagMask = careTagMask | (1 << (i-CARE_TAG_TCP));
 
-    if(pFilter_field->fieldType >= FILTER_FIELD_END)
-        return RT_ERR_ENTRY_INDEX;
+		if(pFilter_cfg->careTag.tagType[i].value)
+			careTagData = careTagData | (1 << (i-CARE_TAG_TCP));
+    }
 
-	if(0 == pFilter_field->fieldTemplateNo)
+	if(careTagData || careTagMask)
 	{
-		pFilter_field->fieldTemplateNo = filter_fieldSize[pFilter_field->fieldType];
+		i = 0;
+		while(i < RTL8367B_ACLTEMPLATENO)
+		{
+			if(aclRule[i].valid == 1 && filter_advanceCaretagField[i][0] == TRUE)
+			{
 
-		for(i = 0; i < pFilter_field->fieldTemplateNo; i++)
+				aclRule[i].data_bits.field[filter_advanceCaretagField[i][1]] = careTagData & 0xFFFF;
+				aclRule[i].care_bits.field[filter_advanceCaretagField[i][1]] = careTagMask & 0xFFFF;
+				break;
+			}
+			i++;
+		}
+		/*none of previous used template containing field 15*/
+		if(i == RTL8367B_ACLTEMPLATENO)
 		{
-			pFilter_field->fieldTemplateIdx[i] = filter_fieldTemplateIndex[pFilter_field->fieldType][i];
+			i = 0;
+			while(i <= RTL8367B_ACLTEMPLATENO)
+			{
+				if(filter_advanceCaretagField[i][0] == TRUE)
+				{
+					aclRule[i].data_bits.field[filter_advanceCaretagField[i][1]] = careTagData & 0xFFFF;
+					aclRule[i].care_bits.field[filter_advanceCaretagField[i][1]] = careTagMask & 0xFFFF;
+					aclRule[i].valid = 1;
+					break;
+				}
+				i++;
+			}
 		}
 	}
 
-    if(NULL == pFilter_cfg->fieldHead)
-    {
-        pFilter_cfg->fieldHead = pFilter_field;
-    }
-    else
+	/*Check rule number*/
+	noRulesAdd = 0;
+    for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
     {
-        if (pFilter_cfg->fieldHead->next == NULL)
-        {
-            pFilter_cfg->fieldHead->next = pFilter_field;
-        }
-        else
-        {
-            tailPtr = pFilter_cfg->fieldHead->next;
-            while( tailPtr->next != NULL)
-            {
-                tailPtr = tailPtr->next;
-            }
-            tailPtr->next = pFilter_field;
-        }
+		if(1 == aclRule[i].valid)
+		{
+			noRulesAdd ++;
+		}
     }
 
-    return RT_ERR_OK;
-}
-
-static rtk_api_ret_t _rtk_filter_igrAcl_writeDataField(rtl8367b_aclrule *aclRule, rtk_filter_field_t *fieldPtr)
-{
-    rtk_uint32 i, tempIdx,fieldIdx, ipValue, ipMask;
-    rtk_uint32 ip6addr[RTK_IPV6_ADDR_WORD_LENGTH];
-    rtk_uint32 ip6mask[RTK_IPV6_ADDR_WORD_LENGTH];
+	*ruleNum = noRulesAdd;
 
-	for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+	if((filter_id + noRulesAdd - 1) > RTL8367B_ACLRULEMAX)
 	{
-		tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-
-		aclRule[tempIdx].valid = TRUE;
+		return RT_ERR_ENTRY_INDEX;
 	}
 
-    switch (fieldPtr->fieldType)
-    {
-    /* use DMAC structure as representative for mac structure */
-    case FILTER_FIELD_DMAC:
-    case FILTER_FIELD_SMAC:
-
-		for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-		{
-			tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-			fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+	/*set care tag mask in TAG Indicator*/
+    careTagData = 0;
+	careTagMask = 0;
 
-			aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.mac.value.octet[5 - i*2] | (fieldPtr->filter_pattern_union.mac.value.octet[5 - (i*2 + 1)] << 8);
-			aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.mac.mask.octet[5 - i*2] | (fieldPtr->filter_pattern_union.mac.mask.octet[5 - (i*2 + 1)] << 8);
-		}
-   		break;
-    case FILTER_FIELD_ETHERTYPE:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+    for(i = 0; i <= CARE_TAG_IPV6;i++)
+    {
+        if(0 == pFilter_cfg->careTag.tagType[i].mask )
+        {
+            careTagMask &=  ~(1 << i);
+        }
+        else
         {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-			fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
-
-            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.etherType.value;
-            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.etherType.mask;
+            careTagMask |= (1 << i);
+            if(0 == pFilter_cfg->careTag.tagType[i].value )
+                careTagData &= ~(1 << i);
+            else
+                careTagData |= (1 << i);
         }
-        break;
-    case FILTER_FIELD_IPV4_SIP:
-    case FILTER_FIELD_IPV4_DIP:
+    }
 
-		ipValue = fieldPtr->filter_pattern_union.sip.value;
-		ipMask = fieldPtr->filter_pattern_union.sip.mask;
+    for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
+    {
+        aclRule[i].data_bits.tag_exist = (careTagData) & ACL_RULE_CARETAG_MASK;
+        aclRule[i].care_bits.tag_exist = (careTagMask) & ACL_RULE_CARETAG_MASK;
+    }
 
-		for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-		{
-			tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-			fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+    if(FILTER_FIELD_DATA_RANGE == pFilter_cfg->activeport.dataType)
+    {
 
-			aclRule[tempIdx].data_bits.field[fieldIdx] = (ipValue & (0xFFFF << (i << 4))) >> (i << 4);
-			aclRule[tempIdx].care_bits.field[fieldIdx] = (ipMask & (0xFFFF << (i << 4))) >> (i << 4);
-		}
-		break;
-    case FILTER_FIELD_IPV4_TOS:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+        if(pFilter_cfg->activeport.rangeStart >= RTL8367B_PORTNO || pFilter_cfg->activeport.rangeEnd >= RTL8367B_PORTNO
+          || pFilter_cfg->activeport.rangeEnd > pFilter_cfg->activeport.rangeStart)
+            return RT_ERR_INPUT;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.ipTos.value & 0xFF;
-            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.ipTos.mask  & 0xFF;
-        }
-        break;
-    case FILTER_FIELD_IPV4_PROTOCOL:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+        for(i = pFilter_cfg->activeport.rangeStart;i <= pFilter_cfg->activeport.rangeEnd; i++)
+            active_portmsk |= 1 << i;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.protocol.value & 0xFF;
-            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.protocol.mask  & 0xFF;
-        }
-        break;
-    case FILTER_FIELD_IPV6_SIPV6:
-    case FILTER_FIELD_IPV6_DIPV6:
-        for(i = 0; i < RTK_IPV6_ADDR_WORD_LENGTH; i++)
+        for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
         {
-            ip6addr[i] = fieldPtr->filter_pattern_union.sipv6.value.addr[i];
-            ip6mask[i] = fieldPtr->filter_pattern_union.sipv6.mask.addr[i];
+    		if(1 == aclRule[i].valid)
+            {
+                aclRule[0].data_bits.active_portmsk = active_portmsk;
+                aclRule[0].care_bits.active_portmsk = 0xFF;
+            }
         }
+    }
+    else if(FILTER_FIELD_DATA_MASK == pFilter_cfg->activeport.dataType )
+    {
+        if(pFilter_cfg->activeport.value >= (1 << RTL8367B_PORTNO) || pFilter_cfg->activeport.mask >= (1 << RTL8367B_PORTNO))
+            return RT_ERR_INPUT;
 
-		for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-		{
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-			fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+        for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
+        {
+    		if(1 == aclRule[i].valid)
+    		{
+    			aclRule[i].data_bits.active_portmsk = pFilter_cfg->activeport.value;
+                aclRule[i].care_bits.active_portmsk = pFilter_cfg->activeport.mask;
+    		}
+        }
+    }
+    else
+        return RT_ERR_INPUT;
 
-            if(i < 2)
-            {
-                aclRule[tempIdx].data_bits.field[fieldIdx] = ((ip6addr[0] & (0xFFFF << (i * 16))) >> (i * 16));
-                aclRule[tempIdx].care_bits.field[fieldIdx] = ((ip6mask[0] & (0xFFFF << (i * 16))) >> (i * 16));
-            }
-            else
-            {
-                aclRule[tempIdx].data_bits.field[fieldIdx] = ((ip6addr[3] & (0xFFFF << ((i&1) * 16))) >> ((i&1) * 16));
-                aclRule[tempIdx].care_bits.field[fieldIdx] = ((ip6mask[3] & (0xFFFF << ((i&1) * 16))) >> ((i&1) * 16));
-            }
-		}
+    if(pFilter_cfg->invert >= FILTER_INVERT_END )
+        return RT_ERR_INPUT;
 
-		break;
-	case FILTER_FIELD_CTAG:
-    case FILTER_FIELD_STAG:
 
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+	/*Last action gets high priority if actions are the same*/
+    memset(&aclAct, 0, sizeof(rtl8367b_acl_act_t));
+    aclActCtrl = 0;
+    for(actType = 0; actType < FILTER_ENACT_END; actType ++)
+    {
+        if(pFilter_action->actEnable[actType])
         {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+            switch (actType)
+            {
+            case FILTER_ENACT_INGRESS_CVLAN_INDEX:
+                if(pFilter_action->filterIngressCvlanIdx > RTL8367B_CVIDXMAX)
+                    return RT_ERR_INPUT;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.l2tag.pri.value << 13) | (fieldPtr->filter_pattern_union.l2tag.cfi.value << 12) | fieldPtr->filter_pattern_union.l2tag.vid.value;
-            aclRule[tempIdx].care_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.l2tag.pri.mask << 13) | (fieldPtr->filter_pattern_union.l2tag.cfi.mask << 12) | fieldPtr->filter_pattern_union.l2tag.vid.mask;
-        }
-        break;
-	case FILTER_FIELD_IPV4_FLAG:
+                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_INGRESS);
+                aclAct.cvidx_cact = pFilter_action->filterIngressCvlanIdx;
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+            case FILTER_ENACT_INGRESS_CVLAN_VID:
+                if(pFilter_action->filterIngressCvlanVid > RTL8367B_VIDMAX)
+                    return RT_ERR_INPUT;
 
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+				/*Search avalid vlan member configuration or create new one*/
+				for(vidx = 0; vidx <= RTL8367B_CVIDXMAX; vidx ++)
+				{
+				    if((retVal = rtl8367b_getAsicVlanMemberConfig(vidx, &vlanMC)) != RT_ERR_OK)
+				        return retVal;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0x1FFF;
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.xf.value << 15);
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.df.value << 14);
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.mf.value << 13);
+					if(pFilter_action->filterIngressCvlanVid == vlanMC.evid)
+						break;
+				}
 
-            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0x1FFF;
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.xf.mask << 15);
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.df.mask << 14);
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.mf.mask << 13);
-        }
+				/*Did not have existed matched VID, search free entries*/
+				if(vidx == (RTL8367B_CVIDXMAX + 1))
+				{
+					for(vidx = 0; vidx <= RTL8367B_CVIDXMAX; vidx ++)
+					{
+					    if((retVal = rtl8367b_getAsicVlanMemberConfig(vidx, &vlanMC)) != RT_ERR_OK)
+					        return retVal;
 
-        break;
-	case FILTER_FIELD_IPV4_OFFSET:
+						if(0 == vlanMC.mbr && 0 == vlanMC.evid)
+                        {
+                            /* Empty entry, copy member and untag mask from 4K VLAN */
+                            vlan4K.vid = pFilter_action->filterIngressCvlanVid;
 
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+                            if ((retVal = rtl8367b_getAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
+                                return retVal;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0xE000;
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.inData.value;
+                            if(vlan4K.mbr == 0x00)
+                                return RT_ERR_VLAN_EMPTY_ENTRY;
 
-            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0xE000;
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.inData.mask;
-        }
+                            vlanMC.evid     = vlan4K.vid;
+                            vlanMC.mbr      = vlan4K.mbr;
+                            vlanMC.fid_msti = vlan4K.fid_msti;
+                            vlanMC.meteridx = vlan4K.meteridx;
+                            vlanMC.envlanpol= vlan4K.envlanpol;
+                            vlanMC.vbpen    = vlan4K.vbpen;
+                            vlanMC.vbpri    = vlan4K.vbpri;
 
-        break;
+                            if((retVal = rtl8367b_setAsicVlanMemberConfig(vidx, &vlanMC)) != RT_ERR_OK)
+                                return retVal;
 
-	case FILTER_FIELD_IPV6_TRAFFIC_CLASS:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+                            break;
+                        }
+					}
 
+					if(vidx == (RTL8367B_CVIDXMAX + 1))
+						return RT_ERR_INPUT;
+				}
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.value << 4;
-            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.mask << 4;
-        }
-        break;
-	case FILTER_FIELD_IPV6_NEXT_HEADER:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_INGRESS);
+                aclAct.cvidx_cact = vidx;
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+            case FILTER_ENACT_CVLAN_INGRESS:
+                if(pFilter_action->filterCvlanIdx > RTL8367B_CVIDXMAX)
+                    return RT_ERR_INPUT;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.value << 8;
-            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.mask << 8;
-        }
-        break;
-    case FILTER_FIELD_TCP_SPORT:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
+                aclAct.cvidx_cact = pFilter_action->filterCvlanIdx;
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+            case FILTER_ENACT_CVLAN_EGRESS:
+                if(pFilter_action->filterCvlanIdx > RTL8367B_CVIDXMAX)
+                    return RT_ERR_INPUT;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpSrcPort.value;
-            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpSrcPort.mask;
-        }
-        break;
-    case FILTER_FIELD_TCP_DPORT:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
+                aclAct.cvidx_cact = pFilter_action->filterCvlanIdx;
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+             case FILTER_ENACT_CVLAN_SVID:
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpDstPort.value;
-            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpDstPort.mask;
-        }
-        break;
-	case FILTER_FIELD_TCP_FLAG:
+                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+             case FILTER_ENACT_POLICING_1:
+                if(pFilter_action->filterPolicingIdx[1] >= (RTL8367B_METERNO * 2))
+                    return RT_ERR_INPUT;
+
+                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
+                aclAct.cvidx_cact = pFilter_action->filterPolicingIdx[1];
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
 
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+            case FILTER_ENACT_EGRESS_SVLAN_INDEX:
+                if(pFilter_action->filterEgressSvlanIdx > RTL8367B_SVIDXMAX )
+                    return RT_ERR_INPUT;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.cwr.value << 7);
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ece.value << 6);
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.urg.value << 5);
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ack.value << 4);
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.psh.value << 3);
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.rst.value << 2);
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.syn.value << 1);
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.tcpFlag.fin.value;
+                aclAct.sact = FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_SVLAN_EGRESS);
+                aclAct.svidx_sact = pFilter_action->filterEgressSvlanIdx;
+                aclActCtrl |= FILTER_ENACT_SVLAN_MASK;
+                break;
+            case FILTER_ENACT_SVLAN_INGRESS:
+            case FILTER_ENACT_SVLAN_EGRESS:
 
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.cwr.mask << 7);
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ece.mask << 6);
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.urg.mask << 5);
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ack.mask << 4);
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.psh.mask << 3);
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.rst.mask << 2);
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.syn.mask << 1);
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.tcpFlag.fin.mask;
-        }
-        break;
-    case FILTER_FIELD_UDP_SPORT:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+                if(pFilter_action->filterSvlanVid > RTL8367B_VIDMAX)
+                    return RT_ERR_INPUT;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpSrcPort.value;
-            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpSrcPort.mask;
-        }
-        break;
-    case FILTER_FIELD_UDP_DPORT:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+                for(svidx = 0; svidx <= RTL8367B_SVIDXMAX; svidx++)
+                {
+                    if((retVal = rtl8367b_getAsicSvlanMemberConfiguration(svidx, &svlan_cfg)) != RT_ERR_OK)
+				        return retVal;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpDstPort.value;
-            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpDstPort.mask;
-        }
-        break;
-	case FILTER_FIELD_ICMP_CODE:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+                    if(pFilter_action->filterSvlanVid == svlan_cfg.vs_svid)
+						break;
+                }
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0xFF00;
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.icmpCode.value;
-            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0xFF00;
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.icmpCode.mask;
-        }
-        break;
-	case FILTER_FIELD_ICMP_TYPE:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+                if(svidx == (RTL8367B_SVIDXMAX + 1))
+                    return RT_ERR_INPUT;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0x00FF;
-            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.icmpType.value << 8);
-            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0x00FF;
-            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.icmpType.mask << 8);
-        }
-        break;
-	case FILTER_FIELD_IGMP_TYPE:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+                aclAct.sact = FILTER_ENACT_SVLAN_TYPE(actType);
+				aclAct.svidx_sact = svidx;
+                aclActCtrl |= FILTER_ENACT_SVLAN_MASK;
+                break;
+            case FILTER_ENACT_SVLAN_CVID:
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.igmpType.value << 8);
-            aclRule[tempIdx].care_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.igmpType.mask << 8);
-        }
-        break;
-    case FILTER_FIELD_PATTERN_MATCH:
-        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
-        {
-            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
-            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+                aclAct.sact = FILTER_ENACT_SVLAN_TYPE(actType);
+                aclActCtrl |= FILTER_ENACT_SVLAN_MASK;
+				break;
+            case FILTER_ENACT_POLICING_2:
+                if(pFilter_action->filterPolicingIdx[2] >= (RTL8367B_METERNO * 2))
+                    return RT_ERR_INPUT;
 
-            aclRule[tempIdx].data_bits.field[fieldIdx] = ((fieldPtr->filter_pattern_union.pattern.value[i/2] >> (16 * (i%2))) & 0x0000FFFF );
-            aclRule[tempIdx].care_bits.field[fieldIdx] = ((fieldPtr->filter_pattern_union.pattern.mask[i/2] >> (16 * (i%2))) & 0x0000FFFF );
-        }
-        break;
-    case FILTER_FIELD_VID_RANGE:
-    case FILTER_FIELD_IP_RANGE:
-    case FILTER_FIELD_PORT_RANGE:
-    default:
-		tempIdx = (fieldPtr->fieldTemplateIdx[0] & 0xF0) >> 4;
-		fieldIdx = fieldPtr->fieldTemplateIdx[0] & 0x0F;
+                aclAct.sact = FILTER_ENACT_SVLAN_TYPE(actType);
+                aclAct.svidx_sact = pFilter_action->filterPolicingIdx[2];
+                aclActCtrl |= FILTER_ENACT_SVLAN_MASK;
+                break;
+            case FILTER_ENACT_POLICING_0:
+                if(pFilter_action->filterPolicingIdx[0] >= (RTL8367B_METERNO * 2))
+                    return RT_ERR_INPUT;
 
-        aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.value;
-        aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.mask;
-        break;
-    }
+                aclAct.aclmeteridx = pFilter_action->filterPolicingIdx[0];
+                aclActCtrl |= FILTER_ENACT_POLICING_MASK;
+                break;
+            case FILTER_ENACT_PRIORITY:
+            case FILTER_ENACT_1P_REMARK:
+                if(pFilter_action->filterPriority > RTL8367B_PRIMAX)
+                    return RT_ERR_INPUT;
 
-    return RT_ERR_OK;
-}
+                aclAct.priact = FILTER_ENACT_PRI_TYPE(actType);
+                aclAct.pridx = pFilter_action->filterPriority;
+                aclActCtrl |= FILTER_ENACT_PRIORITY_MASK;
+                break;
+            case FILTER_ENACT_DSCP_REMARK:
+                if(pFilter_action->filterPriority > RTL8367B_DSCPMAX)
+                    return RT_ERR_INPUT;
 
-/* Function Name:
- *      rtk_filter_igrAcl_cfg_add
- * Description:
- *      Add an ACL configuration to ASIC
- * Input:
- *      filter_id       - Start index of ACL configuration.
- *      pFilter_cfg     - The ACL configuration that this function will add comparison rule
- *      pFilter_action  - Action(s) of ACL configuration.
- * Output:
- *      ruleNum - number of rules written in acl table
- * Return:
- *      RT_ERR_OK              					- OK
- *      RT_ERR_FAILED          					- Failed
- *      RT_ERR_SMI             					- SMI access error
- *      RT_ERR_NULL_POINTER    					- Pointer pFilter_field or pFilter_cfg point to NULL.
- *      RT_ERR_INPUT 							- Invalid input parameters.
- *      RT_ERR_ENTRY_INDEX 						- Invalid filter_id .
- *      RT_ERR_NULL_POINTER 					- Pointer pFilter_action or pFilter_cfg point to NULL.
- *      RT_ERR_FILTER_INACL_ACT_NOT_SUPPORT 	- Action is not supported in this chip.
- *      RT_ERR_FILTER_INACL_RULE_NOT_SUPPORT 	- Rule is not supported.
- * Note:
- *      This function store pFilter_cfg, pFilter_action into ASIC. The starting
- *      index(es) is filter_id.
- */
-rtk_api_ret_t rtk_filter_igrAcl_cfg_add(rtk_filter_id_t filter_id, rtk_filter_cfg_t* pFilter_cfg, rtk_filter_action_t* pFilter_action, rtk_filter_number_t *ruleNum)
-{
-    rtk_api_ret_t               retVal;
-    rtk_uint32                  careTagData, careTagMask;
-    rtk_uint32                  i,vidx, svidx, actType, ruleId;
-    rtk_uint32                  aclActCtrl;
-    rtk_uint32                  cpuPort;
-    rtk_filter_field_t*         fieldPtr;
-    rtl8367b_aclrule            aclRule[RTL8367B_ACLTEMPLATENO];
-    rtl8367b_aclrule            tempRule;
-    rtl8367b_acl_act_t          aclAct;
-    rtk_uint32                  noRulesAdd;
-    rtl8367b_vlanconfiguser     vlanMC;
-    rtk_uint8                   active_portmsk;
-    rtl8367b_user_vlan4kentry   vlan4K;
-    rtl8367b_svlan_memconf_t    svlan_cfg;
+                aclAct.priact = FILTER_ENACT_PRI_TYPE(actType);
+                aclAct.pridx = pFilter_action->filterPriority;
+                aclActCtrl |= FILTER_ENACT_PRIORITY_MASK;
+                break;
+            case FILTER_ENACT_POLICING_3:
+                if(pFilter_action->filterPriority >= (RTL8367B_METERNO * 2))
+                    return RT_ERR_INPUT;
 
-    if(filter_id > RTL8367B_ACLRULEMAX )
-        return RT_ERR_ENTRY_INDEX;
+                aclAct.priact = FILTER_ENACT_PRI_TYPE(actType);
+                aclAct.pridx = pFilter_action->filterPolicingIdx[3];
+                aclActCtrl |= FILTER_ENACT_PRIORITY_MASK;
+                break;
+            case FILTER_ENACT_DROP:
 
-    if(NULL == pFilter_cfg)
-        return RT_ERR_NULL_POINTER;
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(FILTER_ENACT_REDIRECT);
+                aclAct.fwdpmask = 0;
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+            case FILTER_ENACT_REDIRECT:
+                if(pFilter_action->filterRedirectPortmask >= (1 << RTK_MAX_NUM_OF_PORT))
+                    return RT_ERR_INPUT;
 
-    if(NULL == pFilter_action )
-        return RT_ERR_NULL_POINTER;
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
+                aclAct.fwdpmask = pFilter_action->filterRedirectPortmask;
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+            case FILTER_ENACT_ADD_DSTPORT:
+                if(pFilter_action->filterAddDstPortmask >= (1 << RTK_MAX_NUM_OF_PORT))
+                    return RT_ERR_INPUT;
 
-    fieldPtr = pFilter_cfg->fieldHead;
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
+                aclAct.fwdpmask = pFilter_action->filterAddDstPortmask;
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+            case FILTER_ENACT_MIRROR:
 
-    /* init RULE */
-    for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
-    {
-        memset(&aclRule[i], 0, sizeof(rtl8367b_aclrule));
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
+                aclAct.fwdpmask = pFilter_action->filterAddDstPortmask;
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+            case FILTER_ENACT_TRAP_CPU:
 
-        aclRule[i].data_bits.type= i;
-        aclRule[i].care_bits.type= 0x7;
-    }
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+            case FILTER_ENACT_COPY_CPU:
+                if((retVal = rtl8367b_getAsicCputagTrapPort(&cpuPort)) != RT_ERR_OK)
+                    return retVal;
 
-    while(NULL != fieldPtr)
-    {
-        _rtk_filter_igrAcl_writeDataField(aclRule, fieldPtr);
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(FILTER_ENACT_MIRROR);
+                aclAct.fwdpmask = 1 << cpuPort;
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+            case FILTER_ENACT_INTERRUPT:
 
-        fieldPtr = fieldPtr->next;
+                aclAct.aclint = TRUE;
+                aclActCtrl |= FILTER_ENACT_INTGPIO_MASK;
+                break;
+            case FILTER_ENACT_GPO:
+
+                aclAct.gpio_en = TRUE;
+                aclAct.gpio_pin = pFilter_action->filterPin;
+                aclActCtrl |= FILTER_ENACT_INTGPIO_MASK;
+                break;
+            default:
+                return RT_ERR_FILTER_INACL_ACT_NOT_SUPPORT;
+            }
+        }
     }
 
-	/*set care tag mask in User Defined Field 15*/
-	/*Follow care tag should not be used while ACL template and User defined fields are fully control by system designer*/
-    /*those advanced packet type care tag is used in default template design structure only*/
-	careTagData = 0;
-	careTagMask = 0;
-        active_portmsk = 0;
 
-	for(i = CARE_TAG_TCP; i < CARE_TAG_END; i++)
+	/*check if free ACL rules are enough*/
+    for(i = filter_id; i < (filter_id + noRulesAdd); i++)
     {
-		if(pFilter_cfg->careTag.tagType[i].mask)
-			careTagMask = careTagMask | (1 << (i-CARE_TAG_TCP));
+        if((retVal = rtl8367b_getAsicAclRule(i, &tempRule)) != RT_ERR_OK )
+            return retVal;
 
-		if(pFilter_cfg->careTag.tagType[i].value)
-			careTagData = careTagData | (1 << (i-CARE_TAG_TCP));
+        if(tempRule.valid == TRUE)
+        {
+            return RT_ERR_TBL_FULL;
+        }
     }
 
-	if(careTagData || careTagMask)
-	{
-		i = 0;
-		while(i < RTL8367B_ACLTEMPLATENO)
-		{
-			if(aclRule[i].valid == 1 && filter_advanceCaretagField[i][0] == TRUE)
-			{
-
-				aclRule[i].data_bits.field[filter_advanceCaretagField[i][1]] = careTagData & 0xFFFF;
-				aclRule[i].care_bits.field[filter_advanceCaretagField[i][1]] = careTagMask & 0xFFFF;
-				break;
-			}
-			i++;
-		}
-		/*none of previous used template containing field 15*/
-		if(i == RTL8367B_ACLTEMPLATENO)
-		{
-			i = 0;
-			while(i <= RTL8367B_ACLTEMPLATENO)
-			{
-				if(filter_advanceCaretagField[i][0] == TRUE)
-				{
-					aclRule[i].data_bits.field[filter_advanceCaretagField[i][1]] = careTagData & 0xFFFF;
-					aclRule[i].care_bits.field[filter_advanceCaretagField[i][1]] = careTagMask & 0xFFFF;
-					aclRule[i].valid = 1;
-					break;
-				}
-				i++;
-			}
-		}
-	}
-
-	/*Check rule number*/
-	noRulesAdd = 0;
+	ruleId = 0;
     for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
     {
-		if(1 == aclRule[i].valid)
-		{
-			noRulesAdd ++;
+        if(aclRule[i].valid == TRUE)
+        {
+            /* write ACL action control */
+            if((retVal = rtl8367b_setAsicAclActCtrl(filter_id + ruleId, aclActCtrl)) != RT_ERR_OK )
+                return retVal;
+            /* write ACL action */
+            if((retVal = rtl8367b_setAsicAclAct(filter_id + ruleId, &aclAct)) != RT_ERR_OK )
+                return retVal;
+            /* write ACL not */
+            if((retVal = rtl8367b_setAsicAclNot(filter_id + ruleId, pFilter_cfg->invert)) != RT_ERR_OK )
+                return retVal;
+            /* write ACL rule */
+            if((retVal = rtl8367b_setAsicAclRule(filter_id + ruleId, &aclRule[i])) != RT_ERR_OK )
+                return retVal;
+
+            /* only the first rule will be written with input action control, aclActCtrl of other rules will be zero */
+            aclActCtrl = 0;
+            memset(&aclAct, 0, sizeof(rtl8367b_acl_act_t));
+
+			ruleId ++;
 		}
     }
 
-	*ruleNum = noRulesAdd;
+    return RT_ERR_OK;
+}
 
-	if((filter_id + noRulesAdd - 1) > RTL8367B_ACLRULEMAX)
-	{
-		return RT_ERR_ENTRY_INDEX;
-	}
+/* Function Name:
+ *      rtk_filter_igrAcl_cfg_del
+ * Description:
+ *      Delete an ACL configuration from ASIC
+ * Input:
+ *      filter_id   - Start index of ACL configuration.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_ENTRYIDX  - Invalid filter_id.
+ * Note:
+ *      This function delete a group of ACL rules starting from filter_id.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_cfg_del(rtk_filter_id_t filter_id)
+{
 
-	/*set care tag mask in TAG Indicator*/
-    careTagData = 0;
-	careTagMask = 0;
+    rtl8367b_aclrule initRule;
+    rtl8367b_acl_act_t  initAct;
+    rtk_api_ret_t ret;
 
-    for(i = 0; i <= CARE_TAG_IPV6;i++)
-    {
-        if(0 == pFilter_cfg->careTag.tagType[i].mask )
-        {
-            careTagMask &=  ~(1 << i);
-        }
-        else
-        {
-            careTagMask |= (1 << i);
-            if(0 == pFilter_cfg->careTag.tagType[i].value )
-                careTagData &= ~(1 << i);
-            else
-                careTagData |= (1 << i);
-        }
-    }
+    if(filter_id > RTL8367B_ACLRULEMAX )
+        return RT_ERR_FILTER_ENTRYIDX;
 
-    for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
-    {
-        aclRule[i].data_bits.tag_exist = (careTagData) & ACL_RULE_CARETAG_MASK;
-        aclRule[i].care_bits.tag_exist = (careTagMask) & ACL_RULE_CARETAG_MASK;
-    }
+    memset(&initRule, 0, sizeof(rtl8367b_aclrule));
+    memset(&initAct, 0, sizeof(rtl8367b_acl_act_t));
 
-    if(FILTER_FIELD_DATA_RANGE == pFilter_cfg->activeport.dataType)
-    {
+    if((ret = rtl8367b_setAsicAclRule(filter_id, &initRule)) != RT_ERR_OK)
+        return ret;
+    if((ret = rtl8367b_setAsicAclActCtrl(filter_id, FILTER_ENACT_INIT_MASK))!= RT_ERR_OK)
+        return ret;
+    if((ret = rtl8367b_setAsicAclAct(filter_id, &initAct)) != RT_ERR_OK)
+        return ret;
+    if((ret = rtl8367b_setAsicAclNot(filter_id, DISABLED)) != RT_ERR_OK )
+        return ret;
 
-        if(pFilter_cfg->activeport.rangeStart >= RTL8367B_PORTNO || pFilter_cfg->activeport.rangeEnd >= RTL8367B_PORTNO
-          || pFilter_cfg->activeport.rangeEnd > pFilter_cfg->activeport.rangeStart)
-            return RT_ERR_INPUT;
+    return RT_ERR_OK;
+}
 
-        for(i = pFilter_cfg->activeport.rangeStart;i <= pFilter_cfg->activeport.rangeEnd; i++)
-            active_portmsk |= 1 << i;
+/* Function Name:
+ *      rtk_filter_igrAcl_cfg_delAll
+ * Description:
+ *      Delete all ACL entries from ASIC
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      This function delete all ACL configuration from ASIC.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_cfg_delAll(void)
+{
+    rtl8367b_aclrule  initRule;
+    rtl8367b_acl_act_t   initAct;
+    rtk_uint32            i;
+    rtk_api_ret_t     ret;
 
-        for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
-        {
-    		if(1 == aclRule[i].valid)
-            {
-                aclRule[0].data_bits.active_portmsk = active_portmsk;
-                aclRule[0].care_bits.active_portmsk = 0xFF;
-            }
-        }
-    }
-    else if(FILTER_FIELD_DATA_MASK == pFilter_cfg->activeport.dataType )
-    {
-        if(pFilter_cfg->activeport.value >= (1 << RTL8367B_PORTNO) || pFilter_cfg->activeport.mask >= (1 << RTL8367B_PORTNO))
-            return RT_ERR_INPUT;
+    memset(&initRule, 0, sizeof(rtl8367b_aclrule));
+    memset(&initAct, 0, sizeof(rtl8367b_acl_act_t));
 
-        for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
-        {
-    		if(1 == aclRule[i].valid)
-    		{
-    			aclRule[i].data_bits.active_portmsk = pFilter_cfg->activeport.value;
-                aclRule[i].care_bits.active_portmsk = pFilter_cfg->activeport.mask;
-    		}
-        }
+    for(i = 0; i < RTL8367B_ACLRULENO; i++)
+    {
+        if((ret = rtl8367b_setAsicAclRule(i, &initRule)) != RT_ERR_OK)
+            return ret;
+        if((ret = rtl8367b_setAsicAclActCtrl(i, FILTER_ENACT_INIT_MASK))!= RT_ERR_OK)
+            return ret;
+         if ((ret = rtl8367b_setAsicAclAct(i, &initAct)) != RT_ERR_OK)
+            return ret;
+        if((ret = rtl8367b_setAsicAclNot(i, DISABLED)) != RT_ERR_OK )
+            return ret;
     }
-    else
-        return RT_ERR_INPUT;
-
-    if(pFilter_cfg->invert >= FILTER_INVERT_END )
-        return RT_ERR_INPUT;
 
+    return RT_ERR_OK;
+}
 
-	/*Last action gets high priority if actions are the same*/
-    memset(&aclAct, 0, sizeof(rtl8367b_acl_act_t));
-    aclActCtrl = 0;
-    for(actType = 0; actType < FILTER_ENACT_END; actType ++)
-    {
-        if(pFilter_action->actEnable[actType])
-        {
-            switch (actType)
-            {
-            case FILTER_ENACT_INGRESS_CVLAN_INDEX:
-                if(pFilter_action->filterIngressCvlanIdx > RTL8367B_CVIDXMAX)
-                    return RT_ERR_INPUT;
+/* Function Name:
+ *      rtk_filter_igrAcl_cfg_get
+ * Description:
+ *      Get one ingress acl configuration from ASIC.
+ * Input:
+ *      filter_id       - Start index of ACL configuration.
+ * Output:
+ *      pFilter_cfg     - buffer pointer of ingress acl data
+ *      pFilter_action  - buffer pointer of ingress acl action
+ * Return:
+ *      RT_ERR_OK              	- OK
+ *      RT_ERR_FAILED          	- Failed
+ *      RT_ERR_SMI             	- SMI access error
+ *      RT_ERR_NULL_POINTER 	- Pointer pFilter_action or pFilter_cfg point to NULL.
+ *      RT_ERR_FILTER_ENTRYIDX 	- Invalid entry index.
+ * Note:
+ *      This function delete all ACL configuration from ASIC.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_cfg_get(rtk_filter_id_t filter_id, rtk_filter_cfg_raw_t *pFilter_cfg, rtk_filter_action_t *pAction)
+{
+    rtk_api_ret_t               retVal;
+    rtk_uint32                  i, tmp;
+    rtl8367b_aclrule            aclRule;
+    rtl8367b_acl_act_t          aclAct;
+    rtk_uint32                  cpuPort;
+    rtl8367b_acltemplate_t      type;
+    rtl8367b_svlan_memconf_t    svlan_cfg;
+    rtl8367b_vlanconfiguser     vlanMC;
 
-                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_INGRESS);
-                aclAct.cvidx_cact = pFilter_action->filterIngressCvlanIdx;
-                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
-                break;
-            case FILTER_ENACT_INGRESS_CVLAN_VID:
-                if(pFilter_action->filterIngressCvlanVid > RTL8367B_VIDMAX)
-                    return RT_ERR_INPUT;
+    if ((retVal = rtl8367b_getAsicAclRule(filter_id, &aclRule)) != RT_ERR_OK)
+        return retVal;
 
-				/*Search avalid vlan member configuration or create new one*/
-				for(vidx = 0; vidx <= RTL8367B_CVIDXMAX; vidx ++)
-				{
-				    if((retVal = rtl8367b_getAsicVlanMemberConfig(vidx, &vlanMC)) != RT_ERR_OK)
-				        return retVal;
+    pFilter_cfg->activeport.dataType = FILTER_FIELD_DATA_MASK;
+    pFilter_cfg->activeport.value = aclRule.data_bits.active_portmsk;
+    pFilter_cfg->activeport.mask = aclRule.care_bits.active_portmsk;
 
-					if(pFilter_action->filterIngressCvlanVid == vlanMC.evid)
-						break;
-				}
+    for(i = 0; i <= CARE_TAG_IPV6; i++)
+    {
+        if(aclRule.data_bits.tag_exist & (1 << i))
+            pFilter_cfg->careTag.tagType[i].value = 1;
+        else
+            pFilter_cfg->careTag.tagType[i].value = 0;
 
-				/*Did not have existed matched VID, search free entries*/
-				if(vidx == (RTL8367B_CVIDXMAX + 1))
-				{
-					for(vidx = 0; vidx <= RTL8367B_CVIDXMAX; vidx ++)
-					{
-					    if((retVal = rtl8367b_getAsicVlanMemberConfig(vidx, &vlanMC)) != RT_ERR_OK)
-					        return retVal;
+        if (aclRule.care_bits.tag_exist & (1 << i))
+            pFilter_cfg->careTag.tagType[i].mask = 1;
+        else
+            pFilter_cfg->careTag.tagType[i].mask = 0;
+    }
 
-						if(0 == vlanMC.mbr && 0 == vlanMC.evid)
-                        {
-                            /* Empty entry, copy member and untag mask from 4K VLAN */
-                            vlan4K.vid = pFilter_action->filterIngressCvlanVid;
+    if(filter_advanceCaretagField[aclRule.data_bits.type][0] == TRUE)
+    {
+        /* Advanced Care tag setting */
+        for(i = CARE_TAG_TCP; i < CARE_TAG_END; i++)
+        {
+            if(aclRule.data_bits.field[filter_advanceCaretagField[aclRule.data_bits.type][1]] & (0x0001 << (i-CARE_TAG_TCP)) )
+                pFilter_cfg->careTag.tagType[i].value = 1;
+            else
+                pFilter_cfg->careTag.tagType[i].value = 0;
 
-                            if ((retVal = rtl8367b_getAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
-                                return retVal;
+            if(aclRule.care_bits.field[filter_advanceCaretagField[aclRule.data_bits.type][1]] & (0x0001 << (i-CARE_TAG_TCP)) )
+                pFilter_cfg->careTag.tagType[i].mask = 1;
+            else
+                pFilter_cfg->careTag.tagType[i].mask = 0;
+        }
+    }
 
-                            if(vlan4K.mbr == 0x00)
-                                return RT_ERR_VLAN_EMPTY_ENTRY;
+    for(i = 0; i < RTL8367B_ACLRULEFIELDNO; i++)
+    {
+        pFilter_cfg->careFieldRaw[i] = aclRule.care_bits.field[i];
+        pFilter_cfg->dataFieldRaw[i] = aclRule.data_bits.field[i];
+    }
 
-                            vlanMC.evid     = vlan4K.vid;
-                            vlanMC.mbr      = vlan4K.mbr;
-                            vlanMC.fid_msti = vlan4K.fid_msti;
-                            vlanMC.meteridx = vlan4K.meteridx;
-                            vlanMC.envlanpol= vlan4K.envlanpol;
-                            vlanMC.vbpen    = vlan4K.vbpen;
-                            vlanMC.vbpri    = vlan4K.vbpri;
+    if ((retVal = rtl8367b_getAsicAclNot(filter_id, &tmp))!= RT_ERR_OK)
+        return retVal;
 
-                            if((retVal = rtl8367b_setAsicVlanMemberConfig(vidx, &vlanMC)) != RT_ERR_OK)
-                                return retVal;
+    pFilter_cfg->invert = tmp;
 
-                            break;
-                        }
-					}
+    pFilter_cfg->valid = aclRule.valid;
 
-					if(vidx == (RTL8367B_CVIDXMAX + 1))
-						return RT_ERR_INPUT;
-				}
+    memset(pAction, 0, sizeof(rtk_filter_action_t));
 
-                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_INGRESS);
-                aclAct.cvidx_cact = vidx;
-                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
-                break;
-            case FILTER_ENACT_CVLAN_INGRESS:
-                if(pFilter_action->filterCvlanIdx > RTL8367B_CVIDXMAX)
-                    return RT_ERR_INPUT;
+    if ((retVal = rtl8367b_getAsicAclActCtrl(filter_id, &tmp))!= RT_ERR_OK)
+        return retVal;
 
-                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
-                aclAct.cvidx_cact = pFilter_action->filterCvlanIdx;
-                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
-                break;
-            case FILTER_ENACT_CVLAN_EGRESS:
-                if(pFilter_action->filterCvlanIdx > RTL8367B_CVIDXMAX)
-                    return RT_ERR_INPUT;
+    if ((retVal = rtl8367b_getAsicAclAct(filter_id, &aclAct)) != RT_ERR_OK)
+        return retVal;
 
-                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
-                aclAct.cvidx_cact = pFilter_action->filterCvlanIdx;
-                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
-                break;
-             case FILTER_ENACT_CVLAN_SVID:
+    if(tmp & FILTER_ENACT_FWD_MASK)
+    {
+        if(aclAct.fwdact == RTL8367B_ACL_FWD_TRAP )
+            pAction->actEnable[FILTER_ENACT_TRAP_CPU] = TRUE;
+        else if (aclAct.fwdact == RTL8367B_ACL_FWD_MIRRORFUNTION )
+        {
+        	pAction->actEnable[FILTER_ENACT_MIRROR] = TRUE;
+			pAction->filterAddDstPortmask = aclAct.fwdpmask;
+		}
+        else if (aclAct.fwdact == RTL8367B_ACL_FWD_REDIRECT)
+        {
+            if(aclAct.fwdpmask == 0 )
+                pAction->actEnable[FILTER_ENACT_DROP] = TRUE;
+            else
+            {
+                pAction->actEnable[FILTER_ENACT_REDIRECT] = TRUE;
+                pAction->filterRedirectPortmask = aclAct.fwdpmask;
+            }
+        }
+        else if (aclAct.fwdact == RTL8367B_ACL_FWD_MIRROR)
+        {
+            if((retVal = rtl8367b_getAsicCputagTrapPort(&cpuPort)) != RT_ERR_OK)
+                return retVal;
+            if (aclAct.fwdpmask == (1 << cpuPort))
+            {
+                pAction->actEnable[FILTER_ENACT_COPY_CPU] = TRUE;
+            }
+            else
+            {
+                pAction->actEnable[FILTER_ENACT_ADD_DSTPORT] = TRUE;
+                pAction->filterAddDstPortmask = aclAct.fwdpmask;
+            }
+        }
+        else
+        {
+            return RT_ERR_FAILED;
+        }
+    }
 
-                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
-                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
-                break;
-             case FILTER_ENACT_POLICING_1:
-                if(pFilter_action->filterPolicingIdx[1] >= (RTL8367B_METERNO * 2))
-                    return RT_ERR_INPUT;
+    if(tmp & FILTER_ENACT_POLICING_MASK)
+    {
+        pAction->actEnable[FILTER_ENACT_POLICING_0] = TRUE;
+        pAction->filterPolicingIdx[0] = aclAct.aclmeteridx;
+    }
 
-                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
-                aclAct.cvidx_cact = pFilter_action->filterPolicingIdx[1];
-                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
-                break;
+    if(tmp & FILTER_ENACT_PRIORITY_MASK)
+    {
+    	if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_PRIORITY))
+        {
+        	pAction->actEnable[FILTER_ENACT_PRIORITY] = TRUE;
+        	pAction->filterPriority = aclAct.pridx;
+    	}
+		else if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_1P_REMARK))
+        {
+        	pAction->actEnable[FILTER_ENACT_1P_REMARK] = TRUE;
+        	pAction->filterPriority = aclAct.pridx;
+    	}
+		else if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_DSCP_REMARK))
+        {
+        	pAction->actEnable[FILTER_ENACT_DSCP_REMARK] = TRUE;
+        	pAction->filterPriority = aclAct.pridx;
+    	}
+		else if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_POLICING_3))
+        {
+        	pAction->actEnable[FILTER_ENACT_POLICING_3] = TRUE;
+        	pAction->filterPolicingIdx[3]  = aclAct.pridx;
+    	}
+    }
 
-            case FILTER_ENACT_EGRESS_SVLAN_INDEX:
-                if(pFilter_action->filterEgressSvlanIdx > RTL8367B_SVIDXMAX )
-                    return RT_ERR_INPUT;
+    if(tmp & FILTER_ENACT_SVLAN_MASK)
+    {
+    	if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_SVLAN_INGRESS))
+        {
+            if((retVal = rtl8367b_getAsicSvlanMemberConfiguration(aclAct.svidx_sact, &svlan_cfg)) != RT_ERR_OK)
+				return retVal;
 
-                aclAct.sact = FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_SVLAN_EGRESS);
-                aclAct.svidx_sact = pFilter_action->filterEgressSvlanIdx;
-                aclActCtrl |= FILTER_ENACT_SVLAN_MASK;
-                break;
-            case FILTER_ENACT_SVLAN_INGRESS:
-            case FILTER_ENACT_SVLAN_EGRESS:
+        	pAction->actEnable[FILTER_ENACT_SVLAN_INGRESS] = TRUE;
+        	pAction->filterSvlanIdx = aclAct.svidx_sact;
+            pAction->filterSvlanVid = svlan_cfg.vs_svid;
+    	}
+    	else if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_SVLAN_EGRESS))
+        {
+            if((retVal = rtl8367b_getAsicSvlanMemberConfiguration(aclAct.svidx_sact, &svlan_cfg)) != RT_ERR_OK)
+				return retVal;
 
-                if(pFilter_action->filterSvlanVid > RTL8367B_VIDMAX)
-                    return RT_ERR_INPUT;
+        	pAction->actEnable[FILTER_ENACT_SVLAN_EGRESS] = TRUE;
+            pAction->filterEgressSvlanIdx = aclAct.svidx_sact;
+        	pAction->filterSvlanIdx = aclAct.svidx_sact;
+            pAction->filterSvlanVid = svlan_cfg.vs_svid;
+    	}
+    	else if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_SVLAN_CVID))
+        	pAction->actEnable[FILTER_ENACT_SVLAN_CVID] = TRUE;
+    	else if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_POLICING_2))
+        {
+        	pAction->actEnable[FILTER_ENACT_POLICING_2] = TRUE;
+        	pAction->filterPolicingIdx[2]  = aclAct.svidx_sact;
+    	}
+    }
 
-                for(svidx = 0; svidx <= RTL8367B_SVIDXMAX; svidx++)
-                {
-                    if((retVal = rtl8367b_getAsicSvlanMemberConfiguration(svidx, &svlan_cfg)) != RT_ERR_OK)
-				        return retVal;
 
-                    if(pFilter_action->filterSvlanVid == svlan_cfg.vs_svid)
-						break;
-                }
+    if(tmp & FILTER_ENACT_CVLAN_MASK)
+    {
+        if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_INGRESS))
+        {
+            if((retVal = rtl8367b_getAsicVlanMemberConfig(aclAct.cvidx_cact, &vlanMC)) != RT_ERR_OK)
+                return retVal;
 
-                if(svidx == (RTL8367B_SVIDXMAX + 1))
-                    return RT_ERR_INPUT;
+            pAction->actEnable[FILTER_ENACT_CVLAN_INGRESS] = TRUE;
+            pAction->filterCvlanIdx         = aclAct.cvidx_cact;
+            pAction->filterIngressCvlanVid  = vlanMC.evid;
+            pAction->filterIngressCvlanIdx  = aclAct.cvidx_cact;
+        }
+        else if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_EGRESS))
+        {
+            pAction->actEnable[FILTER_ENACT_CVLAN_EGRESS] = TRUE;
+            pAction->filterCvlanIdx = aclAct.cvidx_cact;
+        }
+        else if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_SVID))
+        {
+            pAction->actEnable[FILTER_ENACT_CVLAN_SVID] = TRUE;
+        }
+    	else if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_POLICING_1))
+        {
+        	pAction->actEnable[FILTER_ENACT_POLICING_1] = TRUE;
+        	pAction->filterPolicingIdx[1]  = aclAct.cvidx_cact;
+    	}
+    }
 
-                aclAct.sact = FILTER_ENACT_SVLAN_TYPE(actType);
-				aclAct.svidx_sact = svidx;
-                aclActCtrl |= FILTER_ENACT_SVLAN_MASK;
-                break;
-            case FILTER_ENACT_SVLAN_CVID:
+    if(tmp & FILTER_ENACT_INTGPIO_MASK)
+    {
+		if(TRUE == aclAct.aclint)
+		{
+			pAction->actEnable[FILTER_ENACT_INTERRUPT] = TRUE;
+		}
 
-                aclAct.sact = FILTER_ENACT_SVLAN_TYPE(actType);
-                aclActCtrl |= FILTER_ENACT_SVLAN_MASK;
-				break;
-            case FILTER_ENACT_POLICING_2:
-                if(pFilter_action->filterPolicingIdx[2] >= (RTL8367B_METERNO * 2))
-                    return RT_ERR_INPUT;
+		if(TRUE == aclAct.gpio_en)
+		{
+			pAction->actEnable[FILTER_ENACT_GPO] = TRUE;
+			pAction->filterPin = aclAct.gpio_pin;
+		}
+    }
 
-                aclAct.sact = FILTER_ENACT_SVLAN_TYPE(actType);
-                aclAct.svidx_sact = pFilter_action->filterPolicingIdx[2];
-                aclActCtrl |= FILTER_ENACT_SVLAN_MASK;
-                break;
-            case FILTER_ENACT_POLICING_0:
-                if(pFilter_action->filterPolicingIdx[0] >= (RTL8367B_METERNO * 2))
-                    return RT_ERR_INPUT;
+    /* Get field type of RAW data */
+    if ((retVal = rtl8367b_getAsicAclTemplate(aclRule.data_bits.type, &type))!= RT_ERR_OK)
+        return retVal;
 
-                aclAct.aclmeteridx = pFilter_action->filterPolicingIdx[0];
-                aclActCtrl |= FILTER_ENACT_POLICING_MASK;
-                break;
-            case FILTER_ENACT_PRIORITY:
-            case FILTER_ENACT_1P_REMARK:
-                if(pFilter_action->filterPriority > RTL8367B_PRIMAX)
-                    return RT_ERR_INPUT;
+    for(i = 0; i < RTL8367B_ACLRULEFIELDNO; i++)
+    {
+        pFilter_cfg->fieldRawType[i] = type.field[i];
+    }/* end of for(i...) */
 
-                aclAct.priact = FILTER_ENACT_PRI_TYPE(actType);
-                aclAct.pridx = pFilter_action->filterPriority;
-                aclActCtrl |= FILTER_ENACT_PRIORITY_MASK;
-                break;
-            case FILTER_ENACT_DSCP_REMARK:
-                if(pFilter_action->filterPriority > RTL8367B_DSCPMAX)
-                    return RT_ERR_INPUT;
+    return RT_ERR_OK;
+}
 
-                aclAct.priact = FILTER_ENACT_PRI_TYPE(actType);
-                aclAct.pridx = pFilter_action->filterPriority;
-                aclActCtrl |= FILTER_ENACT_PRIORITY_MASK;
-                break;
-            case FILTER_ENACT_POLICING_3:
-                if(pFilter_action->filterPriority >= (RTL8367B_METERNO * 2))
-                    return RT_ERR_INPUT;
+/* Function Name:
+ *      rtk_filter_igrAcl_unmatchAction_set
+ * Description:
+ *      Set action to packets when no ACL configuration match
+ * Input:
+ *      port    - Port id.
+ *      action  - Action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID 		- Invalid port id.
+ *      RT_ERR_INPUT 		- Invalid input parameters.
+ * Note:
+ *      This function sets action of packets when no ACL configruation matches.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_unmatchAction_set(rtk_port_t port, rtk_filter_unmatch_action_t action)
+{
+    rtk_api_ret_t ret;
 
-                aclAct.priact = FILTER_ENACT_PRI_TYPE(actType);
-                aclAct.pridx = pFilter_action->filterPolicingIdx[3];
-                aclActCtrl |= FILTER_ENACT_PRIORITY_MASK;
-                break;
-            case FILTER_ENACT_DROP:
+    if(port > RTL8367B_PORTIDMAX )
+        return RT_ERR_PORT_ID;
 
-                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(FILTER_ENACT_REDIRECT);
-                aclAct.fwdpmask = 0;
-                aclActCtrl |= FILTER_ENACT_FWD_MASK;
-                break;
-            case FILTER_ENACT_REDIRECT:
-                if(pFilter_action->filterRedirectPortmask >= (1 << RTK_MAX_NUM_OF_PORT))
-                    return RT_ERR_INPUT;
+    if(action >= FILTER_UNMATCH_END)
+        return RT_ERR_INPUT;
 
-                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
-                aclAct.fwdpmask = pFilter_action->filterRedirectPortmask;
-                aclActCtrl |= FILTER_ENACT_FWD_MASK;
-                break;
-            case FILTER_ENACT_ADD_DSTPORT:
-                if(pFilter_action->filterAddDstPortmask >= (1 << RTK_MAX_NUM_OF_PORT))
-                    return RT_ERR_INPUT;
+    if((ret = rtl8367b_setAsicAclUnmatchedPermit(port, action)) != RT_ERR_OK)
+       return ret;
 
-                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
-                aclAct.fwdpmask = pFilter_action->filterAddDstPortmask;
-                aclActCtrl |= FILTER_ENACT_FWD_MASK;
-                break;
-            case FILTER_ENACT_MIRROR:
+    return RT_ERR_OK;
+}
 
-                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
-                aclAct.fwdpmask = pFilter_action->filterAddDstPortmask;
-                aclActCtrl |= FILTER_ENACT_FWD_MASK;
-                break;
-            case FILTER_ENACT_TRAP_CPU:
+/* Function Name:
+ *      rtk_filter_igrAcl_unmatchAction_get
+ * Description:
+ *      Get action to packets when no ACL configuration match
+ * Input:
+ *      port    - Port id.
+ * Output:
+ *      pAction - Action.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port id.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This function gets action of packets when no ACL configruation matches.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_unmatchAction_get(rtk_port_t port, rtk_filter_unmatch_action_t* pAction)
+{
+    rtk_api_ret_t ret;
 
-                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
-                aclActCtrl |= FILTER_ENACT_FWD_MASK;
-                break;
-            case FILTER_ENACT_COPY_CPU:
-                if((retVal = rtl8367b_getAsicCputagTrapPort(&cpuPort)) != RT_ERR_OK)
-                    return retVal;
+    if(port > RTL8367B_PORTIDMAX)
+        return RT_ERR_PORT_ID;
 
-                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(FILTER_ENACT_MIRROR);
-                aclAct.fwdpmask = 1 << cpuPort;
-                aclActCtrl |= FILTER_ENACT_FWD_MASK;
-                break;
-            case FILTER_ENACT_INTERRUPT:
+    if((ret = rtl8367b_getAsicAclUnmatchedPermit(port, pAction)) != RT_ERR_OK)
+       return ret;
 
-                aclAct.aclint = TRUE;
-                aclActCtrl |= FILTER_ENACT_INTGPIO_MASK;
-                break;
-            case FILTER_ENACT_GPO:
+    return RT_ERR_OK;
+}
 
-                aclAct.gpio_en = TRUE;
-                aclAct.gpio_pin = pFilter_action->filterPin;
-                aclActCtrl |= FILTER_ENACT_INTGPIO_MASK;
-                break;
-            default:
-                return RT_ERR_FILTER_INACL_ACT_NOT_SUPPORT;
-            }
-        }
-    }
+/* Function Name:
+ *      rtk_filter_igrAcl_state_set
+ * Description:
+ *      Set state of ingress ACL.
+ * Input:
+ *      port    - Port id.
+ *      state   - Ingress ACL state.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port id.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This function gets action of packets when no ACL configruation matches.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_state_set(rtk_port_t port, rtk_filter_state_t state)
+{
+    rtk_api_ret_t ret;
 
+    if(port > RTL8367B_PORTIDMAX )
+        return RT_ERR_PORT_ID;
+    if(state >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
 
-	/*check if free ACL rules are enough*/
-    for(i = filter_id; i < (filter_id + noRulesAdd); i++)
-    {
-        if((retVal = rtl8367b_getAsicAclRule(i, &tempRule)) != RT_ERR_OK )
-            return retVal;
+    if((ret = rtl8367b_setAsicAcl(port, state)) != RT_ERR_OK)
+       return ret;
 
-        if(tempRule.valid == TRUE)
-        {
-            return RT_ERR_TBL_FULL;
-        }
-    }
+    return RT_ERR_OK;
+}
 
-	ruleId = 0;
-    for(i = 0; i < RTL8367B_ACLTEMPLATENO; i++)
-    {
-        if(aclRule[i].valid == TRUE)
-        {
-            /* write ACL action control */
-            if((retVal = rtl8367b_setAsicAclActCtrl(filter_id + ruleId, aclActCtrl)) != RT_ERR_OK )
-                return retVal;
-            /* write ACL action */
-            if((retVal = rtl8367b_setAsicAclAct(filter_id + ruleId, &aclAct)) != RT_ERR_OK )
-                return retVal;
-            /* write ACL not */
-            if((retVal = rtl8367b_setAsicAclNot(filter_id + ruleId, pFilter_cfg->invert)) != RT_ERR_OK )
-                return retVal;
-            /* write ACL rule */
-            if((retVal = rtl8367b_setAsicAclRule(filter_id + ruleId, &aclRule[i])) != RT_ERR_OK )
-                return retVal;
+/* Function Name:
+ *      rtk_filter_igrAcl_state_get
+ * Description:
+ *      Get state of ingress ACL.
+ * Input:
+ *      port    - Port id.
+ * Output:
+ *      pState  - Ingress ACL state.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port id.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This function gets action of packets when no ACL configruation matches.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_state_get(rtk_port_t port, rtk_filter_state_t* pState)
+{
+    rtk_api_ret_t ret;
 
-            /* only the first rule will be written with input action control, aclActCtrl of other rules will be zero */
-            aclActCtrl = 0;
-            memset(&aclAct, 0, sizeof(rtl8367b_acl_act_t));
+    if(port > RTL8367B_PORTIDMAX )
+        return RT_ERR_PORT_ID;
 
-			ruleId ++;
-		}
-    }
+    if((ret = rtl8367b_getAsicAcl(port, pState)) != RT_ERR_OK)
+       return ret;
 
     return RT_ERR_OK;
 }
-
 /* Function Name:
- *      rtk_filter_igrAcl_cfg_del
+ *      rtk_filter_igrAcl_template_set
  * Description:
- *      Delete an ACL configuration from ASIC
+ *      Set template of ingress ACL.
  * Input:
- *      filter_id   - Start index of ACL configuration.
+ *      template - Ingress ACL template
  * Output:
  *      None
  * Return:
- *      RT_ERR_OK               - OK
- *      RT_ERR_FAILED           - Failed
- *      RT_ERR_SMI              - SMI access error
- *      RT_ERR_FILTER_ENTRYIDX  - Invalid filter_id.
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Invalid input parameters.
  * Note:
- *      This function delete a group of ACL rules starting from filter_id.
+ *      This function set ACL template.
  */
-rtk_api_ret_t rtk_filter_igrAcl_cfg_del(rtk_filter_id_t filter_id)
+rtk_api_ret_t rtk_filter_igrAcl_template_set(rtk_filter_template_t *aclTemplate)
 {
-
-    rtl8367b_aclrule initRule;
-    rtl8367b_acl_act_t  initAct;
     rtk_api_ret_t ret;
+    rtk_uint32 idxField;
+    rtl8367b_acltemplate_t aclType;
 
-    if(filter_id > RTL8367B_ACLRULEMAX )
-        return RT_ERR_FILTER_ENTRYIDX;
+    if(aclTemplate->index >= RTK_MAX_NUM_OF_FILTER_TYPE)
+        return RT_ERR_INPUT;
 
-    memset(&initRule, 0, sizeof(rtl8367b_aclrule));
-    memset(&initAct, 0, sizeof(rtl8367b_acl_act_t));
+    for(idxField = 0; idxField < RTK_MAX_NUM_OF_FILTER_FIELD; idxField ++)
+    {
+        aclType.field[idxField] = aclTemplate->fieldType[idxField];
+    }
 
-    if((ret = rtl8367b_setAsicAclRule(filter_id, &initRule)) != RT_ERR_OK)
-        return ret;
-    if((ret = rtl8367b_setAsicAclActCtrl(filter_id, FILTER_ENACT_INIT_MASK))!= RT_ERR_OK)
-        return ret;
-    if((ret = rtl8367b_setAsicAclAct(filter_id, &initAct)) != RT_ERR_OK)
-        return ret;
+    ret = rtl8367b_setAsicAclTemplate(aclTemplate->index, &aclType);
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_igrAcl_cfg_delAll
+ *      rtk_filter_igrAcl_template_get
  * Description:
- *      Delete all ACL entries from ASIC
+ *      Get template of ingress ACL.
  * Input:
- *      None
+ *      template - Ingress ACL template
  * Output:
  *      None
  * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
  * Note:
- *      This function delete all ACL configuration from ASIC.
+ *      This function gets template of ACL.
  */
-rtk_api_ret_t rtk_filter_igrAcl_cfg_delAll(void)
+rtk_api_ret_t rtk_filter_igrAcl_template_get(rtk_filter_template_t *aclTemplate)
 {
-    rtl8367b_aclrule  initRule;
-    rtl8367b_acl_act_t   initAct;
-    rtk_uint32            i;
-    rtk_api_ret_t     ret;
+    rtk_api_ret_t ret;
+    rtk_uint32 idxField;
+    rtl8367b_acltemplate_t aclType;
 
-    memset(&initRule, 0, sizeof(rtl8367b_aclrule));
-    memset(&initAct, 0, sizeof(rtl8367b_acl_act_t));
+    if(aclTemplate->index >= RTK_MAX_NUM_OF_FILTER_TYPE)
+        return RT_ERR_INPUT;
 
-    for(i = 0; i < RTL8367B_ACLRULENO; i++)
+   if((ret = rtl8367b_getAsicAclTemplate(aclTemplate->index, &aclType)) != RT_ERR_OK)
+       return ret;
+
+    for(idxField = 0; idxField < RTK_MAX_NUM_OF_FILTER_FIELD; idxField ++)
     {
-        if((ret = rtl8367b_setAsicAclRule(i, &initRule)) != RT_ERR_OK)
-            return ret;
-        if((ret = rtl8367b_setAsicAclActCtrl(i, FILTER_ENACT_INIT_MASK))!= RT_ERR_OK)
-            return ret;
-         if ((ret = rtl8367b_setAsicAclAct(i, &initAct)) != RT_ERR_OK)
-            return ret;
+        aclTemplate->fieldType[idxField] = aclType.field[idxField];
     }
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_igrAcl_cfg_get
+ *      rtk_filter_igrAcl_field_sel_set
  * Description:
- *      Get one ingress acl configuration from ASIC.
+ *      Set user defined field selectors in HSB
  * Input:
- *      filter_id       - Start index of ACL configuration.
+ *      index 		- index of field selector 0-15
+ *      format 		- Format of field selector
+ *      offset 		- Retrieving data offset
  * Output:
- *      pFilter_cfg     - buffer pointer of ingress acl data
- *      pFilter_action  - buffer pointer of ingress acl action
+ *      None
  * Return:
- *      RT_ERR_OK              	- OK
- *      RT_ERR_FAILED          	- Failed
- *      RT_ERR_SMI             	- SMI access error
- *      RT_ERR_NULL_POINTER 	- Pointer pFilter_action or pFilter_cfg point to NULL.
- *      RT_ERR_FILTER_ENTRYIDX 	- Invalid entry index.
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
  * Note:
- *      This function delete all ACL configuration from ASIC.
- */
-rtk_api_ret_t rtk_filter_igrAcl_cfg_get(rtk_filter_id_t filter_id, rtk_filter_cfg_raw_t *pFilter_cfg, rtk_filter_action_t *pAction)
-{
-    rtk_api_ret_t               retVal;
-    rtk_uint32                  i, tmp;
-    rtl8367b_aclrule            aclRule;
-    rtl8367b_acl_act_t          aclAct;
-    rtk_uint32                  cpuPort;
-    rtl8367b_acltemplate_t      type;
-    rtl8367b_svlan_memconf_t    svlan_cfg;
-    rtl8367b_vlanconfiguser     vlanMC;
-
-    if ((retVal = rtl8367b_getAsicAclRule(filter_id, &aclRule)) != RT_ERR_OK)
-        return retVal;
-
-    pFilter_cfg->activeport.dataType = FILTER_FIELD_DATA_MASK;
-    pFilter_cfg->activeport.value = aclRule.data_bits.active_portmsk;
-    pFilter_cfg->activeport.mask = aclRule.care_bits.active_portmsk;
-
-    for(i = 0; i <= CARE_TAG_IPV6; i++)
-    {
-        if(aclRule.data_bits.tag_exist & (1 << i))
-            pFilter_cfg->careTag.tagType[i].value = 1;
-        else
-            pFilter_cfg->careTag.tagType[i].value = 0;
-
-        if (aclRule.care_bits.tag_exist & (1 << i))
-            pFilter_cfg->careTag.tagType[i].mask = 1;
-        else
-            pFilter_cfg->careTag.tagType[i].mask = 0;
-    }
-
-    if(filter_advanceCaretagField[aclRule.data_bits.type][0] == TRUE)
-    {
-        /* Advanced Care tag setting */
-        for(i = CARE_TAG_TCP; i < CARE_TAG_END; i++)
-        {
-            if(aclRule.data_bits.field[filter_advanceCaretagField[aclRule.data_bits.type][1]] & (0x0001 << (i-CARE_TAG_TCP)) )
-                pFilter_cfg->careTag.tagType[i].value = 1;
-            else
-                pFilter_cfg->careTag.tagType[i].value = 0;
-
-            if(aclRule.care_bits.field[filter_advanceCaretagField[aclRule.data_bits.type][1]] & (0x0001 << (i-CARE_TAG_TCP)) )
-                pFilter_cfg->careTag.tagType[i].mask = 1;
-            else
-                pFilter_cfg->careTag.tagType[i].mask = 0;
-        }
-    }
-
-    for(i = 0; i < RTL8367B_ACLRULEFIELDNO; i++)
-    {
-        pFilter_cfg->careFieldRaw[i] = aclRule.care_bits.field[i];
-        pFilter_cfg->dataFieldRaw[i] = aclRule.data_bits.field[i];
-    }
-
-    if ((retVal = rtl8367b_getAsicAclNot(filter_id, &tmp))!= RT_ERR_OK)
-        return retVal;
-
-    pFilter_cfg->invert = tmp;
-
-    pFilter_cfg->valid = aclRule.valid;
-
-    memset(pAction, 0, sizeof(rtk_filter_action_t));
-
-    if ((retVal = rtl8367b_getAsicAclActCtrl(filter_id, &tmp))!= RT_ERR_OK)
-        return retVal;
-
-    if ((retVal = rtl8367b_getAsicAclAct(filter_id, &aclAct)) != RT_ERR_OK)
-        return retVal;
-
-    if(tmp & FILTER_ENACT_FWD_MASK)
-    {
-        if(aclAct.fwdact == RTL8367B_ACL_FWD_TRAP )
-            pAction->actEnable[FILTER_ENACT_TRAP_CPU] = TRUE;
-        else if (aclAct.fwdact == RTL8367B_ACL_FWD_MIRRORFUNTION )
-        {
-        	pAction->actEnable[FILTER_ENACT_MIRROR] = TRUE;
-			pAction->filterAddDstPortmask = aclAct.fwdpmask;
-		}
-        else if (aclAct.fwdact == RTL8367B_ACL_FWD_REDIRECT)
-        {
-            if(aclAct.fwdpmask == 0 )
-                pAction->actEnable[FILTER_ENACT_DROP] = TRUE;
-            else
-            {
-                pAction->actEnable[FILTER_ENACT_REDIRECT] = TRUE;
-                pAction->filterRedirectPortmask = aclAct.fwdpmask;
-            }
-        }
-        else if (aclAct.fwdact == RTL8367B_ACL_FWD_MIRROR)
-        {
-            if((retVal = rtl8367b_getAsicCputagTrapPort(&cpuPort)) != RT_ERR_OK)
-                return retVal;
-            if (aclAct.fwdpmask == (1 << cpuPort))
-            {
-                pAction->actEnable[FILTER_ENACT_COPY_CPU] = TRUE;
-            }
-            else
-            {
-                pAction->actEnable[FILTER_ENACT_ADD_DSTPORT] = TRUE;
-                pAction->filterAddDstPortmask = aclAct.fwdpmask;
-            }
-        }
-        else
-        {
-            return RT_ERR_FAILED;
-        }
-    }
-
-    if(tmp & FILTER_ENACT_POLICING_MASK)
-    {
-        pAction->actEnable[FILTER_ENACT_POLICING_0] = TRUE;
-        pAction->filterPolicingIdx[0] = aclAct.aclmeteridx;
-    }
-
-    if(tmp & FILTER_ENACT_PRIORITY_MASK)
-    {
-    	if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_PRIORITY))
-        {
-        	pAction->actEnable[FILTER_ENACT_PRIORITY] = TRUE;
-        	pAction->filterPriority = aclAct.pridx;
-    	}
-		else if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_1P_REMARK))
-        {
-        	pAction->actEnable[FILTER_ENACT_1P_REMARK] = TRUE;
-        	pAction->filterPriority = aclAct.pridx;
-    	}
-		else if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_DSCP_REMARK))
-        {
-        	pAction->actEnable[FILTER_ENACT_DSCP_REMARK] = TRUE;
-        	pAction->filterPriority = aclAct.pridx;
-    	}
-		else if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_POLICING_3))
-        {
-        	pAction->actEnable[FILTER_ENACT_POLICING_3] = TRUE;
-        	pAction->filterPolicingIdx[3]  = aclAct.pridx;
-    	}
-    }
-
-    if(tmp & FILTER_ENACT_SVLAN_MASK)
-    {
-    	if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_SVLAN_INGRESS))
-        {
-            if((retVal = rtl8367b_getAsicSvlanMemberConfiguration(aclAct.svidx_sact, &svlan_cfg)) != RT_ERR_OK)
-				return retVal;
-
-        	pAction->actEnable[FILTER_ENACT_SVLAN_INGRESS] = TRUE;
-        	pAction->filterSvlanIdx = aclAct.svidx_sact;
-            pAction->filterSvlanVid = svlan_cfg.vs_svid;
-    	}
-    	else if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_SVLAN_EGRESS))
-        {
-            if((retVal = rtl8367b_getAsicSvlanMemberConfiguration(aclAct.svidx_sact, &svlan_cfg)) != RT_ERR_OK)
-				return retVal;
+ *      System support 16 user defined field selctors.
+ * 		Each selector can be enabled or disable.
+ *      User can defined retrieving 16-bits in many predefiend
+ * 		standard l2/l3/l4 payload.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_field_sel_set(rtk_uint32 index, rtk_field_sel_t format, rtk_uint32 offset)
+{
+    rtk_api_ret_t ret;
 
-        	pAction->actEnable[FILTER_ENACT_SVLAN_EGRESS] = TRUE;
-            pAction->filterEgressSvlanIdx = aclAct.svidx_sact;
-        	pAction->filterSvlanIdx = aclAct.svidx_sact;
-            pAction->filterSvlanVid = svlan_cfg.vs_svid;
-    	}
-    	else if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_SVLAN_CVID))
-        	pAction->actEnable[FILTER_ENACT_SVLAN_CVID] = TRUE;
-    	else if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_POLICING_2))
-        {
-        	pAction->actEnable[FILTER_ENACT_POLICING_2] = TRUE;
-        	pAction->filterPolicingIdx[2]  = aclAct.svidx_sact;
-    	}
-    }
+    if(index >= RTL8367B_FIELDSEL_FORMAT_NUMBER)
+        return RT_ERR_OUT_OF_RANGE;
 
+    if(format >= FORMAT_END)
+        return RT_ERR_OUT_OF_RANGE;
 
-    if(tmp & FILTER_ENACT_CVLAN_MASK)
-    {
-        if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_INGRESS))
-        {
-            if((retVal = rtl8367b_getAsicVlanMemberConfig(aclAct.cvidx_cact, &vlanMC)) != RT_ERR_OK)
-                return retVal;
+    if(offset > RTL8367B_FIELDSEL_MAX_OFFSET)
+        return RT_ERR_OUT_OF_RANGE;
 
-            pAction->actEnable[FILTER_ENACT_CVLAN_INGRESS] = TRUE;
-            pAction->filterCvlanIdx         = aclAct.cvidx_cact;
-            pAction->filterIngressCvlanVid  = vlanMC.evid;
-            pAction->filterIngressCvlanIdx  = aclAct.cvidx_cact;
-        }
-        else if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_EGRESS))
-        {
-            pAction->actEnable[FILTER_ENACT_CVLAN_EGRESS] = TRUE;
-            pAction->filterCvlanIdx = aclAct.cvidx_cact;
-        }
-        else if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_SVID))
-        {
-            pAction->actEnable[FILTER_ENACT_CVLAN_SVID] = TRUE;
-        }
-    	else if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_POLICING_1))
-        {
-        	pAction->actEnable[FILTER_ENACT_POLICING_1] = TRUE;
-        	pAction->filterPolicingIdx[1]  = aclAct.cvidx_cact;
-    	}
-    }
+    if((ret = rtl8367b_setAsicFieldSelector(index, (rtk_uint32)format, offset)) != RT_ERR_OK)
+       return ret;
 
-    if(tmp & FILTER_ENACT_INTGPIO_MASK)
-    {
-		if(TRUE == aclAct.aclint)
-		{
-			pAction->actEnable[FILTER_ENACT_INTERRUPT] = TRUE;
-		}
+    return RT_ERR_OK;
+}
 
-		if(TRUE == aclAct.gpio_en)
-		{
-			pAction->actEnable[FILTER_ENACT_GPO] = TRUE;
-			pAction->filterPin = aclAct.gpio_pin;
-		}
-    }
+/* Function Name:
+ *      rtk_filter_igrAcl_field_sel_get
+ * Description:
+ *      Get user defined field selectors in HSB
+ * Input:
+ *      index 	    - index of field selector 0-15
+ * Output:
+ *      pFormat 	- Format of field selector
+ *      pOffset 	- Retrieving data offset
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_field_sel_get(rtk_uint32 index, rtk_field_sel_t *pFormat, rtk_uint32 *pOffset)
+{
+    rtk_api_ret_t ret;
 
-    /* Get field type of RAW data */
-    if ((retVal = rtl8367b_getAsicAclTemplate(aclRule.data_bits.type, &type))!= RT_ERR_OK)
-        return retVal;
+    if(index >= RTL8367B_FIELDSEL_FORMAT_NUMBER)
+        return RT_ERR_OUT_OF_RANGE;
 
-    for(i = 0; i < RTL8367B_ACLRULEFIELDNO; i++)
-    {
-        pFilter_cfg->fieldRawType[i] = type.field[i];
-    }/* end of for(i...) */
+    if((ret = rtl8367b_getAsicFieldSelector(index, pFormat, pOffset)) != RT_ERR_OK)
+       return ret;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_igrAcl_unmatchAction_set
+ *      rtk_filter_iprange_set
  * Description:
- *      Set action to packets when no ACL configuration match
+ *      Set IP Range check
  * Input:
- *      port    - Port id.
- *      action  - Action.
+ *      index 	    - index of IP Range 0-15
+ *      type        - IP Range check type, 0:Delete a entry, 1: IPv4_SIP, 2: IPv4_DIP, 3:IPv6_SIP, 4:IPv6_DIP
+ *      upperIp     - The upper bound of IP range
+ *      lowerIp     - The lower Bound of IP range
  * Output:
- *      None
+ *      None.
  * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_PORT_ID 		- Invalid port id.
- *      RT_ERR_INPUT 		- Invalid input parameters.
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
  * Note:
- *      This function sets action of packets when no ACL configruation matches.
+ *      upperIp must be larger or equal than lowerIp.
  */
-rtk_api_ret_t rtk_filter_igrAcl_unmatchAction_set(rtk_port_t port, rtk_filter_unmatch_action_t action)
+rtk_api_ret_t rtk_filter_iprange_set(rtk_uint32 index, rtk_filter_iprange_t type, ipaddr_t upperIp, ipaddr_t lowerIp)
 {
     rtk_api_ret_t ret;
 
-    if(port > RTL8367B_PORTIDMAX )
-        return RT_ERR_PORT_ID;
+    if(index > RTL8367B_ACLRANGEMAX)
+		return RT_ERR_OUT_OF_RANGE;
 
-    if(action >= FILTER_UNMATCH_END)
+    if(type >= IPRANGE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(lowerIp > upperIp)
         return RT_ERR_INPUT;
 
-    if((ret = rtl8367b_setAsicAclUnmatchedPermit(port, action)) != RT_ERR_OK)
+    if((ret = rtl8367b_setAsicAclIpRange(index, type, upperIp, lowerIp)) != RT_ERR_OK)
        return ret;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_igrAcl_unmatchAction_get
+ *      rtk_filter_iprange_get
  * Description:
- *      Get action to packets when no ACL configuration match
+ *      Set IP Range check
  * Input:
- *      port    - Port id.
+ *      index 	    - index of IP Range 0-15
  * Output:
- *      pAction - Action.
+ *      pType        - IP Range check type, 0:Delete a entry, 1: IPv4_SIP, 2: IPv4_DIP, 3:IPv6_SIP, 4:IPv6_DIP
+ *      pUpperIp     - The upper bound of IP range
+ *      pLowerIp     - The lower Bound of IP range
  * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_PORT_ID      - Invalid port id.
- *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
  * Note:
- *      This function gets action of packets when no ACL configruation matches.
+ *      None.
  */
-rtk_api_ret_t rtk_filter_igrAcl_unmatchAction_get(rtk_port_t port, rtk_filter_unmatch_action_t* pAction)
+rtk_api_ret_t rtk_filter_iprange_get(rtk_uint32 index, rtk_filter_iprange_t *pType, ipaddr_t *pUpperIp, ipaddr_t *pLowerIp)
 {
     rtk_api_ret_t ret;
 
-    if(port > RTL8367B_PORTIDMAX)
-        return RT_ERR_PORT_ID;
+    if(index > RTL8367B_ACLRANGEMAX)
+		return RT_ERR_OUT_OF_RANGE;
 
-    if((ret = rtl8367b_getAsicAclUnmatchedPermit(port, pAction)) != RT_ERR_OK)
+    if((ret = rtl8367b_getAsicAclIpRange(index, pType, pUpperIp, pLowerIp)) != RT_ERR_OK)
        return ret;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_igrAcl_state_set
+ *      rtk_filter_vidrange_set
  * Description:
- *      Set state of ingress ACL.
+ *      Set VID Range check
  * Input:
- *      port    - Port id.
- *      state   - Ingress ACL state.
+ *      index 	    - index of VID Range 0-15
+ *      type        - IP Range check type, 0:Delete a entry, 1: CVID, 2: SVID
+ *      upperVid    - The upper bound of VID range
+ *      lowerVid    - The lower Bound of VID range
  * Output:
- *      None
+ *      None.
  * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_PORT_ID      - Invalid port id.
- *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
  * Note:
- *      This function gets action of packets when no ACL configruation matches.
+ *      upperVid must be larger or equal than lowerVid.
  */
-rtk_api_ret_t rtk_filter_igrAcl_state_set(rtk_port_t port, rtk_filter_state_t state)
+rtk_api_ret_t rtk_filter_vidrange_set(rtk_uint32 index, rtk_filter_vidrange_t type, rtk_uint32 upperVid, rtk_uint32 lowerVid)
 {
     rtk_api_ret_t ret;
 
-    if(port > RTL8367B_PORTIDMAX )
-        return RT_ERR_PORT_ID;
-    if(state >= RTK_ENABLE_END)
+    if(index > RTL8367B_ACLRANGEMAX)
+		return RT_ERR_OUT_OF_RANGE;
+
+    if(type >= VIDRANGE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(lowerVid > upperVid)
         return RT_ERR_INPUT;
 
-    if((ret = rtl8367b_setAsicAcl(port, state)) != RT_ERR_OK)
+    if( (upperVid > RTL8367B_VIDMAX) || (lowerVid > RTL8367B_VIDMAX))
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((ret = rtl8367b_setAsicAclVidRange(index, type, upperVid, lowerVid)) != RT_ERR_OK)
        return ret;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_igrAcl_state_get
+ *      rtk_filter_vidrange_get
  * Description:
- *      Get state of ingress ACL.
+ *      Get VID Range check
  * Input:
- *      port    - Port id.
+ *      index 	    - index of VID Range 0-15
  * Output:
- *      pState  - Ingress ACL state.
+ *      pType        - IP Range check type, 0:Unused, 1: CVID, 2: SVID
+ *      pUpperVid    - The upper bound of VID range
+ *      pLowerVid    - The lower Bound of VID range
  * Return:
- *      RT_ERR_OK           - OK
- *      RT_ERR_FAILED       - Failed
- *      RT_ERR_SMI          - SMI access error
- *      RT_ERR_PORT_ID      - Invalid port id.
- *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
  * Note:
- *      This function gets action of packets when no ACL configruation matches.
+ *      None.
  */
-rtk_api_ret_t rtk_filter_igrAcl_state_get(rtk_port_t port, rtk_filter_state_t* pState)
+rtk_api_ret_t rtk_filter_vidrange_get(rtk_uint32 index, rtk_filter_vidrange_t *pType, rtk_uint32 *pUpperVid, rtk_uint32 *pLowerVid)
 {
     rtk_api_ret_t ret;
 
-    if(port > RTL8367B_PORTIDMAX )
-        return RT_ERR_PORT_ID;
+    if(index > RTL8367B_ACLRANGEMAX)
+		return RT_ERR_OUT_OF_RANGE;
 
-    if((ret = rtl8367b_getAsicAcl(port, pState)) != RT_ERR_OK)
+    if((ret = rtl8367b_getAsicAclVidRange(index, pType, pUpperVid, pLowerVid)) != RT_ERR_OK)
        return ret;
 
     return RT_ERR_OK;
 }
+
 /* Function Name:
- *      rtk_filter_igrAcl_template_set
+ *      rtk_filter_portrange_set
  * Description:
- *      Set template of ingress ACL.
+ *      Set Port Range check
  * Input:
- *      template - Ingress ACL template
+ *      index 	    - index of Port Range 0-15
+ *      type        - IP Range check type, 0:Delete a entry, 1: Source Port, 2: Destnation Port
+ *      upperPort   - The upper bound of Port range
+ *      lowerPort   - The lower Bound of Port range
  * Output:
- *      None
+ *      None.
  * Return:
  *      RT_ERR_OK              - OK
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_INPUT           - Invalid input parameters.
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
  * Note:
- *      This function set ACL template.
+ *      upperPort must be larger or equal than lowerPort.
  */
-rtk_api_ret_t rtk_filter_igrAcl_template_set(rtk_filter_template_t *aclTemplate)
+rtk_api_ret_t rtk_filter_portrange_set(rtk_uint32 index, rtk_filter_portrange_t type, rtk_uint32 upperPort, rtk_uint32 lowerPort)
 {
     rtk_api_ret_t ret;
-    rtk_uint32 idxField;
-    rtl8367b_acltemplate_t aclType;
 
-    if(aclTemplate->index >= RTK_MAX_NUM_OF_FILTER_TYPE)
+    if(index > RTL8367B_ACLRANGEMAX)
+		return RT_ERR_OUT_OF_RANGE;
+
+    if(type >= PORTRANGE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(lowerPort > upperPort)
         return RT_ERR_INPUT;
 
-    for(idxField = 0; idxField < RTK_MAX_NUM_OF_FILTER_FIELD; idxField ++)
-    {
-        if( (aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_DMAC_15_0      || aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_CTAG) &&
-            (aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_IPV4_SIP_15_0  || aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_IPV4_DIP_31_16) &&
-            (aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_IPV6_SIP_15_0  || aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_IPV6_DIP_31_16) &&
-            (aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_VIDRANGE       || aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_PORTRANGE) &&
-            (aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_FIELD_SELECT00 || aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_FIELD_SELECT15) )
-            return RT_ERR_INPUT;
-    }
+    if(upperPort > RTL8367B_ACL_PORTRANGEMAX)
+        return RT_ERR_INPUT;
 
-    for(idxField = 0; idxField < RTK_MAX_NUM_OF_FILTER_FIELD; idxField ++)
-    {
-        aclType.field[idxField] = aclTemplate->fieldType[idxField];
-    }
+    if(lowerPort > RTL8367B_ACL_PORTRANGEMAX)
+        return RT_ERR_INPUT;
 
-    ret = rtl8367b_setAsicAclTemplate(aclTemplate->index, &aclType);
+    if((ret = rtl8367b_setAsicAclPortRange(index, type, upperPort, lowerPort)) != RT_ERR_OK)
+       return ret;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_igrAcl_template_get
+ *      rtk_filter_portrange_get
  * Description:
- *      Get template of ingress ACL.
+ *      Set Port Range check
  * Input:
- *      template - Ingress ACL template
+ *      index 	    - index of Port Range 0-15
  * Output:
- *      None
+ *      pType       - IP Range check type, 0:Delete a entry, 1: Source Port, 2: Destnation Port
+ *      pUpperPort  - The upper bound of Port range
+ *      pLowerPort  - The lower Bound of Port range
  * Return:
  *      RT_ERR_OK              - OK
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
  * Note:
- *      This function gets template of ACL.
+ *      None.
  */
-rtk_api_ret_t rtk_filter_igrAcl_template_get(rtk_filter_template_t *aclTemplate)
+rtk_api_ret_t rtk_filter_portrange_get(rtk_uint32 index, rtk_filter_portrange_t *pType, rtk_uint32 *pUpperPort, rtk_uint32 *pLowerPort)
 {
     rtk_api_ret_t ret;
-    rtk_uint32 idxField;
-    rtl8367b_acltemplate_t aclType;
 
-    if(aclTemplate->index >= RTK_MAX_NUM_OF_FILTER_TYPE)
-        return RT_ERR_INPUT;
+    if(index > RTL8367B_ACLRANGEMAX)
+		return RT_ERR_OUT_OF_RANGE;
 
-   if((ret = rtl8367b_getAsicAclTemplate(aclTemplate->index, &aclType)) != RT_ERR_OK)
+    if((ret = rtl8367b_getAsicAclPortRange(index, pType, pUpperPort, pLowerPort)) != RT_ERR_OK)
        return ret;
 
-    for(idxField = 0; idxField < RTK_MAX_NUM_OF_FILTER_FIELD; idxField ++)
-    {
-        aclTemplate->fieldType[idxField] = aclType.field[idxField];
-    }
-
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_igrAcl_field_sel_set
+ *      rtk_eee_init
  * Description:
- *      Set user defined field selectors in HSB
+ *      EEE function initialization.
  * Input:
- *      index 		- index of field selector 0-15
- *      format 		- Format of field selector
- *      offset 		- Retrieving data offset
+ *      None
  * Output:
  *      None
  * Return:
@@ -17851,899 +18212,1375 @@ rtk_api_ret_t rtk_filter_igrAcl_template
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
  * Note:
- *      System support 16 user defined field selctors.
- * 		Each selector can be enabled or disable.
- *      User can defined retrieving 16-bits in many predefiend
- * 		standard l2/l3/l4 payload.
+ *      This API is used to initialize EEE status.
  */
-rtk_api_ret_t rtk_filter_igrAcl_field_sel_set(rtk_uint32 index, rtk_field_sel_t format, rtk_uint32 offset)
+rtk_api_ret_t rtk_eee_init(void)
 {
-    rtk_api_ret_t ret;
-
-    if(index >= RTL8367B_FIELDSEL_FORMAT_NUMBER)
-        return RT_ERR_OUT_OF_RANGE;
-
-    if(format >= FORMAT_END)
-        return RT_ERR_OUT_OF_RANGE;
+    rtk_api_ret_t retVal;
 
-    if(offset > RTL8367B_FIELDSEL_MAX_OFFSET)
-        return RT_ERR_OUT_OF_RANGE;
+    if((retVal = rtl8367b_setAsicRegBit(0x0018, 10, 1)) != RT_ERR_OK)
+        return retVal;
 
-    if((ret = rtl8367b_setAsicFieldSelector(index, (rtk_uint32)format, offset)) != RT_ERR_OK)
-       return ret;
+    if((retVal = rtl8367b_setAsicRegBit(0x0018, 11, 1)) != RT_ERR_OK)
+        return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_igrAcl_field_sel_get
+ *      rtk_eee_portEnable_set
  * Description:
- *      Get user defined field selectors in HSB
+ *      Set enable status of EEE function.
  * Input:
- *      index 	    - index of field selector 0-15
+ *      port - port id.
+ *      enable - enable EEE status.
  * Output:
- *      pFormat 	- Format of field selector
- *      pOffset 	- Retrieving data offset
+ *      None
  * Return:
  *      RT_ERR_OK              - OK
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_ID - Invalid port number.
+ *      RT_ERR_ENABLE - Invalid enable input.
  * Note:
- *      None.
+ *      This API can set EEE function to the specific port.
+ *      The configuration of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
  */
-rtk_api_ret_t rtk_filter_igrAcl_field_sel_get(rtk_uint32 index, rtk_field_sel_t *pFormat, rtk_uint32 *pOffset)
+rtk_api_ret_t rtk_eee_portEnable_set(rtk_port_t port, rtk_enable_t enable)
 {
-    rtk_api_ret_t ret;
+    rtk_api_ret_t   retVal;
+    rtk_uint32      regData;
+    rtk_uint32      data;
 
-    if(index >= RTL8367B_FIELDSEL_FORMAT_NUMBER)
-        return RT_ERR_OUT_OF_RANGE;
+    if (port > RTK_PORT_ID_MAX)
+        return RT_ERR_PORT_ID;
 
-    if((ret = rtl8367b_getAsicFieldSelector(index, pFormat, pOffset)) != RT_ERR_OK)
-       return ret;
+    if (enable>=RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data)) != RT_ERR_OK)
+        return retVal;
+
+    if( (data == 0x0276) || (data == 0x0597) || (data == 0x6367) )
+    {
+        if((retVal = rtl8367b_getAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        if(enable)
+        {
+            regData |= (0x0001 << 1);
+            regData |= (0x0001 << 2);
+        }
+        else
+        {
+            regData &= ~(0x0001 << 1);
+            regData &= ~(0x0001 << 2);
+        }
+
+        if((retVal = rtl8367b_setAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, regData)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        if ((retVal = rtl8367b_setAsicEee100M(port,enable))!=RT_ERR_OK)
+            return retVal;
+        if ((retVal = rtl8367b_setAsicEeeGiga(port,enable))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367b_setAsicRegBit(RTL8367B_PORT_EEE_CFG_REG(port), RTL8367B_PORT0_EEECFG_EEE_TX_OFFSET, (enable == ENABLED) ? 1 : 0)) != RT_ERR_OK)
+            return retVal;
+        if ((retVal = rtl8367b_setAsicRegBit(RTL8367B_PORT_EEE_CFG_REG(port), RTL8367B_PORT0_EEECFG_EEE_RX_OFFSET, (enable == ENABLED) ? 1 : 0)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367b_setAsicPHYReg(port, RTL8367B_PHY_PAGE_ADDRESS, 0))!=RT_ERR_OK)
+            return retVal;
+        if ((retVal = rtl8367b_setAsicPHYReg(port, 13, 7))!=RT_ERR_OK)
+            return retVal;
+        if ((retVal = rtl8367b_setAsicPHYReg(port, 14, 60))!=RT_ERR_OK)
+            return retVal;
+        if ((retVal = rtl8367b_setAsicPHYReg(port, 13, 0x4007))!=RT_ERR_OK)
+            return retVal;
+        if ((retVal = rtl8367b_setAsicPHYReg(port, 14, (enable == ENABLED) ? 0x0006 : 0x0000))!=RT_ERR_OK)
+            return retVal;
+    }
+
+    if ((retVal = rtl8367b_setAsicPHYReg(port, RTL8367B_PHY_PAGE_ADDRESS, 0))!=RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367b_getAsicPHYReg(port, 0, &regData))!=RT_ERR_OK)
+        return retVal;
+    regData |= 0x0200;
+    if ((retVal = rtl8367b_setAsicPHYReg(port, 0, regData))!=RT_ERR_OK)
+        return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_iprange_set
+ *      rtk_eee_portEnable_get
  * Description:
- *      Set IP Range check
+ *      Get enable status of EEE function
  * Input:
- *      index 	    - index of IP Range 0-15
- *      type        - IP Range check type, 0:Delete a entry, 1: IPv4_SIP, 2: IPv4_DIP, 3:IPv6_SIP, 4:IPv6_DIP
- *      upperIp     - The upper bound of IP range
- *      lowerIp     - The lower Bound of IP range
+ *      port - Port id.
  * Output:
- *      None.
+ *      pEnable - Back pressure status.
  * Return:
  *      RT_ERR_OK              - OK
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
- *      RT_ERR_INPUT           - Input error
+ *      RT_ERR_PORT_ID - Invalid port number.
  * Note:
- *      upperIp must be larger or equal than lowerIp.
+ *      This API can get EEE function to the specific port.
+ *      The configuration of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
  */
-rtk_api_ret_t rtk_filter_iprange_set(rtk_uint32 index, rtk_filter_iprange_t type, ipaddr_t upperIp, ipaddr_t lowerIp)
+
+rtk_api_ret_t rtk_eee_portEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
 {
-    rtk_api_ret_t ret;
+    rtk_api_ret_t retVal;
+    rtk_uint32      regData, regData1, regData2;
+    rtk_uint32      data;
 
-    if(index > RTL8367B_ACLRANGEMAX)
-		return RT_ERR_OUT_OF_RANGE;
+    if (port > RTK_PORT_ID_MAX)
+        return RT_ERR_PORT_ID;
 
-    if(type >= IPRANGE_END)
-        return RT_ERR_OUT_OF_RANGE;
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
 
-    if(lowerIp > upperIp)
-        return RT_ERR_INPUT;
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data)) != RT_ERR_OK)
+        return retVal;
 
-    if((ret = rtl8367b_setAsicAclIpRange(index, type, upperIp, lowerIp)) != RT_ERR_OK)
-       return ret;
+    if( (data == 0x0276) || (data == 0x0597) || (data == 0x6367) )
+    {
+        if((retVal = rtl8367b_getAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = ((regData & 0x0006) == 0x0006) ? ENABLED : DISABLED;
+    }
+    else
+    {
+        if ((retVal = rtl8367b_getAsicEee100M(port,&regData1))!=RT_ERR_OK)
+            return retVal;
+        if ((retVal = rtl8367b_getAsicEeeGiga(port,&regData2))!=RT_ERR_OK)
+            return retVal;
+
+        if (regData1==1&&regData2==1)
+            *pEnable = ENABLED;
+        else
+            *pEnable = DISABLED;
+    }
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_iprange_get
+ *      rtk_igmp_init
  * Description:
- *      Set IP Range check
+ *      This API enables H/W IGMP and set a default initial configuration.
  * Input:
- *      index 	    - index of IP Range 0-15
+ *      None.
  * Output:
- *      pType        - IP Range check type, 0:Delete a entry, 1: IPv4_SIP, 2: IPv4_DIP, 3:IPv6_SIP, 4:IPv6_DIP
- *      pUpperIp     - The upper bound of IP range
- *      pLowerIp     - The lower Bound of IP range
+ *      None.
  * Return:
  *      RT_ERR_OK              - OK
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
  * Note:
- *      None.
+ *      This API enables H/W IGMP and set a default initial configuration.
  */
-rtk_api_ret_t rtk_filter_iprange_get(rtk_uint32 index, rtk_filter_iprange_t *pType, ipaddr_t *pUpperIp, ipaddr_t *pLowerIp)
+rtk_api_ret_t rtk_igmp_init(void)
 {
-    rtk_api_ret_t ret;
+    rtk_api_ret_t retVal;
+    rtk_port_t port;
 
-    if(index > RTL8367B_ACLRANGEMAX)
-		return RT_ERR_OUT_OF_RANGE;
+    if ((retVal = rtl8367b_setAsicLutIpMulticastLookup(ENABLED))!=RT_ERR_OK)
+        return retVal;
 
-    if((ret = rtl8367b_getAsicAclIpRange(index, pType, pUpperIp, pLowerIp)) != RT_ERR_OK)
-       return ret;
+    if ((retVal = rtl8367b_setAsicLutIpLookupMethod(1))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367b_setAsicIgmp(ENABLED))!=RT_ERR_OK)
+        return retVal;
+
+    for(port = 0; port <= RTK_PORT_ID_MAX; port++)
+    {
+        if ((retVal = rtl8367b_setAsicIGMPv1Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
+        return retVal;
+
+        if ((retVal = rtl8367b_setAsicIGMPv2Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367b_setAsicIGMPv3Opeartion(port, PROTOCOL_OP_FLOOD))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367b_setAsicMLDv1Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367b_setAsicMLDv2Opeartion(port, PROTOCOL_OP_FLOOD))!=RT_ERR_OK)
+            return retVal;
+    }
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_vidrange_set
+ *      rtk_igmp_state_set
  * Description:
- *      Set VID Range check
- * Input:
- *      index 	    - index of VID Range 0-15
- *      type        - IP Range check type, 0:Delete a entry, 1: CVID, 2: SVID
- *      upperVid    - The upper bound of VID range
- *      lowerVid    - The lower Bound of VID range
+ *      This API set H/W IGMP state.
+ * Input:
+ *      enabled     - H/W IGMP state
  * Output:
  *      None.
  * Return:
  *      RT_ERR_OK              - OK
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
- *      RT_ERR_INPUT           - Input error
+ *      RT_ERR_INPUT           - Error parameter
  * Note:
- *      upperVid must be larger or equal than lowerVid.
+ *      This API set H/W IGMP state.
  */
-rtk_api_ret_t rtk_filter_vidrange_set(rtk_uint32 index, rtk_filter_vidrange_t type, rtk_uint32 upperVid, rtk_uint32 lowerVid)
+rtk_api_ret_t rtk_igmp_state_set(rtk_enable_t enabled)
 {
-    rtk_api_ret_t ret;
-
-    if(index > RTL8367B_ACLRANGEMAX)
-		return RT_ERR_OUT_OF_RANGE;
-
-    if(type >= VIDRANGE_END)
-        return RT_ERR_OUT_OF_RANGE;
+    rtk_api_ret_t retVal;
 
-    if(lowerVid > upperVid)
+    if (enabled >= RTK_ENABLE_END)
         return RT_ERR_INPUT;
 
-    if( (upperVid > RTL8367B_VIDMAX) || (lowerVid > RTL8367B_VIDMAX))
-        return RT_ERR_OUT_OF_RANGE;
-
-    if((ret = rtl8367b_setAsicAclVidRange(index, type, upperVid, lowerVid)) != RT_ERR_OK)
-       return ret;
+    if ((retVal = rtl8367b_setAsicIgmp(enabled))!=RT_ERR_OK)
+        return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_vidrange_get
+ *      rtk_igmp_state_get
  * Description:
- *      Get VID Range check
+ *      This API get H/W IGMP state.
  * Input:
- *      index 	    - index of VID Range 0-15
+ *      None.
  * Output:
- *      pType        - IP Range check type, 0:Unused, 1: CVID, 2: SVID
- *      pUpperVid    - The upper bound of VID range
- *      pLowerVid    - The lower Bound of VID range
+ *      pEnabled        - H/W IGMP state
  * Return:
  *      RT_ERR_OK              - OK
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Error parameter
  * Note:
- *      None.
+ *      This API set current H/W IGMP state.
  */
-rtk_api_ret_t rtk_filter_vidrange_get(rtk_uint32 index, rtk_filter_vidrange_t *pType, rtk_uint32 *pUpperVid, rtk_uint32 *pLowerVid)
+rtk_api_ret_t rtk_igmp_state_get(rtk_enable_t *pEnabled)
 {
-    rtk_api_ret_t ret;
-
-    if(index > RTL8367B_ACLRANGEMAX)
-		return RT_ERR_OUT_OF_RANGE;
+    rtk_api_ret_t retVal;
 
-    if((ret = rtl8367b_getAsicAclVidRange(index, pType, pUpperVid, pLowerVid)) != RT_ERR_OK)
-       return ret;
+    if ((retVal = rtl8367b_getAsicIgmp(pEnabled))!=RT_ERR_OK)
+        return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_portrange_set
+ *      rtk_igmp_static_router_port_set
  * Description:
- *      Set Port Range check
+ *      Configure static router port
  * Input:
- *      index 	    - index of Port Range 0-15
- *      type        - IP Range check type, 0:Delete a entry, 1: Source Port, 2: Destnation Port
- *      upperPort   - The upper bound of Port range
- *      lowerPort   - The lower Bound of Port range
+ *      portmask    - Static Port mask
  * Output:
  *      None.
  * Return:
  *      RT_ERR_OK              - OK
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
- *      RT_ERR_INPUT           - Input error
+ *      RT_ERR_PORT_MASK       - Error parameter
  * Note:
- *      upperPort must be larger or equal than lowerPort.
+ *      This API set static router port
  */
-rtk_api_ret_t rtk_filter_portrange_set(rtk_uint32 index, rtk_filter_portrange_t type, rtk_uint32 upperPort, rtk_uint32 lowerPort)
+rtk_api_ret_t rtk_igmp_static_router_port_set(rtk_portmask_t portmask)
 {
-    rtk_api_ret_t ret;
-
-    if(index > RTL8367B_ACLRANGEMAX)
-		return RT_ERR_OUT_OF_RANGE;
-
-    if(type >= PORTRANGE_END)
-        return RT_ERR_OUT_OF_RANGE;
-
-    if(lowerPort > upperPort)
-        return RT_ERR_INPUT;
-
-    if(upperPort > RTL8367B_ACL_PORTRANGEMAX)
-        return RT_ERR_INPUT;
+    rtk_api_ret_t retVal;
 
-    if(lowerPort > RTL8367B_ACL_PORTRANGEMAX)
-        return RT_ERR_INPUT;
+    if ( portmask.bits[0] > RTK_MAX_PORT_MASK)
+        return RT_ERR_PORT_MASK;
 
-    if((ret = rtl8367b_setAsicAclPortRange(index, type, upperPort, lowerPort)) != RT_ERR_OK)
-       return ret;
+    if ((retVal = rtl8367b_setAsicIGMPStaticRouterPort(portmask.bits[0]))!=RT_ERR_OK)
+        return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_filter_portrange_get
+ *      rtk_igmp_static_router_port_get
  * Description:
- *      Set Port Range check
+ *      Get static router port
  * Input:
- *      index 	    - index of Port Range 0-15
+ *      None.
  * Output:
- *      pType       - IP Range check type, 0:Delete a entry, 1: Source Port, 2: Destnation Port
- *      pUpperPort  - The upper bound of Port range
- *      pLowerPort  - The lower Bound of Port range
+ *      pPortmask       - Static port mask
  * Return:
  *      RT_ERR_OK              - OK
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
- *      RT_ERR_INPUT           - Input error
+ *      RT_ERR_PORT_MASK       - Error parameter
  * Note:
- *      None.
+ *      This API get static router port
  */
-rtk_api_ret_t rtk_filter_portrange_get(rtk_uint32 index, rtk_filter_portrange_t *pType, rtk_uint32 *pUpperPort, rtk_uint32 *pLowerPort)
+rtk_api_ret_t rtk_igmp_static_router_port_get(rtk_portmask_t *pPortmask)
 {
-    rtk_api_ret_t ret;
-
-    if(index > RTL8367B_ACLRANGEMAX)
-		return RT_ERR_OUT_OF_RANGE;
+    rtk_api_ret_t retVal;
 
-    if((ret = rtl8367b_getAsicAclPortRange(index, pType, pUpperPort, pLowerPort)) != RT_ERR_OK)
-       return ret;
+    if ((retVal = rtl8367b_getAsicIGMPStaticRouterPort(&pPortmask->bits[0]))!=RT_ERR_OK)
+        return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_eee_init
+ *      rtk_igmp_protocol_set
  * Description:
- *      EEE function initialization.
+ *      set IGMP/MLD protocol action
  * Input:
- *      None
+ *      port        - Port ID
+ *      protocol    - IGMP/MLD protocol
+ *      action      - Per-port and per-protocol IGMP action seeting
  * Output:
- *      None
+ *      None.
  * Return:
  *      RT_ERR_OK              - OK
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
  * Note:
- *      This API is used to initialize EEE status.
+ *      This API set IGMP/MLD protocol action
  */
-rtk_api_ret_t rtk_eee_init(void)
+rtk_api_ret_t rtk_igmp_protocol_set(rtk_port_t port, rtk_igmp_protocol_t protocol, rtk_trap_igmp_action_t action)
 {
-    rtk_api_ret_t retVal;
+    rtk_uint32      operation;
+    rtk_api_ret_t   retVal;
 
-    if((retVal = rtl8367b_setAsicRegBit(0x0018, 10, 1)) != RT_ERR_OK)
-        return retVal;
+    if (port > RTK_PORT_ID_MAX)
+        return RT_ERR_PORT_ID;
 
-    if((retVal = rtl8367b_setAsicRegBit(0x0018, 11, 1)) != RT_ERR_OK)
-        return retVal;
+    if(protocol >= PROTOCOL_END)
+        return RT_ERR_INPUT;
+
+    if((action >= IGMP_ACTION_END) || (action == IGMP_ACTION_FORWARD_EXCLUDE_CPU))
+        return RT_ERR_INPUT;
+
+    switch(action)
+    {
+        case IGMP_ACTION_FORWARD:
+            operation = PROTOCOL_OP_FLOOD;
+            break;
+        case IGMP_ACTION_TRAP2CPU:
+            operation = PROTOCOL_OP_TRAP;
+            break;
+        case IGMP_ACTION_DROP:
+            operation = PROTOCOL_OP_DROP;
+            break;
+        case IGMP_ACTION_ASIC:
+            if( (protocol == PROTOCOL_IGMPv3) || (protocol == PROTOCOL_MLDv2) )
+                return RT_ERR_CHIP_NOT_SUPPORTED;
+            else
+            operation = PROTOCOL_OP_ASIC;
+            break;
+        default:
+            return RT_ERR_INPUT;
+    }
+
+    switch(protocol)
+    {
+        case PROTOCOL_IGMPv1:
+            if ((retVal = rtl8367b_setAsicIGMPv1Opeartion(port, operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_IGMPv2:
+            if ((retVal = rtl8367b_setAsicIGMPv2Opeartion(port, operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_IGMPv3:
+            if ((retVal = rtl8367b_setAsicIGMPv3Opeartion(port, operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_MLDv1:
+            if ((retVal = rtl8367b_setAsicMLDv1Opeartion(port, operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_MLDv2:
+            if ((retVal = rtl8367b_setAsicMLDv2Opeartion(port, operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        default:
+            return RT_ERR_INPUT;
+
+    }
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_eee_portEnable_set
+ *      rtk_igmp_protocol_get
  * Description:
- *      Set enable status of EEE function.
+ *      set IGMP/MLD protocol action
  * Input:
- *      port - port id.
- *      enable - enable EEE status.
+ *      port        - Port ID
+ *      protocol    - IGMP/MLD protocol
+ *      action      - Per-port and per-protocol IGMP action seeting
  * Output:
- *      None
+ *      None.
  * Return:
  *      RT_ERR_OK              - OK
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_PORT_ID - Invalid port number.
- *      RT_ERR_ENABLE - Invalid enable input.
+ *      RT_ERR_PORT_MASK       - Error parameter
  * Note:
- *      This API can set EEE function to the specific port.
- *      The configuration of the port is as following:
- *      - DISABLE
- *      - ENABLE
+ *      This API set IGMP/MLD protocol action
  */
-rtk_api_ret_t rtk_eee_portEnable_set(rtk_port_t port, rtk_enable_t enable)
+rtk_api_ret_t rtk_igmp_protocol_get(rtk_port_t port, rtk_igmp_protocol_t protocol, rtk_trap_igmp_action_t *pAction)
 {
+    rtk_uint32      operation;
     rtk_api_ret_t   retVal;
-    rtk_uint32      regData;
 
     if (port > RTK_PORT_ID_MAX)
         return RT_ERR_PORT_ID;
 
-    if (enable>=RTK_ENABLE_END)
+    if(protocol >= PROTOCOL_END)
         return RT_ERR_INPUT;
 
-    if ((retVal = rtl8367b_setAsicEee100M(port,enable))!=RT_ERR_OK)
-        return retVal;
-    if ((retVal = rtl8367b_setAsicEeeGiga(port,enable))!=RT_ERR_OK)
-        return retVal;
+    switch(protocol)
+    {
+        case PROTOCOL_IGMPv1:
+            if ((retVal = rtl8367b_getAsicIGMPv1Opeartion(port, &operation))!=RT_ERR_OK)
+                return retVal;
 
-    if ((retVal = rtl8367b_setAsicRegBit(RTL8367B_PORT_EEE_CFG_REG(port), RTL8367B_PORT0_EEECFG_EEE_TX_OFFSET, (enable == ENABLED) ? 1 : 0)) != RT_ERR_OK)
-        return retVal;
-    if ((retVal = rtl8367b_setAsicRegBit(RTL8367B_PORT_EEE_CFG_REG(port), RTL8367B_PORT0_EEECFG_EEE_RX_OFFSET, (enable == ENABLED) ? 1 : 0)) != RT_ERR_OK)
-        return retVal;
+            break;
+        case PROTOCOL_IGMPv2:
+            if ((retVal = rtl8367b_getAsicIGMPv2Opeartion(port, &operation))!=RT_ERR_OK)
+                return retVal;
 
-    if ((retVal = rtl8367b_setAsicPHYReg(port, RTL8367B_PHY_PAGE_ADDRESS, 7))!=RT_ERR_OK)
-        return retVal;
-    if ((retVal = rtl8367b_setAsicPHYReg(port, 30, 32))!=RT_ERR_OK)
-        return retVal;
-    if ((retVal = rtl8367b_setAsicPHYReg(port, 21, (enable == ENABLED) ? 0x0100 : 0x0000))!=RT_ERR_OK)
-        return retVal;
+            break;
+        case PROTOCOL_IGMPv3:
+            if ((retVal = rtl8367b_getAsicIGMPv3Opeartion(port, &operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_MLDv1:
+            if ((retVal = rtl8367b_getAsicMLDv1Opeartion(port, &operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_MLDv2:
+            if ((retVal = rtl8367b_getAsicMLDv2Opeartion(port, &operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        default:
+            return RT_ERR_INPUT;
 
-    if ((retVal = rtl8367b_setAsicPHYReg(port, RTL8367B_PHY_PAGE_ADDRESS, 0))!=RT_ERR_OK)
-        return retVal;
-    if ((retVal = rtl8367b_getAsicPHYReg(port, 0, &regData))!=RT_ERR_OK)
-        return retVal;
-    regData |= 0x0200;
-    if ((retVal = rtl8367b_setAsicPHYReg(port, 0, regData))!=RT_ERR_OK)
-        return retVal;
+    }
+
+    switch(operation)
+    {
+        case PROTOCOL_OP_FLOOD:
+            *pAction = IGMP_ACTION_FORWARD;
+            break;
+        case PROTOCOL_OP_TRAP:
+            *pAction = IGMP_ACTION_TRAP2CPU;
+            break;
+        case PROTOCOL_OP_DROP:
+            *pAction = IGMP_ACTION_DROP;
+            break;
+        case PROTOCOL_OP_ASIC:
+            *pAction = IGMP_ACTION_ASIC;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_eee_portEnable_get
+ *      rtk_igmp_fastLeave_set
  * Description:
- *      Get enable status of EEE function
+ *      set IGMP/MLD FastLeave state
  * Input:
- *      port - Port id.
+ *      state       - ENABLED: Enable FastLeave, DISABLED: disable FastLeave
  * Output:
- *      pEnable - Back pressure status.
+ *      None.
  * Return:
  *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_PORT_ID - Invalid port number.
  * Note:
- *      This API can get EEE function to the specific port.
- *      The configuration of the port is as following:
- *      - DISABLE
- *      - ENABLE
+ *      This API set IGMP/MLD FastLeave state
  */
-
-rtk_api_ret_t rtk_eee_portEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+rtk_api_ret_t rtk_igmp_fastLeave_set(rtk_enable_t state)
 {
-    rtk_api_ret_t retVal;
-    rtk_uint32 regData1, regData2;
+    rtk_api_ret_t   retVal;
 
-    if (port > RTK_PORT_ID_MAX)
-        return RT_ERR_PORT_ID;
+    if(state >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
 
-    if ((retVal = rtl8367b_getAsicEee100M(port,&regData1))!=RT_ERR_OK)
-        return retVal;
-    if ((retVal = rtl8367b_getAsicEeeGiga(port,&regData2))!=RT_ERR_OK)
+    if ((retVal = rtl8367b_setAsicIGMPFastLeaveEn((rtk_uint32)state))!=RT_ERR_OK)
         return retVal;
 
-    if (regData1==1&&regData2==1)
-        *pEnable = ENABLED;
-    else
-        *pEnable = DISABLED;
-
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_igmp_init
+ *      rtk_igmp_fastLeave_get
  * Description:
- *      This API enables H/W IGMP and set a default initial configuration.
+ *      get IGMP/MLD FastLeave state
  * Input:
- *      None.
+ *      None
  * Output:
- *      None.
+ *      pState      - ENABLED: Enable FastLeave, DISABLED: disable FastLeave
  * Return:
  *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - NULL pointer
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
  * Note:
- *      This API enables H/W IGMP and set a default initial configuration.
+ *      This API get IGMP/MLD FastLeave state
  */
-rtk_api_ret_t rtk_igmp_init(void)
+rtk_api_ret_t rtk_igmp_fastLeave_get(rtk_enable_t *pState)
 {
-    rtk_api_ret_t retVal;
-    rtk_port_t port;
-
-    if ((retVal = rtl8367b_setAsicLutIpMulticastLookup(ENABLED))!=RT_ERR_OK)
-        return retVal;
-
-    if ((retVal = rtl8367b_setAsicLutIpLookupMethod(1))!=RT_ERR_OK)
-        return retVal;
+    rtk_uint32      fast_leave;
+    rtk_api_ret_t   retVal;
 
-    if ((retVal = rtl8367b_setAsicIgmp(ENABLED))!=RT_ERR_OK)
-        return retVal;
+    if(pState == NULL)
+        return RT_ERR_NULL_POINTER;
 
-    for(port = 0; port <= RTK_PORT_ID_MAX; port++)
-    {
-        if ((retVal = rtl8367b_setAsicIGMPv1Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
+    if ((retVal = rtl8367b_getAsicIGMPFastLeaveEn(&fast_leave))!=RT_ERR_OK)
         return retVal;
 
-        if ((retVal = rtl8367b_setAsicIGMPv2Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
-            return retVal;
-
-        if ((retVal = rtl8367b_setAsicIGMPv3Opeartion(port, PROTOCOL_OP_FLOOD))!=RT_ERR_OK)
-            return retVal;
-
-        if ((retVal = rtl8367b_setAsicMLDv1Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
-            return retVal;
-
-        if ((retVal = rtl8367b_setAsicMLDv2Opeartion(port, PROTOCOL_OP_FLOOD))!=RT_ERR_OK)
-            return retVal;
-    }
-
+    *pState = ((fast_leave == 1) ? ENABLED : DISABLED);
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_igmp_state_set
+ *      rtk_igmp_maxGroup_set
  * Description:
- *      This API set H/W IGMP state.
+ *      Set per port multicast group learning limit.
  * Input:
- *      enabled     - H/W IGMP state
+ *      port        - Port ID
+ *      group       - The number of multicast group learning limit.
  * Output:
  *      None.
  * Return:
  *      RT_ERR_OK              - OK
+ *      RT_ERR_PORT_ID         - Error Port ID
+ *      RT_ERR_OUT_OF_RANGE    - parameter out of range
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_INPUT           - Error parameter
  * Note:
- *      This API set H/W IGMP state.
+ *      This API set per port multicast group learning limit.
  */
-rtk_api_ret_t rtk_igmp_state_set(rtk_enable_t enabled)
+rtk_api_ret_t rtk_igmp_maxGroup_set(rtk_port_t port, rtk_uint32 group)
 {
-    rtk_api_ret_t retVal;
+    rtk_api_ret_t   retVal;
 
-    if (enabled >= RTK_ENABLE_END)
-        return RT_ERR_INPUT;
+    if (port > RTK_PORT_ID_MAX)
+        return RT_ERR_PORT_ID;
 
-    if ((retVal = rtl8367b_setAsicIgmp(enabled))!=RT_ERR_OK)
+    if(group > RTL8367B_IGMP_MAX_GOUP)
+		return RT_ERR_OUT_OF_RANGE;
+
+    if ((retVal = rtl8367b_setAsicIGMPPortMAXGroup(port, group))!=RT_ERR_OK)
         return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_igmp_state_get
+ *      rtk_igmp_maxGroup_get
  * Description:
- *      This API get H/W IGMP state.
+ *      Get per port multicast group learning limit.
  * Input:
- *      None.
+ *      port        - Port ID
  * Output:
- *      pEnabled        - H/W IGMP state
+ *      pGroup      - The number of multicast group learning limit.
  * Return:
  *      RT_ERR_OK              - OK
+ *      RT_ERR_PORT_ID         - Error Port ID
+ *      RT_ERR_NULL_POINTER    - Null pointer
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_INPUT           - Error parameter
  * Note:
- *      This API set current H/W IGMP state.
+ *      This API get per port multicast group learning limit.
  */
-rtk_api_ret_t rtk_igmp_state_get(rtk_enable_t *pEnabled)
+rtk_api_ret_t rtk_igmp_maxGroup_get(rtk_port_t port, rtk_uint32 *pGroup)
 {
-    rtk_api_ret_t retVal;
+    rtk_api_ret_t   retVal;
 
-    if ((retVal = rtl8367b_getAsicIgmp(pEnabled))!=RT_ERR_OK)
+    if (port > RTK_PORT_ID_MAX)
+        return RT_ERR_PORT_ID;
+
+    if(pGroup == NULL)
+		return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367b_getAsicIGMPPortMAXGroup(port, pGroup))!=RT_ERR_OK)
         return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_igmp_static_router_port_set
+ *      rtk_igmp_currentGroup_get
  * Description:
- *      Configure static router port
+ *      Get per port multicast group learning count.
  * Input:
- *      portmask    - Static Port mask
+ *      port        - Port ID
  * Output:
- *      None.
+ *      pGroup      - The number of multicast group learning count.
  * Return:
  *      RT_ERR_OK              - OK
+ *      RT_ERR_PORT_ID         - Error Port ID
+ *      RT_ERR_NULL_POINTER    - Null pointer
  *      RT_ERR_FAILED          - Failed
  *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_PORT_MASK       - Error parameter
  * Note:
- *      This API set static router port
+ *      This API get per port multicast group learning count.
  */
-rtk_api_ret_t rtk_igmp_static_router_port_set(rtk_portmask_t portmask)
+rtk_api_ret_t rtk_igmp_currentGroup_get(rtk_port_t port, rtk_uint32 *pGroup)
 {
-    rtk_api_ret_t retVal;
+    rtk_api_ret_t   retVal;
 
-    if ( portmask.bits[0] > RTK_MAX_PORT_MASK)
-        return RT_ERR_PORT_MASK;
+    if (port > RTK_PORT_ID_MAX)
+        return RT_ERR_PORT_ID;
 
-    if ((retVal = rtl8367b_setAsicIGMPStaticRouterPort(portmask.bits[0]))!=RT_ERR_OK)
+    if(pGroup == NULL)
+		return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367b_getAsicIGMPPortCurrentGroup(port, pGroup))!=RT_ERR_OK)
         return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_igmp_static_router_port_get
+ *      rtk_port_phyTestMode_set
  * Description:
- *      Get static router port
+ *      Set PHY in test mode.
  * Input:
- *      None.
+ *      port - port id.
+ *      mode - PHY test mode 0:normal 1:test mode 1 2:test mode 2 3: test mode 3 4:test mode 4 5~7:reserved
  * Output:
- *      pPortmask       - Static port mask
+ *      None
  * Return:
- *      RT_ERR_OK              - OK
- *      RT_ERR_FAILED          - Failed
- *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_PORT_MASK       - Error parameter
+ *      RT_ERR_OK              	- OK
+ *      RT_ERR_FAILED          	- Failed
+ *      RT_ERR_SMI             	- SMI access error
+ *      RT_ERR_PORT_ID 			- Invalid port number.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ *      RT_ERR_NOT_ALLOWED      - The Setting is not allowed, caused by set more than 1 port in Test mode.
  * Note:
- *      This API get static router port
+ *      Set PHY in test mode and only one PHY can be in test mode at the same time.
+ *      It means API will return FAILED if other PHY is in test mode.
+ *      This API only provide test mode 1 & 4 setup, and if users want other test modes,
+ *      please contact realtek FAE.
  */
-rtk_api_ret_t rtk_igmp_static_router_port_get(rtk_portmask_t *pPortmask)
+rtk_api_ret_t rtk_port_phyTestMode_set(rtk_port_t port, rtk_port_phy_test_mode_t mode)
 {
-    rtk_api_ret_t retVal;
+    rtk_uint32          data, i, index, phy, reg;
+    rtk_api_ret_t       retVal;
+    CONST_T rtk_uint16 ParaTM_1[][2] = { {0x205F,0x0002}, {0x2053,0xAA00}, {0x2054,0xAA00}, {0x2055,0xAA00},
+                                         {0x2056,0xAA00}, {0x2057,0xAA00}, {0x205F,0x0002} };
 
-    if ((retVal = rtl8367b_getAsicIGMPStaticRouterPort(&pPortmask->bits[0]))!=RT_ERR_OK)
+    if (port > RTK_PHY_ID_MAX)
+        return RT_ERR_PORT_ID;
+
+    if ( (mode == PHY_TEST_MODE_2) || (mode == PHY_TEST_MODE_3) )
+        return RT_ERR_FAILED;
+
+    if (PHY_TEST_MODE_NORMAL != mode)
+    {
+        /* Other port should be Normal mode */
+        for(i = 0; i <= RTK_PHY_ID_MAX; i++)
+        {
+            if(i != port)
+            {
+                if ((retVal = rtl8367b_setAsicPHYReg(i, 31, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367b_getAsicPHYReg(i, 9, &data)) != RT_ERR_OK)
+                    return retVal;
+
+                if((data & 0xE000) != 0)
+                    return RT_ERR_NOT_ALLOWED;
+            }
+        }
+    }
+
+    if (PHY_TEST_MODE_1 == mode)
+    {
+        for (index = 0; index < (sizeof(ParaTM_1) / ((sizeof(rtk_uint16))*2)); index++)
+        {
+            phy = (ParaTM_1[index][0] - 0x2000) / 0x0020;
+            reg = (ParaTM_1[index][0] - 0x2000) % 0x0020;
+            if ((retVal = rtl8367b_setAsicPHYReg(phy, reg, ParaTM_1[index][1])) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+
+    if ((retVal = rtl8367b_setAsicPHYReg(port, 31, 0)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367b_getAsicPHYReg(port, 9, &data)) != RT_ERR_OK)
+        return retVal;
+
+    data &= ~0xE000;
+    data |= (mode << 13);
+    if ((retVal = rtl8367b_setAsicPHYReg(port, 9, data)) != RT_ERR_OK)
         return retVal;
 
     return RT_ERR_OK;
 }
 
 /* Function Name:
- *      rtk_igmp_protocol_set
+ *      rtk_port_phyTestMode_get
  * Description:
- *      set IGMP/MLD protocol action
+ *      Get PHY in which test mode.
  * Input:
- *      port        - Port ID
- *      protocol    - IGMP/MLD protocol
- *      action      - Per-port and per-protocol IGMP action seeting
+ *      port - Port id.
  * Output:
- *      None.
+ *      mode - PHY test mode 0:normal 1:test mode 1 2:test mode 2 3: test mode 3 4:test mode 4 5~7:reserved
  * Return:
- *      RT_ERR_OK              - OK
- *      RT_ERR_FAILED          - Failed
- *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_PORT_MASK       - Error parameter
+ *      RT_ERR_OK              	- OK
+ *      RT_ERR_FAILED          	- Failed
+ *      RT_ERR_SMI             	- SMI access error
+ *      RT_ERR_PORT_ID 			- Invalid port number.
+ *      RT_ERR_INPUT 			- Invalid input parameters.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
  * Note:
- *      This API set IGMP/MLD protocol action
+ *      Get test mode of PHY from register setting 9.15 to 9.13.
  */
-rtk_api_ret_t rtk_igmp_protocol_set(rtk_port_t port, rtk_igmp_protocol_t protocol, rtk_trap_igmp_action_t action)
+rtk_api_ret_t rtk_port_phyTestMode_get(rtk_port_t port, rtk_port_phy_test_mode_t *pMode)
 {
-    rtk_uint32      operation;
+    rtk_uint32      data;
     rtk_api_ret_t   retVal;
 
-    if (port > RTK_PORT_ID_MAX)
+    if (port > RTK_PHY_ID_MAX)
         return RT_ERR_PORT_ID;
 
-    if(protocol >= PROTOCOL_END)
-        return RT_ERR_INPUT;
+    if ((retVal = rtl8367b_setAsicPHYReg(port, 31, 0)) != RT_ERR_OK)
+        return retVal;
 
-    if((action >= IGMP_ACTION_END) || (action == IGMP_ACTION_FORWARD_EXCLUDE_CPU))
-        return RT_ERR_INPUT;
+    if ((retVal = rtl8367b_getAsicPHYReg(port, 9, &data)) != RT_ERR_OK)
+        return retVal;
 
-    switch(action)
-    {
-        case IGMP_ACTION_FORWARD:
-            operation = PROTOCOL_OP_FLOOD;
-            break;
-        case IGMP_ACTION_TRAP2CPU:
-            operation = PROTOCOL_OP_TRAP;
-            break;
-        case IGMP_ACTION_DROP:
-            operation = PROTOCOL_OP_DROP;
-            break;
-        case IGMP_ACTION_ASIC:
-            if( (protocol == PROTOCOL_IGMPv3) || (protocol == PROTOCOL_MLDv2) )
-                return RT_ERR_CHIP_NOT_SUPPORTED;
-            else
-            operation = PROTOCOL_OP_ASIC;
-            break;
-        default:
-            return RT_ERR_INPUT;
-    }
+    *pMode = (data & 0xE000) >> 13;
 
-    switch(protocol)
-    {
-        case PROTOCOL_IGMPv1:
-            if ((retVal = rtl8367b_setAsicIGMPv1Opeartion(port, operation))!=RT_ERR_OK)
-                return retVal;
+    return RT_ERR_OK;
+}
 
-            break;
-        case PROTOCOL_IGMPv2:
-            if ((retVal = rtl8367b_setAsicIGMPv2Opeartion(port, operation))!=RT_ERR_OK)
-                return retVal;
+#define REG1301_8367R_VB				0x1010
+#define REG1301_8367RB					0x1000
 
-            break;
-        case PROTOCOL_IGMPv3:
-            if ((retVal = rtl8367b_setAsicIGMPv3Opeartion(port, operation))!=RT_ERR_OK)
-                return retVal;
+#define CONFIG_LAN_WAN_ISOLATION 1
+#define CONFIG_RTK_REFINE_PORT_DUPLEX_MODE 1
 
-            break;
-        case PROTOCOL_MLDv1:
-            if ((retVal = rtl8367b_setAsicMLDv1Opeartion(port, operation))!=RT_ERR_OK)
-                return retVal;
+#define RTL8367RB_USE_ONE_LED_PER_PORT		1
 
-            break;
-        case PROTOCOL_MLDv2:
-            if ((retVal = rtl8367b_setAsicMLDv2Opeartion(port, operation))!=RT_ERR_OK)
-                return retVal;
+#define ENABLE_8367RB_RGMII2	1
 
-            break;
-        default:
-            return RT_ERR_INPUT;
+#ifdef ENABLE_8367RB_RGMII2
+// for tr181
+int rtk_rgmii_set(int enable)
+{
+    rtk_port_mac_ability_t mac_cfg;
+
+    mac_cfg.forcemode = MAC_FORCE;
+    mac_cfg.speed = SPD_1000M;
+    mac_cfg.duplex = FULL_DUPLEX;
+    if (enable == TRUE)
+        mac_cfg.link = PORT_LINKUP;
+    else		
+        mac_cfg.link = PORT_LINKDOWN;
+    mac_cfg.nway = DISABLED;
+    mac_cfg.txpause = ENABLED;
+    mac_cfg.rxpause = ENABLED;
+    rtk_port_macForceLinkExt_set(EXT_PORT_2, MODE_EXT_RGMII, &mac_cfg);
+
+    return 0;
+}
+#endif
+
+int RTL8367R_init(void)
+{
+    rtk_portmask_t portmask;
+    unsigned int ret;
+    //unsigned int regData;
+
+    /* Set external interface 0 to RGMII with Force mode, 1000M, Full-duple, enable TX&RX pause*/
+    rtk_port_mac_ability_t mac_cfg;
+    rtk_mode_ext_t mode ;
+ 
+    /* Initial Chip */
+    ret = rtk_switch_init();
+ 
+    /* Enable LED Group 0&1 from P0 to P4 */
+    portmask.bits[0]=0x1F;
+    rtk_led_enable_set(LED_GROUP_0, portmask);
+    rtk_led_enable_set(LED_GROUP_1, portmask);
+ 
+    mode = MODE_EXT_RGMII ;
+    mac_cfg.forcemode = MAC_FORCE;
+    mac_cfg.speed = SPD_1000M;
+    mac_cfg.duplex = FULL_DUPLEX;
+    mac_cfg.link = PORT_LINKUP;
+    mac_cfg.nway = DISABLED;
+    mac_cfg.txpause = ENABLED;
+    mac_cfg.rxpause = ENABLED;
+    rtk_port_macForceLinkExt_set(EXT_PORT_1,mode,&mac_cfg);
+ 
+#ifdef ENABLE_8367RB_RGMII2
+    mode = MODE_EXT_RGMII ;
+    mac_cfg.forcemode = MAC_FORCE;
+    mac_cfg.speed = SPD_1000M;
+    mac_cfg.duplex = FULL_DUPLEX;
+    mac_cfg.link = PORT_LINKUP;
+    mac_cfg.nway = DISABLED;
+    mac_cfg.txpause = ENABLED;
+    mac_cfg.rxpause = ENABLED;
+    rtk_port_macForceLinkExt_set(EXT_PORT_2,mode,&mac_cfg);
+#endif
 
+    /* Set RGMII Interface 0 TX delay to 2ns and RX to step 4 */
+    // set the tx/rx delay in 8197D site
+    //rtk_port_rgmiiDelayExt_set(EXT_PORT_1, 1, 4);
+    //rtk_port_rgmiiDelayExt_set(EXT_PORT_1, 0, 0);
+    rtk_port_rgmiiDelayExt_set(EXT_PORT_1, 0, 2); // change rxDelay to 2 to enhance the compatibility of 8197D and 8367RB
+ 
+    /* set port 5 as CPU port */
+    rtk_cpu_enable_set(ENABLE);
+    rtk_cpu_tagPort_set(RTK_EXT_1_MAC, CPU_INSERT_TO_NONE);
+ 
+    // for LED on Realtek 8197D+8367RB
+    if (r8367_cpu_port == RTL8367B_PORT6_ENABLE_OFFSET) {    // 8367RB
+#ifdef RTL8367RB_USE_ONE_LED_PER_PORT
+        rtl8367b_setAsicReg(0x1B03, 0x0222);
+#else
+        /* demo board use 2 LEDs for each port */	
+        rtl8367b_setAsicReg(0x1B03, 0x0936);
+#endif
     }
 
-    return RT_ERR_OK;
+#if 1
+    // for 802.11ac logo 4.2.40 test (udp test item)
+    rtl8367b_setAsicReg(0x121f, 0x01D6);
+    rtl8367b_setAsicReg(0x1220, 0x01B8);
+    rtl8367b_setAsicReg(0x1221, 0x01CC);
+    rtl8367b_setAsicReg(0x1222, 0x01AE);
+    rtl8367b_setAsicReg(0x1223, 0x0302);
+    rtl8367b_setAsicReg(0x1224, 0x02E4);
+    rtl8367b_setAsicReg(0x1225, 0x02D0);
+    rtl8367b_setAsicReg(0x1226, 0x02A8);	
+#endif
+
+#if defined(CONFIG_RTK_REFINE_PORT_DUPLEX_MODE)
+	rtk_forceFull_init();
+#endif
+
+#if defined(CONFIG_LAN_WAN_ISOLATION)
+	{
+	rtk_portmask_t pm;
+	
+	pm.bits[0] = 0xff;
+	rtk_port_isolation_set(0, pm);
+	rtk_port_isolation_set(1, pm);
+	rtk_port_isolation_set(2, pm);
+	rtk_port_isolation_set(3, pm);
+	rtk_port_isolation_set(4, pm);
+	}
+#endif
+
+    return ret; 
 }
 
-/* Function Name:
- *      rtk_igmp_protocol_get
- * Description:
- *      set IGMP/MLD protocol action
- * Input:
- *      port        - Port ID
- *      protocol    - IGMP/MLD protocol
- *      action      - Per-port and per-protocol IGMP action seeting
- * Output:
- *      None.
- * Return:
- *      RT_ERR_OK              - OK
- *      RT_ERR_FAILED          - Failed
- *      RT_ERR_SMI             - SMI access error
- *      RT_ERR_PORT_MASK       - Error parameter
- * Note:
- *      This API set IGMP/MLD protocol action
- */
-rtk_api_ret_t rtk_igmp_protocol_get(rtk_port_t port, rtk_igmp_protocol_t protocol, rtk_trap_igmp_action_t *pAction)
+#define BIT(nr)			(1UL << (nr))
+#define WAN_VID			8
+#define LAN_VID			9
+#if defined(CONFIG_RTL_EXCHANGE_PORTMASK)
+#define	RTL8367R_WAN			0		// WAN port is set to 8367R port 0
+#else
+#define	RTL8367R_WAN			4		// WAN port is set to 8367R port 4
+#endif
+
+#define	RTL_WANPORT_MASK		(0x1 << RTL8367R_WAN)
+#define	RTL_LANPORT_MASK		(0x1f & (~RTL_WANPORT_MASK))
+
+#define GATEWAY_MODE				0
+#define BRIDGE_MODE				1
+
+static  int rtl8197d_op_mode = 0;
+extern rtk_uint32 r8367_cpu_port;
+
+int RTL8367R_vlan_init(void)
+{
+	int i, retval;
+	rtk_portmask_t mbrmsk, untagmsk;
+
+	/* for lan */
+	mbrmsk.bits[0] = RTL_LANPORT_MASK|BIT(r8367_cpu_port);
+	untagmsk.bits[0] = RTL_LANPORT_MASK;
+	retval = rtk_vlan_set(LAN_VID, mbrmsk, untagmsk, 0);
+
+	for(i=0;i<5;i++) {
+		if  ((1<<i)&RTL_LANPORT_MASK)
+		{
+			retval = rtk_vlan_portPvid_set(i, LAN_VID, 0);			
+		}
+	}
+		
+	/* for wan */
+	mbrmsk.bits[0] = RTL_WANPORT_MASK|BIT(r8367_cpu_port);
+	untagmsk.bits[0] = RTL_WANPORT_MASK;
+	retval = rtk_vlan_set(WAN_VID, mbrmsk, untagmsk, 1);
+
+	for(i=0;i<5;i++) {
+		if  ((1<<i)&RTL_WANPORT_MASK)
+		{
+			retval = rtk_vlan_portPvid_set(i, WAN_VID, 0);
+		}
+	}
+
+	rtl8197d_op_mode = GATEWAY_MODE;
+	return 0;
+}
+
+int RTL8367R_vlan_reinit(int mode)
 {
-    rtk_uint32      operation;
-    rtk_api_ret_t   retVal;
+	int i, retval;
+	rtk_portmask_t mbrmsk, untagmsk;
 
-    if (port > RTK_PORT_ID_MAX)
-        return RT_ERR_PORT_ID;
+	if (mode==rtl8197d_op_mode) // no need tio do the re-initialization
+		return 0;
 
-    if(protocol >= PROTOCOL_END)
-        return RT_ERR_INPUT;
+	rtk_vlan_init();
+	
+	if (mode==GATEWAY_MODE)
+	{
+		/* for lan */
+		mbrmsk.bits[0] = RTL_LANPORT_MASK|BIT(r8367_cpu_port);
+		untagmsk.bits[0] = RTL_LANPORT_MASK;
+		retval = rtk_vlan_set(LAN_VID, mbrmsk, untagmsk, 0);
 
-    switch(protocol)
-    {
-        case PROTOCOL_IGMPv1:
-            if ((retVal = rtl8367b_getAsicIGMPv1Opeartion(port, &operation))!=RT_ERR_OK)
-                return retVal;
+		for(i=0;i<5;i++) {
+			if  ((1<<i)&RTL_LANPORT_MASK)
+			{
+				retval = rtk_vlan_portPvid_set(i, LAN_VID, 0);			
+			}
+		}
+	
+		/* for wan */
+		mbrmsk.bits[0] = RTL_WANPORT_MASK|BIT(r8367_cpu_port);
+		untagmsk.bits[0] = RTL_WANPORT_MASK;
+		retval = rtk_vlan_set(WAN_VID, mbrmsk, untagmsk, 1);
 
-            break;
-        case PROTOCOL_IGMPv2:
-            if ((retVal = rtl8367b_getAsicIGMPv2Opeartion(port, &operation))!=RT_ERR_OK)
-                return retVal;
+		for(i=0;i<5;i++) {
+			if  ((1<<i)&RTL_WANPORT_MASK)
+			{
+				retval = rtk_vlan_portPvid_set(i, WAN_VID, 0);
+			}
+		}		
+	} 
+	else {
+		/* for lan */
+		mbrmsk.bits[0] = (RTL_LANPORT_MASK | RTL_WANPORT_MASK) |BIT(r8367_cpu_port);
+		untagmsk.bits[0] = (RTL_LANPORT_MASK | RTL_WANPORT_MASK);
+		retval = rtk_vlan_set(LAN_VID, mbrmsk, untagmsk, 0);
 
-            break;
-        case PROTOCOL_IGMPv3:
-            if ((retVal = rtl8367b_getAsicIGMPv3Opeartion(port, &operation))!=RT_ERR_OK)
-                return retVal;
+		for(i=0;i<5;i++) {
+			if  ((1<<i)&(RTL_LANPORT_MASK | RTL_WANPORT_MASK))
+			{
+				retval = rtk_vlan_portPvid_set(i, LAN_VID, 0);			
+			}
+		}		
+	}
+	rtl8197d_op_mode = mode;
+	
+	return 0;
+}
 
-            break;
-        case PROTOCOL_MLDv1:
-            if ((retVal = rtl8367b_getAsicMLDv1Opeartion(port, &operation))!=RT_ERR_OK)
-                return retVal;
+#define RTL8367R_WAN_PORT_BITMAP 		(1<<RTL8367R_WAN)
+#define RTL8367R_LAN_PORT_BITMAP 		(0x1f - RTL8367R_WAN_PORT_BITMAP)
+#define RTL8367R_LAN_EFID				2
+extern int rtl865x_curOpMode;
 
-            break;
-        case PROTOCOL_MLDv2:
-            if ((retVal = rtl8367b_getAsicMLDv2Opeartion(port, &operation))!=RT_ERR_OK)
-                return retVal;
+#if defined(CONFIG_RTL_VLAN_8021Q) && defined(CONFIG_RTL_8367R_SUPPORT)
+#if 0
+int rtl_vlan_RTL8367R_set(unsigned short vid, unsigned int tagmask, unsigned int mask)
+{
+	rtk_portmask_t mbrmsk, untag;
+	rtk_api_ret_t retVal;
+	int i;
+    unsigned untagmask;
 
-            break;
-        default:
-            return RT_ERR_INPUT;
+    if(vid==WAN_VID || vid == LAN_VID)
+        return 0;
 
-    }
+    untagmask = mask&(~tagmask);
+    
+    mbrmsk.bits[0] = (BIT(r8367_cpu_port)|RTL8367R_WAN_PORT_BITMAP|RTL8367R_LAN_PORT_BITMAP);
 
-    switch(operation)
+    //panic_printk("untagmsk is 0x%x\n", (untagmask&RTL8367R_LAN_PORT_BITMAP));
+    
+    if(tagmask&RTL8367R_WAN_PORT_BITMAP)
+        untag.bits[0] = 0;
+    else
+        untag.bits[0] = (BIT(r8367_cpu_port)|RTL8367R_WAN_PORT_BITMAP|(untagmask&RTL8367R_LAN_PORT_BITMAP));
+
+    retVal=rtk_vlan_set(vid, mbrmsk, untag, 0); 
+    
+	return 0;
+}
+#else
+int rtl_vlan_RTL8367R_set(unsigned short vid, unsigned int tagmask, unsigned int mask, unsigned int fid)
+{
+	int retval;
+	rtk_portmask_t mbrmsk, untagmsk;
+    
+    unsigned untagmask;
+    untagmask = mask&(~tagmask);
+    if (mask == 0 && tagmask == 0)//clear
     {
-        case PROTOCOL_OP_FLOOD:
-            *pAction = IGMP_ACTION_FORWARD;
-            break;
-        case PROTOCOL_OP_TRAP:
-            *pAction = IGMP_ACTION_TRAP2CPU;
-            break;
-        case PROTOCOL_OP_DROP:
-            *pAction = IGMP_ACTION_DROP;
-            break;
-        case PROTOCOL_OP_ASIC:
-            *pAction = IGMP_ACTION_ASIC;
-            break;
-        default:
-            return RT_ERR_FAILED;
+		mbrmsk.bits[0] = mask;
+		untagmsk.bits[0] = untagmask;
     }
+    else
+	{
+		mbrmsk.bits[0] = (mask) |BIT(r8367_cpu_port);
+		//mbrmsk.bits[0] = (mask);
+		untagmsk.bits[0] = untagmask;
+        //panic_printk("%s %d vid = %u mbrmsk.bits[0]=%u untagmsk.bits[0]=%u\n", __FUNCTION__, __LINE__, vid, mbrmsk.bits[0], untagmsk.bits[0]);
+	}
+    
+    retval = rtk_vlan_set(vid, mbrmsk, untagmsk, fid);        
+    
+	return 0;
+}
 
-    return RT_ERR_OK;
+#endif
+
+int rtl_8367r_vlan_get(unsigned int i, unsigned int *mbrmsk, unsigned int *untagmsk, unsigned int *fid)
+{
+	rtk_portmask_t Mbrmsk = {0}, Untagmsk = {0};
+	rtk_fid_t Fid = 0;
+	rtk_api_ret_t ret = 0;
+	
+	if (!mbrmsk || !untagmsk || !fid)
+		return -1;
+	
+	ret = rtk_vlan_get(i, &Mbrmsk, &Untagmsk, &Fid);
+	if (ret == RT_ERR_OK)
+	{
+		*mbrmsk = Mbrmsk.bits[0];
+		*untagmsk = Untagmsk.bits[0];
+		*fid = Fid;
+		return 0;
+	}
+
+	return -1;
 }
+#endif
 
-/* Function Name:
- *      rtk_igmp_fastLeave_set
- * Description:
- *      set IGMP/MLD FastLeave state
- * Input:
- *      state       - ENABLED: Enable FastLeave, DISABLED: disable FastLeave
- * Output:
- *      None.
- * Return:
- *      RT_ERR_OK              - OK
- *      RT_ERR_INPUT           - Error Input
- *      RT_ERR_FAILED          - Failed
- *      RT_ERR_SMI             - SMI access error
- * Note:
- *      This API set IGMP/MLD FastLeave state
- */
-rtk_api_ret_t rtk_igmp_fastLeave_set(rtk_enable_t state)
+int RTL8367R_vlan_set(void)
 {
-    rtk_api_ret_t   retVal;
+	rtk_portmask_t mbrmsk, untag;
+	rtk_api_ret_t retVal;
+	int i;
+	
+ 	for(i=0;i<4096;i++)
+ 	{ 	
+ 		//if (i==WAN_VID ||i==LAN_VID)
+ 		#ifdef CONFIG_RTL_VLAN_8021Q
+ 		if (i==WAN_VID || i==LAN_VID
+		#if defined(CONFIG_RTL_CUSTOM_PASSTHRU)
+			||i==PASSTHRU_VLAN_ID
+		#endif	
+			)
+        #else
+ 		if (i==WAN_VID ||i==LAN_VID || (i==10) || (i==11) || (i==12)	
+		#if defined(CONFIG_RTL_CUSTOM_PASSTHRU)
+			||i==PASSTHRU_VLAN_ID
+		#endif	
+		) /* RTK VLAN */
+        #endif
+ 		{
+ 			mbrmsk.bits[0] = (BIT(r8367_cpu_port)|RTL8367R_WAN_PORT_BITMAP|RTL8367R_LAN_PORT_BITMAP);
+ 			untag.bits[0] = (BIT(r8367_cpu_port)|RTL8367R_WAN_PORT_BITMAP|RTL8367R_LAN_PORT_BITMAP);
+ 		}
+ 		else
+ 		{
+ 			mbrmsk.bits[0] = (BIT(r8367_cpu_port)|RTL8367R_WAN_PORT_BITMAP|RTL8367R_LAN_PORT_BITMAP);
+ 			untag.bits[0] = 0;
+ 		} 	
+ 		retVal=rtk_vlan_set(i, mbrmsk, untag, 0); //all vlan's fid is 0 
+ 	}
 
-    if(state >= RTK_ENABLE_END)
-        return RT_ERR_INPUT;
+	/* set pvid :  wan:8   lan:9  */	
+	for(i=0;i<5;i++)
+	{
+		#if defined (CONFIG_RTL_IVL_SUPPORT)
+		if (i == RTL8367R_WAN)
+			retVal=rtk_vlan_portPvid_set(i, WAN_VID,0);
+		else
+			retVal=rtk_vlan_portPvid_set(i, LAN_VID,0);
+		#else
+		if(rtl865x_curOpMode==GATEWAY_MODE){
+			if (i == RTL8367R_WAN)
+				retVal=rtk_vlan_portPvid_set(i, WAN_VID,0);
+			else
+				retVal=rtk_vlan_portPvid_set(i, LAN_VID,0);
+		}else{
+			retVal=rtk_vlan_portPvid_set(i, LAN_VID,0);
+		}
+		#endif
+	}       
+	
+	/* set wan port efid=1, other ports efid=2 */
+	for(i=0;i<5;i++)
+	{
+		#if defined (CONFIG_RTL_IVL_SUPPORT)
+		if (i == RTL8367R_WAN)
+			retVal = rtk_port_efid_set(i,1);
+		else
+			retVal = rtk_port_efid_set(i,RTL8367R_LAN_EFID);
+		#else
+		if(rtl865x_curOpMode==GATEWAY_MODE){
+			if (i == RTL8367R_WAN)
+				retVal = rtk_port_efid_set(i,1);
+			else
+				retVal = rtk_port_efid_set(i,RTL8367R_LAN_EFID);
+		}else{
+			retVal = rtk_port_efid_set(i,RTL8367R_LAN_EFID);
+		}
+		#endif
+	}
 
-    if ((retVal = rtl8367b_setAsicIGMPFastLeaveEn((rtk_uint32)state))!=RT_ERR_OK)
-        return retVal;
+	// suggested by HM-Chung
+#if defined (CONFIG_RTL_IVL_SUPPORT)	
+	for (i=0; i<5; i++)
+	{
+		if (i == RTL8367R_WAN) 
+			mbrmsk.bits[0] = BIT(r8367_cpu_port);    
+		else
+			mbrmsk.bits[0] = 0xff & ~BIT(RTL8367R_WAN); 
+		rtk_port_isolation_set(i, mbrmsk);
+	}    
+#else	
+	for (i=0; i<5; i++)
+	{
+		if (rtl865x_curOpMode == GATEWAY_MODE) {
+			if (i == RTL8367R_WAN) 
+				mbrmsk.bits[0] = BIT(r8367_cpu_port);    
+			else
+				mbrmsk.bits[0] = 0xff & ~BIT(RTL8367R_WAN); 
+		}
+		else
+			mbrmsk.bits[0] = 0xff; 
+			
+		rtk_port_isolation_set(i, mbrmsk);
+	}    
+#endif
+
+#if defined (CONFIG_RTL_IVL_SUPPORT)
+	//if (rtl865x_curOpMode != GATEWAY_MODE) 
+	{	// no matter Gateway or Bridge mode, always disable wan port L2 learning
+		rtk_l2_limitLearningCnt_set(RTL8367R_WAN, 0);
+		rtk_l2_flushType_set(FLUSH_TYPE_BY_PORT, WAN_VID, RTL8367R_WAN);		
+	}
+#else
+	if (rtl865x_curOpMode == GATEWAY_MODE) {
+		rtk_l2_limitLearningCnt_set(RTL8367R_WAN, 0);
+		rtk_l2_flushType_set(FLUSH_TYPE_BY_PORT, WAN_VID, RTL8367R_WAN);		
+		rtk_l2_flushType_set(FLUSH_TYPE_BY_PORT, LAN_VID, RTL8367R_WAN);		
+	}
+	else {
+		rtk_l2_limitLearningCnt_set(RTL8367R_WAN, 2112);
+		rtk_l2_flushType_set(FLUSH_TYPE_BY_PORT, WAN_VID, RTL8367R_WAN);		
+		rtk_l2_flushType_set(FLUSH_TYPE_BY_PORT, LAN_VID, RTL8367R_WAN);		
+	}
+#endif
 
-    return RT_ERR_OK;
+	/* disable cpu port's mac addr learning ability */
+	rtl8367b_setAsicLutLearnLimitNo(r8367_cpu_port,0);
+	
+	/* disable unknown unicast/mcast/bcast flooding between LAN ports */
+	smi_write(RTL8367B_REG_UNDA_FLOODING_PMSK, BIT(r8367_cpu_port));
+	smi_write(RTL8367B_REG_UNMCAST_FLOADING_PMSK, BIT(r8367_cpu_port));
+	smi_write(RTL8367B_REG_BCAST_FLOADING_PMSK, BIT(r8367_cpu_port));
+	
+	return 0;
 }
 
-/* Function Name:
- *      rtk_igmp_fastLeave_get
- * Description:
- *      get IGMP/MLD FastLeave state
- * Input:
- *      None
- * Output:
- *      pState      - ENABLED: Enable FastLeave, DISABLED: disable FastLeave
- * Return:
- *      RT_ERR_OK              - OK
- *      RT_ERR_NULL_POINTER    - NULL pointer
- *      RT_ERR_FAILED          - Failed
- *      RT_ERR_SMI             - SMI access error
- * Note:
- *      This API get IGMP/MLD FastLeave state
- */
-rtk_api_ret_t rtk_igmp_fastLeave_get(rtk_enable_t *pState)
+void RTL8367R_cpu_tag(int enable)
 {
-    rtk_uint32      fast_leave;
-    rtk_api_ret_t   retVal;
-
-    if(pState == NULL)
-        return RT_ERR_NULL_POINTER;
+	if(enable){
+		rtl8367b_setAsicReg(RTL8367B_REG_CPU_PORT_MASK,1<<r8367_cpu_port); //set CPU port
+		rtl8367b_setAsicReg(RTL8367B_REG_CPU_CTRL,0x281|(r8367_cpu_port)<<RTL8367B_CPU_TRAP_PORT_OFFSET);
+	}
+	else{
+		rtl8367b_setAsicReg(RTL8367B_REG_CPU_CTRL,0x280|(r8367_cpu_port)<<RTL8367B_CPU_TRAP_PORT_OFFSET);
+	}
+}
 
-    if ((retVal = rtl8367b_getAsicIGMPFastLeaveEn(&fast_leave))!=RT_ERR_OK)
-        return retVal;
+void set_8367r_L2(unsigned int *mac, int intf_wan, int is_static)
+{
+	rtk_mac_t Mac;
+	rtk_l2_ucastAddr_t L2_data;
+		
+	memset(&L2_data, 0, sizeof(rtk_l2_ucastAddr_t));
+	
+	L2_data.efid= (intf_wan)? 1 : 2;
+	L2_data.port=r8367_cpu_port;
+	L2_data.is_static=is_static;
 
-    *pState = ((fast_leave == 1) ? ENABLED : DISABLED);
-    return RT_ERR_OK;
+	memcpy(&Mac.octet[0], mac, 6);
+	rtk_l2_addr_add(&Mac,  &L2_data);
 }
 
-/* Function Name:
- *      rtk_igmp_maxGroup_set
- * Description:
- *      Set per port multicast group learning limit.
- * Input:
- *      port        - Port ID
- *      group       - The number of multicast group learning limit.
- * Output:
- *      None.
- * Return:
- *      RT_ERR_OK              - OK
- *      RT_ERR_PORT_ID         - Error Port ID
- *      RT_ERR_OUT_OF_RANGE    - parameter out of range
- *      RT_ERR_FAILED          - Failed
- *      RT_ERR_SMI             - SMI access error
- * Note:
- *      This API set per port multicast group learning limit.
- */
-rtk_api_ret_t rtk_igmp_maxGroup_set(rtk_port_t port, rtk_uint32 group)
+void del_8367r_L2(rtk_mac_t *pMac)
 {
-    rtk_api_ret_t   retVal;
-
-    if (port > RTK_PORT_ID_MAX)
-        return RT_ERR_PORT_ID;
+	rtk_l2_ucastAddr_t L2_data;
 
-    if(group > RTL8367B_IGMP_MAX_GOUP)
-		return RT_ERR_OUT_OF_RANGE;
+	memset(&L2_data, 0, sizeof(rtk_l2_ucastAddr_t));
+	L2_data.fid = 0;
+	L2_data.efid = RTL8367R_LAN_EFID;
+	
+	if (rtk_l2_addr_get(pMac, &L2_data) == RT_ERR_OK)
+		rtk_l2_addr_del(pMac, &L2_data);
 
-    if ((retVal = rtl8367b_setAsicIGMPPortMAXGroup(port, group))!=RT_ERR_OK)
-        return retVal;
+	return;
+}
 
-    return RT_ERR_OK;
+#if 0
+void get_all_L2(void)
+{
+	int i, ret;
+	rtk_l2_addr_table_t p;
+		
+	for (i=1; i<=RTK_MAX_NUM_OF_LEARN_LIMIT;i++)
+	{
+		p.index = i;
+		ret = rtk_l2_entry_get(&p);
+		if (ret == RT_ERR_OK)
+		{
+			printk(" [%d] mac: %02x:%02x:%02x:%02x:%02x:%02x, portmask: 0x%x, age: %d, fid: %d\n", i,
+				p.mac.octet[0],p.mac.octet[1],p.mac.octet[2],p.mac.octet[3],p.mac.octet[4],p.mac.octet[5],
+				p.portmask, p.age, p.fid);			
+		}
+	}
+	return;
 }
+#endif
 
-/* Function Name:
- *      rtk_igmp_maxGroup_get
- * Description:
- *      Get per port multicast group learning limit.
- * Input:
- *      port        - Port ID
- * Output:
- *      pGroup      - The number of multicast group learning limit.
- * Return:
- *      RT_ERR_OK              - OK
- *      RT_ERR_PORT_ID         - Error Port ID
- *      RT_ERR_NULL_POINTER    - Null pointer
- *      RT_ERR_FAILED          - Failed
- *      RT_ERR_SMI             - SMI access error
- * Note:
- *      This API get per port multicast group learning limit.
- */
-rtk_api_ret_t rtk_igmp_maxGroup_get(rtk_port_t port, rtk_uint32 *pGroup)
+enum 
 {
-    rtk_api_ret_t   retVal;
+	PORT_DOWN=0,
+	HALF_DUPLEX_10M,
+	HALF_DUPLEX_100M,
+	HALF_DUPLEX_1000M,
+	DUPLEX_10M,
+	DUPLEX_100M,
+	DUPLEX_1000M,
+	PORT_AUTO
+};
 
-    if (port > RTK_PORT_ID_MAX)
-        return RT_ERR_PORT_ID;
+rtk_api_ret_t set_8367r_speed_mode(int port, int mode)
+{
+	rtk_port_phy_ability_t phyAbility;
 
-    if(pGroup == NULL)
-		return RT_ERR_NULL_POINTER;
+	memset(&phyAbility, 0, sizeof(rtk_port_phy_ability_t));
 
-    if ((retVal = rtl8367b_getAsicIGMPPortMAXGroup(port, pGroup))!=RT_ERR_OK)
-        return retVal;
+	phyAbility.FC = 1;
+	phyAbility.AsyFC = 1;
+	phyAbility.AutoNegotiation = 1;
 
-    return RT_ERR_OK;
+	if (mode == HALF_DUPLEX_10M) //10M half
+	{
+		phyAbility.Half_10 = 1;
+	}
+	else if (mode == DUPLEX_10M)	//10M full
+	{
+		phyAbility.Full_10 = 1;
+	}
+	else if (mode == HALF_DUPLEX_100M) // 100M half
+	{
+		phyAbility.Half_100 = 1;
+	}
+	else if (mode == DUPLEX_100M) // 100M full
+	{
+		phyAbility.Full_100 = 1;
+	}
+	else if (mode == DUPLEX_1000M) // 1000M
+	{
+		phyAbility.Full_1000 = 1;
+	}
+	else
+	{
+		phyAbility.Half_10 = 1;
+		phyAbility.Full_10 = 1;
+		phyAbility.Half_100 = 1;
+		phyAbility.Full_100 = 1;
+		phyAbility.Full_1000 = 1;
+	}
+
+	return (rtk_port_phyAutoNegoAbility_set(port, &phyAbility));
 }
 
-/* Function Name:
- *      rtk_igmp_currentGroup_get
- * Description:
- *      Get per port multicast group learning count.
- * Input:
- *      port        - Port ID
- * Output:
- *      pGroup      - The number of multicast group learning count.
- * Return:
- *      RT_ERR_OK              - OK
- *      RT_ERR_PORT_ID         - Error Port ID
- *      RT_ERR_NULL_POINTER    - Null pointer
- *      RT_ERR_FAILED          - Failed
- *      RT_ERR_SMI             - SMI access error
- * Note:
- *      This API get per port multicast group learning count.
- */
-rtk_api_ret_t rtk_igmp_currentGroup_get(rtk_port_t port, rtk_uint32 *pGroup)
+void rtl8367rb_reset(void)
 {
-    rtk_api_ret_t   retVal;
-
-    if (port > RTK_PORT_ID_MAX)
-        return RT_ERR_PORT_ID;
-
-    if(pGroup == NULL)
-		return RT_ERR_NULL_POINTER;
-
-    if ((retVal = rtl8367b_getAsicIGMPPortCurrentGroup(port, pGroup))!=RT_ERR_OK)
-        return retVal;
+	rtl8367b_setAsicReg(RTL8367B_REG_CHIP_RESET, (1<<RTL8367B_CHIP_RST_OFFSET));	
+	return;
+}
 
-    return RT_ERR_OK;
+#if defined(CONFIG_RTL_CUSTOM_PASSTHRU)
+int rtl8367_setProtocolBasedVLAN(rtk_vlan_proto_type_t proto_type,rtk_vlan_t cvid, int cmdFlag)
+{
+	rtk_port_t port;
+	int ret;
+	rtk_vlan_protoAndPortInfo_t info;
+	info.proto_type=proto_type;
+   	info.frame_type=FRAME_TYPE_ETHERNET;
+    info.cvid=cvid;
+    info.cpri=0;
+	
+	if(cmdFlag==TRUE)
+	{
+		//printk("ADD[%s]:[%d].\n",__FUNCTION__,__LINE__);
+		/*add */
+		for(port=0;port<5;port++){
+			
+			ret=rtk_vlan_protoAndPortBasedVlan_add(port, info);
+			
+		}
+	}
+	else
+	{
+		//printk("DEL[%s]:[%d].\n",__FUNCTION__,__LINE__);
+		/*delete */
+		for(port=0;port<5;port++){
+			
+			ret=rtk_vlan_protoAndPortBasedVlan_del(port,  proto_type, FRAME_TYPE_ETHERNET);
+		}
+	}
+	return ret;
 }
+#endif
 
-#if defined(CONFIG_RTK_VLAN_SUPPORT)
+#if defined(CONFIG_RTK_VLAN_SUPPORT) || defined(CONFIG_RTL_VLAN_8021Q)
 int rtl865x_enableRtl8367ToCpuAcl(void)
 {
 	int retVal;
@@ -18767,6 +19604,7 @@ int rtl865x_enableRtl8367ToCpuAcl(void)
          act.actEnable[FILTER_ENACT_TRAP_CPU] = TRUE;
          if ((retVal = rtk_filter_igrAcl_cfg_add(0, &cfg, &act, &ruleNum)) != RT_ERR_OK)
               	return retVal;
+         return RT_ERR_OK;
 }
 
 int rtl865x_disableRtl8367ToCpuAcl(void)
@@ -18791,15 +19629,16 @@ int rtk_refinePortDuplexMode(void)
 		rtl8367b_setAsicReg(MIB_STATE_FRAG_VAL_UPDATE_BASE+port, (unsigned short)stateFragCounters);
 		rtl8367b_setAsicReg(MIB_STATE_FRAG_CTL_UPDATE_BASE+port, 0x1);
 	}
+	return RT_ERR_OK;
 }
 
 
 rtk_api_ret_t rtk_forceFull_init(void)
 {
     rtk_api_ret_t retVal;
-    rtk_uint32 busyFlag;    
+//    rtk_uint32 busyFlag;    
     rtk_uint16 i,length;
-    rtk_uint8 iromCode[] = {
+    static rtk_uint8 iromCode[] = {
     0x02,0x05,0xFE,0x02,0x04,0x23,0x7D,0x06,
     0x7C,0x11,0x7F,0xC2,0x7E,0x12,0x12,0x05,
     0xE2,0x7D,0x05,0x7C,0x20,0x7F,0xC3,0x7E,
diff -uprN rtl8367r.old/rtk_api_ext.h rtl8367r/rtk_api_ext.h
--- rtl8367r.old/rtk_api_ext.h	2013-10-22 15:45:26.000000000 +0400
+++ rtl8367r/rtk_api_ext.h	2016-01-29 19:05:46.674131759 +0300
@@ -1830,49 +1830,6 @@ extern rtk_api_ret_t rtk_port_phyForceMo
 extern rtk_api_ret_t rtk_port_phyStatus_get(rtk_port_t port, rtk_port_linkStatus_t *pLinkStatus, rtk_port_speed_t *pSpeed, rtk_port_duplex_t *pDuplex);
 
 /* Function Name:
- *      rtk_port_phyTestMode_set
- * Description:
- *      Set PHY in test mode.
- * Input:
- *      port - port id.
- *      mode - PHY test mode 0:normal 1:test mode 1 2:test mode 2 3: test mode 3 4:test mode 4 5~7:reserved
- * Output:
- *      None
- * Return:
- *      RT_ERR_OK              	- OK
- *      RT_ERR_FAILED          	- Failed
- *      RT_ERR_SMI             	- SMI access error
- *      RT_ERR_PORT_ID 			- Invalid port number.
- *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
- * Note:
- *      Set PHY in test mode and only one PHY can be in test mode at the same time.
- *      It means API will return FALED if other PHY is in test mode.
- *      This API only provide test mode 1 setup, and if users want other test modes,
- *      please contact realtek FAE.
- */
-extern rtk_api_ret_t rtk_port_phyTestMode_set(rtk_port_t port, rtk_port_phy_test_mode_t mode);
-
-/* Function Name:
- *      rtk_port_phyTestMode_get
- * Description:
- *      Get PHY in which test mode.
- * Input:
- *      port - Port id.
- * Output:
- *      mode - PHY test mode 0:normal 1:test mode 1 2:test mode 2 3: test mode 3 4:test mode 4 5~7:reserved
- * Return:
- *      RT_ERR_OK              	- OK
- *      RT_ERR_FAILED          	- Failed
- *      RT_ERR_SMI             	- SMI access error
- *      RT_ERR_PORT_ID 			- Invalid port number.
- *      RT_ERR_INPUT 			- Invalid input parameters.
- *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
- * Note:
- *      Get test mode of PHY from register setting 9.15 to 9.13.
- */
-extern rtk_api_ret_t rtk_port_phyTestMode_get(rtk_port_t port, rtk_port_phy_test_mode_t *pMode);
-
-/* Function Name:
  *      rtk_port_phy1000BaseTMasterSlave_set
  * Description:
  *      Set PHY control enable MASTER/SLAVE manual configuration.
@@ -1958,7 +1915,6 @@ extern rtk_api_ret_t rtk_port_macForceLi
  *      - MODE_EXT_TMII_PHY,
  *      - MODE_EXT_GMII,
  *      - MODE_EXT_RMII_MAC,
- *      - MODE_EXT_RMII_PHY,
  */
 extern rtk_api_ret_t rtk_port_macForceLinkExt0_set(rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability);
 
@@ -2006,7 +1962,6 @@ extern rtk_api_ret_t rtk_port_macForceLi
  *      - MODE_EXT_TMII_PHY,
  *      - MODE_EXT_GMII,
  *      - MODE_EXT_RMII_MAC,
- *      - MODE_EXT_RMII_PHY,
  */
 extern rtk_api_ret_t rtk_port_macForceLinkExt1_set(rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability);
 
@@ -2055,7 +2010,6 @@ extern rtk_api_ret_t rtk_port_macForceLi
  *      - MODE_EXT_TMII_PHY,
  *      - MODE_EXT_GMII,
  *      - MODE_EXT_RMII_MAC,
- *      - MODE_EXT_RMII_PHY,
  */
 extern rtk_api_ret_t rtk_port_macForceLinkExt_set(rtk_ext_port_t port, rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability);
 
@@ -2397,6 +2351,7 @@ extern rtk_api_ret_t rtk_port_rgmiiDelay
  * Description:
  *      Set RGMII interface delay value for TX and RX.
  * Input:
+ *      port    - EXT port
  *      txDelay - TX delay value, 1 for delay 2ns and 0 for no-delay
  *      rxDelay - RX delay value, 0~7 for delay setup.
  * Output:
@@ -2420,6 +2375,7 @@ extern rtk_api_ret_t rtk_port_rgmiiDelay
  * Input:
  *      None
  * Output:
+ *      port     - EXT port
  *      pTxDelay - TX delay value
  *      pRxDelay - RX delay value
  * Return:
@@ -3865,7 +3821,7 @@ extern rtk_api_ret_t rtk_l2_localPktPerm
  *      RT_ERR_SMI              - SMI access error
  *      RT_ERR_OUT_OF_RANGE     - input out of range.
  * Note:
- *      The API can set LUT agging out period for each entry and the range is from 14s to 800s.
+ *      The API can set LUT agging out period for each entry and the range is from 45s to 458s.
  */
 extern rtk_api_ret_t rtk_l2_aging_set(rtk_l2_age_time_t aging_time);
 
diff -uprN rtl8367r.old/rtk_api.h rtl8367r/rtk_api.h
--- rtl8367r.old/rtk_api.h	2013-10-22 15:45:26.000000000 +0400
+++ rtl8367r/rtk_api.h	2016-01-29 19:05:46.638131759 +0300
@@ -104,10 +104,6 @@
 #define RTK_MAX_NUM_OF_FILTER_TYPE                  5
 #define RTK_MAX_NUM_OF_FILTER_FIELD                 8
 
-#define RTK_FIBER_FORCE_1000M                       3
-#define RTK_FIBER_FORCE_100M                        5
-#define RTK_FIBER_FORCE_100M1000M                   7
-
 #define RTK_MAX_NUM_OF_METER                        32
 
 #define RTK_FLOWCTRL_PAUSE_ALL                      1980
@@ -176,7 +172,7 @@
 #define CONFIG_RTL_CUSTOM_PASSTHRU 1
 #endif
 
-#if defined CONFIG_RTL_CUSTOM_PASSTHRU
+#if defined(CONFIG_RTL_CUSTOM_PASSTHRU)
 #define PASSTHRU_VLAN_ID 100
 #endif
 
@@ -609,12 +605,13 @@ typedef enum rtk_filter_field_type_raw_e
 
     FILTER_FIELD_RAW_IPV6_SIP_15_0 = 0x20,
     FILTER_FIELD_RAW_IPV6_SIP_31_16,
-    FILTER_FIELD_RAW_IPV6_DIP_15_0,
+    FILTER_FIELD_RAW_IPV6_DIP_15_0 = 0x28,
     FILTER_FIELD_RAW_IPV6_DIP_31_16,
 
 	FILTER_FIELD_RAW_VIDRANGE = 0x30,
 	FILTER_FIELD_RAW_IPRANGE,
 	FILTER_FIELD_RAW_PORTRANGE,
+	FILTER_FIELD_RAW_FIELD_VALID,
 
 	FILTER_FIELD_RAW_FIELD_SELECT00 = 0x40,
 	FILTER_FIELD_RAW_FIELD_SELECT01,
@@ -886,6 +883,9 @@ typedef struct rtk_l2_ucastAddr_s
     rtk_uint32      da_block;
     rtk_uint32      auth;
     rtk_uint32      is_static;
+    rtk_uint32      priority;
+    rtk_uint32      sa_pri_en;
+    rtk_uint32      fwd_pri_en;
 }rtk_l2_ucastAddr_t;
 
 
diff -uprN rtl8367r.old/rtl8367b_asicdrv_green.c rtl8367r/rtl8367b_asicdrv_green.c
--- rtl8367r.old/rtl8367b_asicdrv_green.c	2013-10-22 15:45:26.000000000 +0400
+++ rtl8367r/rtl8367b_asicdrv_green.c	2016-01-29 19:05:46.534131762 +0300
@@ -1,16 +1,16 @@
 /*
- * Copyright (C) 2009 Realtek Semiconductor Corp. 
+ * Copyright (C) 2009 Realtek Semiconductor Corp.
  * All Rights Reserved.
  *
  * This program is the proprietary software of Realtek Semiconductor
- * Corporation and/or its licensors, and only be used, duplicated, 
- * modified or distributed under the authorized license from Realtek. 
+ * Corporation and/or its licensors, and only be used, duplicated,
+ * modified or distributed under the authorized license from Realtek.
  *
- * ANY USE OF THE SOFTWARE OTHER THAN AS AUTHORIZED UNDER 
- * THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED. 
+ * ANY USE OF THE SOFTWARE OTHER THAN AS AUTHORIZED UNDER
+ * THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
  *
- * $Revision: 14202 $
- * $Date: 2010-11-16 15:13:00 +0800 (, 16  2010) $
+ * $Revision: 48858 $
+ * $Date: 2014-06-24 20:26:15 +0800 (??, 24 ?? 2014) $
  *
  * Purpose : RTL8367B switch high-level API for RTL8367B
  * Feature : Green ethernet related functions
@@ -39,7 +39,7 @@ ret_t rtl8367b_getAsicGreenPortPage(rtk_
     ret_t retVal;
     rtk_uint32 regData;
     rtk_uint32 pageMeter;
-    
+
     if(port > RTL8367B_PORTIDMAX)
         return RT_ERR_PORT_ID;
 
@@ -55,7 +55,7 @@ ret_t rtl8367b_getAsicGreenPortPage(rtk_
 
     pageMeter = pageMeter + (regData << 16);
 
-    *pPage = pageMeter;     
+    *pPage = pageMeter;
     return RT_ERR_OK;
 }
 /* Function Name:
@@ -158,7 +158,7 @@ ret_t rtl8367b_getAsicGreenHighPriorityT
 @func rtk_int32 | rtl8367b_setAsicGreenEthernet | Set green ethernet function.
 @parm rtk_uint32 | green | Green feature function usage 1:enable 0:disable.
 @rvalue RT_ERR_OK | Success.
-@rvalue RT_ERR_SMI | SMI access error. 
+@rvalue RT_ERR_SMI | SMI access error.
 @comm
  	The API can set Green Ethernet function to reduce power consumption. While green feature is enabled, ASIC will automatic
  detect the cable length and then select different power mode for best performance with minimums power consumption. Link down
@@ -166,17 +166,119 @@ ret_t rtl8367b_getAsicGreenHighPriorityT
 */
 ret_t rtl8367b_setAsicGreenEthernet(rtk_uint32 green)
 {
+    rtk_uint32 port;
+    rtk_uint32 data;
+    rtk_uint32 checkCounter;
+    rtk_uint32 regData;
+    rtk_uint32 phy_status;
+    ret_t retVal;
+
     if (green > 1)
         return RT_ERR_INPUT;
 
-	return rtl8367b_setAsicRegBit(RTL8367B_REG_PHY_AD,RTL8367B_EN_PHY_GREEN_OFFSET,green);
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data)) != RT_ERR_OK)
+        return retVal;
+
+    if( (data == 0x0276) || (data == 0x0597) || (data == 0x6367) )
+    {
+        for(port = 0; port <= RTL8367B_PHY_INTERNALNOMAX; port++)
+        {
+            /* 0xa420[2:0] */
+            if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xA420, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            phy_status = (regData & 0x0007);
+
+            if(phy_status == 3)
+            {
+                /* 0xb820[4] = 1 */
+                if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xB820, &regData)) != RT_ERR_OK)
+                    return retVal;
+
+                regData |= (0x0001 << 4);
+
+                if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xB820, regData)) != RT_ERR_OK)
+                    return retVal;
+
+                /* wait 0xb800[6] = 1 */
+                checkCounter = 100;
+                while(checkCounter)
+                {
+                    retVal = rtl8367b_getAsicPHYOCPReg(port, 0xB800, &regData);
+                    if( (retVal != RT_ERR_OK) || ((regData & 0x0040) != 0x0040) )
+                    {
+                        checkCounter --;
+                        if(0 == checkCounter)
+                        {
+                             return RT_ERR_BUSYWAIT_TIMEOUT;
+                        }
+                    }
+                    else
+                        checkCounter = 0;
+                }
+            }
+
+            /* 0xa436 = 0x8011 */
+            if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xA436, 0x8011)) != RT_ERR_OK)
+                return retVal;
+
+            /* wr 0xa438[15] = 0: disable, 1: enable */
+            if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xA438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            if(green)
+                regData |= 0x8000;
+            else
+                regData &= 0x7FFF;
+
+            if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xA438, regData)) != RT_ERR_OK)
+                return retVal;
+
+            if(phy_status == 3)
+            {
+                /* 0xb820[4] = 0  */
+                if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xB820, &regData)) != RT_ERR_OK)
+                    return retVal;
+
+                regData &= ~(0x0001 << 4);
+
+                if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xB820, regData)) != RT_ERR_OK)
+                    return retVal;
+
+                /* wait 0xb800[6] = 0 */
+                checkCounter = 100;
+                while(checkCounter)
+                {
+                    retVal = rtl8367b_getAsicPHYOCPReg(port, 0xB800, &regData);
+                    if( (retVal != RT_ERR_OK) || ((regData & 0x0040) != 0x0000) )
+                    {
+                        checkCounter --;
+                        if(0 == checkCounter)
+                        {
+                            return RT_ERR_BUSYWAIT_TIMEOUT;
+                        }
+                    }
+                    else
+                        checkCounter = 0;
+                }
+            }
+        }
+    }
+
+    if((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_PHY_AD,RTL8367B_EN_PHY_GREEN_OFFSET,green)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
 }
 
 /*
 @func rtk_int32 | rtl8367b_getAsicGreenEthernet | Get green ethernet function.
 @parm rtk_uint32 | *green | Green feature function usage 1:enable 0:disable.
 @rvalue RT_ERR_OK | Success.
-@rvalue RT_ERR_SMI | SMI access error. 
+@rvalue RT_ERR_SMI | SMI access error.
 @comm
  	The API can set Green Ethernet function to reduce power consumption. While green feature is enabled, ASIC will automatic
  detect the cable length and then select different power mode for best performance with minimums power consumption. Link down
@@ -193,7 +295,7 @@ ret_t rtl8367b_getAsicGreenEthernet(rtk_
 @parm rtk_uint32 | phy | phy number
 @parm rtk_uint32 | enable | enable power saving mode.
 @rvalue RT_ERR_OK | Success.
-@rvalue RT_ERR_SMI | SMI access error. 
+@rvalue RT_ERR_SMI | SMI access error.
 @rvalue RT_ERR_PORT_ID | Invalid port number.
 @comm
     The API can set power saving mode per phy.
@@ -202,23 +304,116 @@ ret_t rtl8367b_setAsicPowerSaving(rtk_ui
 {
     rtk_api_ret_t retVal;
     rtk_uint32 phyData;
+    rtk_uint32 phyReg;
+    rtk_uint32 data;
+    rtk_uint32 phy_status;
+    rtk_uint32 regData;
+    rtk_uint32 checkCounter;
 
     if(phy > RTL8367B_PHYIDMAX)
         return RT_ERR_PORT_ID;
     if (enable > 1)
         return RT_ERR_INPUT;
 
-    if ((retVal = rtl8367b_setAsicPHYReg(phy,RTL8367B_PHY_PAGE_ADDRESS,0))!=RT_ERR_OK)
-        return retVal;  
-    
-    if ((retVal = rtl8367b_getAsicPHYReg(phy,PHY_POWERSAVING_REG,&phyData))!=RT_ERR_OK)
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
         return retVal;
 
-    phyData = (phyData & (~PHY_POWERSAVING_MASK)) | (enable<<PHY_POWERSAVING_OFFSET) ;
-
-    if ((retVal = rtl8367b_setAsicPHYReg(phy,PHY_POWERSAVING_REG,phyData))!=RT_ERR_OK)
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data)) != RT_ERR_OK)
         return retVal;
 
+    if( (data == 0x0276) || (data == 0x0597) || (data == 0x6367) )
+    {
+        phyReg = PHY_POWERSAVING_REG + 3;
+
+        /* 0xa420[2:0] */
+        if((retVal = rtl8367b_getAsicPHYOCPReg(phy, 0xA420, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        phy_status = (regData & 0x0007);
+
+        if(phy_status == 3)
+        {
+            /* 0xb820[4] = 1 */
+            if((retVal = rtl8367b_getAsicPHYOCPReg(phy, 0xB820, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            regData |= (0x0001 << 4);
+
+            if((retVal = rtl8367b_setAsicPHYOCPReg(phy, 0xB820, regData)) != RT_ERR_OK)
+                return retVal;
+
+            /* wait 0xb800[6] = 1 */
+            checkCounter = 100;
+            while(checkCounter)
+            {
+                retVal = rtl8367b_getAsicPHYOCPReg(phy, 0xB800, &regData);
+                if( (retVal != RT_ERR_OK) || ((regData & 0x0040) != 0x0040) )
+                {
+                    checkCounter --;
+                    if(0 == checkCounter)
+                    {
+                         return RT_ERR_BUSYWAIT_TIMEOUT;
+                    }
+                }
+                else
+                    checkCounter = 0;
+            }
+        }
+
+        if ((retVal = rtl8367b_getAsicPHYReg(phy,phyReg,&phyData))!=RT_ERR_OK)
+            return retVal;
+
+        phyData = phyData & ~(0x0001 << 2);
+        phyData = phyData | (enable << 2);
+
+        if ((retVal = rtl8367b_setAsicPHYReg(phy,phyReg,phyData))!=RT_ERR_OK)
+            return retVal;
+
+        if(phy_status == 3)
+        {
+            /* 0xb820[4] = 0  */
+            if((retVal = rtl8367b_getAsicPHYOCPReg(phy, 0xB820, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            regData &= ~(0x0001 << 4);
+
+            if((retVal = rtl8367b_setAsicPHYOCPReg(phy, 0xB820, regData)) != RT_ERR_OK)
+                return retVal;
+
+            /* wait 0xb800[6] = 0 */
+            checkCounter = 100;
+            while(checkCounter)
+            {
+                retVal = rtl8367b_getAsicPHYOCPReg(phy, 0xB800, &regData);
+                if( (retVal != RT_ERR_OK) || ((regData & 0x0040) != 0x0000) )
+                {
+                    checkCounter --;
+                    if(0 == checkCounter)
+                    {
+                        return RT_ERR_BUSYWAIT_TIMEOUT;
+                    }
+                }
+                else
+                    checkCounter = 0;
+            }
+        }
+    }
+    else
+    {
+        phyReg = PHY_POWERSAVING_REG;
+
+        if ((retVal = rtl8367b_setAsicPHYReg(phy,RTL8367B_PHY_PAGE_ADDRESS,0))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367b_getAsicPHYReg(phy,phyReg,&phyData))!=RT_ERR_OK)
+            return retVal;
+
+        phyData = (phyData & (~PHY_POWERSAVING_MASK)) | (enable<<PHY_POWERSAVING_OFFSET) ;
+
+        if ((retVal = rtl8367b_setAsicPHYReg(phy,phyReg,phyData))!=RT_ERR_OK)
+            return retVal;
+    }
+
     return RT_ERR_OK;
 }
 
@@ -227,7 +422,7 @@ ret_t rtl8367b_setAsicPowerSaving(rtk_ui
 @parm rtk_uint32 | port | The port number
 @parm rtk_uint32* | enable | enable power saving mode.
 @rvalue RT_ERR_OK | Success.
-@rvalue RT_ERR_SMI | SMI access error. 
+@rvalue RT_ERR_SMI | SMI access error.
 @rvalue RT_ERR_PORT_ID | Invalid port number.
 @comm
     The API can get power saving mode per phy.
@@ -236,21 +431,46 @@ ret_t rtl8367b_getAsicPowerSaving(rtk_ui
 {
     rtk_api_ret_t retVal;
     rtk_uint32 phyData;
+    rtk_uint32 phyReg;
+    rtk_uint32 data;
 
     if(phy > RTL8367B_PHYIDMAX)
         return RT_ERR_PORT_ID;
 
-    if ((retVal = rtl8367b_setAsicPHYReg(phy,RTL8367B_PHY_PAGE_ADDRESS,0))!=RT_ERR_OK)
-        return retVal;  
-    
-    if ((retVal = rtl8367b_getAsicPHYReg(phy,PHY_POWERSAVING_REG,&phyData))!=RT_ERR_OK)
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367b_getAsicReg(0x1300, &data)) != RT_ERR_OK)
         return retVal;
 
-    if ((phyData & PHY_POWERSAVING_MASK) > 0)
-        *enable = 1;
-    else 
-        *enable = 0;
-    
+    if( (data == 0x0276) || (data == 0x0597) || (data == 0x6367) )
+    {
+        phyReg = PHY_POWERSAVING_REG + 3;
+
+        if ((retVal = rtl8367b_getAsicPHYReg(phy,phyReg,&phyData))!=RT_ERR_OK)
+            return retVal;
+
+        if ((phyData & 0x0004) > 0)
+            *enable = 1;
+        else
+            *enable = 0;
+    }
+    else
+    {
+        phyReg = PHY_POWERSAVING_REG;
+
+        if ((retVal = rtl8367b_setAsicPHYReg(phy,RTL8367B_PHY_PAGE_ADDRESS,0))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367b_getAsicPHYReg(phy,phyReg,&phyData))!=RT_ERR_OK)
+            return retVal;
+
+        if ((phyData & PHY_POWERSAVING_MASK) > 0)
+            *enable = 1;
+        else
+            *enable = 0;
+    }
+
     return RT_ERR_OK;
 }
 
diff -uprN rtl8367r.old/rtl8367b_asicdrv_phy.c rtl8367r/rtl8367b_asicdrv_phy.c
--- rtl8367r.old/rtl8367b_asicdrv_phy.c	2013-10-22 15:45:26.000000000 +0400
+++ rtl8367r/rtl8367b_asicdrv_phy.c	2016-01-29 19:05:45.858131776 +0300
@@ -9,8 +9,8 @@
  * ANY USE OF THE SOFTWARE OTHER THAN AS AUTHORIZED UNDER
  * THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
  *
- * $Revision: 22767 $
- * $Date: 2011-09-19 14:10:21 +0800 (, 19  2011) $
+ * $Revision: 48278 $
+ * $Date: 2014-06-05 15:43:29 +0800 (??, 05 ?? 2014) $
  *
  * Purpose : RTL8367B switch high-level API for RTL8367B
  * Feature : PHY related functions
@@ -41,6 +41,7 @@
  */
 ret_t rtl8367b_setAsicPHYReg( rtk_uint32 phyNo, rtk_uint32 phyAddr, rtk_uint32 value)
 {
+    ret_t retVal;
 	rtk_uint32 regAddr;
 
     if(phyNo > RTL8367B_PHY_INTERNALNOMAX)
@@ -49,6 +50,10 @@ ret_t rtl8367b_setAsicPHYReg( rtk_uint32
     if(phyAddr > RTL8367B_PHY_REGNOMAX)
         return RT_ERR_PHY_REG_ID;
 
+    /* Default OCP Address */
+    if((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_GPHY_OCP_MSB_0, RTL8367B_CFG_CPU_OCPADR_MSB_MASK, 0x29)) != RT_ERR_OK)
+        return retVal;
+
     regAddr = 0x2000 + (phyNo << 5) + phyAddr;
 
     return rtl8367b_setAsicReg(regAddr, value);
@@ -75,6 +80,7 @@ ret_t rtl8367b_setAsicPHYReg( rtk_uint32
  */
 ret_t rtl8367b_getAsicPHYReg( rtk_uint32 phyNo, rtk_uint32 phyAddr, rtk_uint32 *value)
 {
+    ret_t retVal;
 	rtk_uint32 regAddr;
 
     if(phyNo > RTL8367B_PHY_INTERNALNOMAX)
@@ -83,11 +89,95 @@ ret_t rtl8367b_getAsicPHYReg( rtk_uint32
     if(phyAddr > RTL8367B_PHY_REGNOMAX)
         return RT_ERR_PHY_REG_ID;
 
+    /* Default OCP Address */
+    if((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_GPHY_OCP_MSB_0, RTL8367B_CFG_CPU_OCPADR_MSB_MASK, 0x29)) != RT_ERR_OK)
+        return retVal;
+
     regAddr = 0x2000 + (phyNo << 5) + phyAddr;
 
     return rtl8367b_getAsicReg(regAddr, value);
 }
 
+/* Function Name:
+ *      rtl8367b_setAsicPHYOCPReg
+ * Description:
+ *      Set PHY OCP registers
+ * Input:
+ *      phyNo 	- Physical port number (0~7)
+ *      ocpAddr - OCP address
+ *      ocpData - Writing data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK 				- Success
+ *      RT_ERR_SMI  			- SMI access error
+ *      RT_ERR_PHY_REG_ID  		- invalid PHY address
+ *      RT_ERR_PHY_ID  			- invalid PHY no
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      None
+ */
+ret_t rtl8367b_setAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 ocpData )
+{
+    ret_t retVal;
+	rtk_uint32 regAddr;
+    rtk_uint32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;
+
+    /* OCP prefix */
+    ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
+    if((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_GPHY_OCP_MSB_0, RTL8367B_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix)) != RT_ERR_OK)
+        return retVal;
+
+    /*prepare access address*/
+    ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
+    ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
+    regAddr = RTL8367B_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367B_PHY_OFFSET) | ocpAddr5_1;
+    if((retVal = rtl8367b_setAsicReg(regAddr, ocpData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367b_getAsicPHYOCPReg
+ * Description:
+ *      Get PHY OCP registers
+ * Input:
+ *      phyNo 	- Physical port number (0~7)
+ *      ocpAddr - PHY address
+ *      pRegData - read data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK 				- Success
+ *      RT_ERR_SMI  			- SMI access error
+ *      RT_ERR_PHY_REG_ID  		- invalid PHY address
+ *      RT_ERR_PHY_ID  			- invalid PHY no
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      None
+ */
+ret_t rtl8367b_getAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 *pRegData )
+{
+    ret_t retVal;
+	rtk_uint32 regAddr;
+    rtk_uint32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;
+
+    /* OCP prefix */
+    ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
+    if((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_GPHY_OCP_MSB_0, RTL8367B_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix)) != RT_ERR_OK)
+        return retVal;
+
+    /*prepare access address*/
+    ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
+    ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
+    regAddr = RTL8367B_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367B_PHY_OFFSET) | ocpAddr5_1;
+    if((retVal = rtl8367b_getAsicReg(regAddr, pRegData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
 #else
 
 /* Function Name:
@@ -134,6 +224,10 @@ ret_t rtl8367b_setAsicPHYReg(rtk_uint32
     if(busyFlag)
         return RT_ERR_BUSYWAIT_TIMEOUT;
 
+    /* Default OCP Address */
+    if((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_GPHY_OCP_MSB_0, RTL8367B_CFG_CPU_OCPADR_MSB_MASK, 0x29)) != RT_ERR_OK)
+        return retVal;
+
     /*prepare access data*/
     retVal = rtl8367b_setAsicReg(RTL8367B_REG_INDRECT_ACCESS_WRITE_DATA, phyData);
 	if(retVal != RT_ERR_OK)
@@ -149,7 +243,11 @@ ret_t rtl8367b_setAsicPHYReg(rtk_uint32
     /*Set WRITE Command*/
     retVal = rtl8367b_setAsicReg(RTL8367B_REG_INDRECT_ACCESS_CTRL, RTL8367B_CMD_MASK | RTL8367B_RW_MASK);
 
+#if defined(RTK_X86_CLE)
+	checkCounter = 100;
+#else
     checkCounter = 5;
+#endif
 	while(checkCounter)
 	{
     	retVal = rtl8367b_getAsicReg(RTL8367B_REG_INDRECT_ACCESS_STATUS,&busyFlag);
@@ -210,6 +308,10 @@ ret_t rtl8367b_getAsicPHYReg(rtk_uint32
     if(busyFlag)
         return RT_ERR_BUSYWAIT_TIMEOUT;
 
+    /* Default OCP Address */
+    if((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_GPHY_OCP_MSB_0, RTL8367B_CFG_CPU_OCPADR_MSB_MASK, 0x29)) != RT_ERR_OK)
+        return retVal;
+
     /*prepare access address*/
     regData = RTL8367B_PHY_BASE | (phyNo << RTL8367B_PHY_OFFSET) | phyAddr;
 
@@ -222,7 +324,162 @@ ret_t rtl8367b_getAsicPHYReg(rtk_uint32
 	if(retVal != RT_ERR_OK)
 		return retVal;
 
-	checkCounter = 5;
+#if defined(RTK_X86_CLE)
+	checkCounter = 100;
+#else
+    checkCounter = 5;
+#endif
+	while(checkCounter)
+	{
+    	retVal = rtl8367b_getAsicReg(RTL8367B_REG_INDRECT_ACCESS_STATUS,&busyFlag);
+		if((retVal != RT_ERR_OK) || busyFlag)
+		{
+			checkCounter --;
+			if(0 == checkCounter)
+                return RT_ERR_FAILED;
+		}
+		else
+		{
+			checkCounter = 0;
+		}
+	}
+
+    /*get PHY register*/
+    retVal = rtl8367b_getAsicReg(RTL8367B_REG_INDRECT_ACCESS_READ_DATA, &regData);
+	if(retVal != RT_ERR_OK)
+		return retVal;
+
+    *pRegData = regData;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367b_setAsicPHYOCPReg
+ * Description:
+ *      Set PHY OCP registers
+ * Input:
+ *      phyNo 	- Physical port number (0~7)
+ *      ocpAddr - OCP address
+ *      ocpData - Writing data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK 				- Success
+ *      RT_ERR_SMI  			- SMI access error
+ *      RT_ERR_PHY_REG_ID  		- invalid PHY address
+ *      RT_ERR_PHY_ID  			- invalid PHY no
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      None
+ */
+ret_t rtl8367b_setAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 ocpData )
+{
+	ret_t retVal;
+	rtk_uint32 regData;
+    rtk_uint32 busyFlag, checkCounter;
+    rtk_uint32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;
+
+    /*Check internal phy access busy or not*/
+    retVal = rtl8367b_getAsicReg(RTL8367B_REG_INDRECT_ACCESS_STATUS,&busyFlag);
+	if(retVal != RT_ERR_OK)
+		return retVal;
+
+    if(busyFlag)
+        return RT_ERR_BUSYWAIT_TIMEOUT;
+
+    /* OCP prefix */
+    ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
+    if((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_GPHY_OCP_MSB_0, RTL8367B_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix)) != RT_ERR_OK)
+        return retVal;
+
+    /*prepare access data*/
+    retVal = rtl8367b_setAsicReg(RTL8367B_REG_INDRECT_ACCESS_WRITE_DATA, ocpData);
+	if(retVal != RT_ERR_OK)
+		return retVal;
+
+    /*prepare access address*/
+    ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
+    ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
+    regData = RTL8367B_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367B_PHY_OFFSET) | ocpAddr5_1;
+    retVal = rtl8367b_setAsicReg(RTL8367B_REG_INDRECT_ACCESS_ADDRESS, regData);
+	if(retVal != RT_ERR_OK)
+		return retVal;
+
+    /*Set WRITE Command*/
+    retVal = rtl8367b_setAsicReg(RTL8367B_REG_INDRECT_ACCESS_CTRL, RTL8367B_CMD_MASK | RTL8367B_RW_MASK);
+
+    checkCounter = 100;
+	while(checkCounter)
+	{
+    	retVal = rtl8367b_getAsicReg(RTL8367B_REG_INDRECT_ACCESS_STATUS,&busyFlag);
+		if((retVal != RT_ERR_OK) || busyFlag)
+		{
+			checkCounter --;
+			if(0 == checkCounter)
+                return RT_ERR_BUSYWAIT_TIMEOUT;
+		}
+		else
+		{
+			checkCounter = 0;
+		}
+	}
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367b_getAsicPHYOCPReg
+ * Description:
+ *      Get PHY OCP registers
+ * Input:
+ *      phyNo 	- Physical port number (0~7)
+ *      ocpAddr - PHY address
+ *      pRegData - read data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK 				- Success
+ *      RT_ERR_SMI  			- SMI access error
+ *      RT_ERR_PHY_REG_ID  		- invalid PHY address
+ *      RT_ERR_PHY_ID  			- invalid PHY no
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      None
+ */
+ret_t rtl8367b_getAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 *pRegData )
+{
+	ret_t retVal;
+	rtk_uint32 regData;
+    rtk_uint32 busyFlag,checkCounter;
+    rtk_uint32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;
+
+    /*Check internal phy access busy or not*/
+    retVal = rtl8367b_getAsicReg(RTL8367B_REG_INDRECT_ACCESS_STATUS,&busyFlag);
+	if(retVal != RT_ERR_OK)
+		return retVal;
+
+    if(busyFlag)
+        return RT_ERR_BUSYWAIT_TIMEOUT;
+
+    /* OCP prefix */
+    ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
+    if((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_GPHY_OCP_MSB_0, RTL8367B_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix)) != RT_ERR_OK)
+        return retVal;
+
+    /*prepare access address*/
+    ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
+    ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
+    regData = RTL8367B_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367B_PHY_OFFSET) | ocpAddr5_1;
+    retVal = rtl8367b_setAsicReg(RTL8367B_REG_INDRECT_ACCESS_ADDRESS, regData);
+	if(retVal != RT_ERR_OK)
+		return retVal;
+
+    /*Set READ Command*/
+    retVal = rtl8367b_setAsicReg(RTL8367B_REG_INDRECT_ACCESS_CTRL, RTL8367B_CMD_MASK );
+	if(retVal != RT_ERR_OK)
+		return retVal;
+
+	checkCounter = 100;
 	while(checkCounter)
 	{
     	retVal = rtl8367b_getAsicReg(RTL8367B_REG_INDRECT_ACCESS_STATUS,&busyFlag);
diff -uprN rtl8367r.old/rtl8367b_asicdrv_phy.h rtl8367r/rtl8367b_asicdrv_phy.h
--- rtl8367r.old/rtl8367b_asicdrv_phy.h	2013-10-22 15:45:26.000000000 +0400
+++ rtl8367r/rtl8367b_asicdrv_phy.h	2016-01-29 19:05:46.150131770 +0300
@@ -15,9 +15,17 @@
 
 #define	RTL8367B_PHY_PAGE_ADDRESS       31
 
+#define    RTL8367B_REG_GPHY_OCP_MSB_0    0x1d15
+#define    RTL8367B_CFG_CPU_OCPADR_MSB_OFFSET    6
+#define    RTL8367B_CFG_CPU_OCPADR_MSB_MASK    0xFC0
+#define    RTL8367B_CFG_DW8051_OCPADR_MSB_OFFSET    0
+#define    RTL8367B_CFG_DW8051_OCPADR_MSB_MASK    0x3F
+
 
 extern ret_t rtl8367b_setAsicPHYReg(rtk_uint32 phyNo, rtk_uint32 phyAddr, rtk_uint32 regData );
 extern ret_t rtl8367b_getAsicPHYReg(rtk_uint32 phyNo, rtk_uint32 phyAddr, rtk_uint32* pRegData );
+extern ret_t rtl8367b_setAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 ocpData );
+extern ret_t rtl8367b_getAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 *pRegData );
 
 #endif /*#ifndef _RTL8367B_ASICDRV_PHY_H_*/
 
diff -uprN rtl8367r.old/rtl8367b_asicdrv_port.c rtl8367r/rtl8367b_asicdrv_port.c
--- rtl8367r.old/rtl8367b_asicdrv_port.c	2013-10-22 15:45:26.000000000 +0400
+++ rtl8367r/rtl8367b_asicdrv_port.c	2016-01-29 19:05:45.922131774 +0300
@@ -10,7 +10,7 @@
  * THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
  *
  * $Revision: 20646 $
- * $Date: 2011-08-09 14:53:37 +0800 (, 09  2011) $
+ * $Date: 2011-08-09 14:53:37 +0800 (??? 09 ?? 2011) $
  *
  * Purpose : RTL8367B switch high-level API for RTL8367B
  * Feature : Port security related functions
@@ -789,24 +789,49 @@ ret_t rtl8367b_getAsicPortLoopback(rtk_u
 ret_t rtl8367b_setAsicPortRTCT(rtk_uint32 portmask)
 {
     ret_t       retVal;
+    rtk_uint32  regData;
+    rtk_uint32  port;
 
     if(portmask > (0x0001 << RTL8367B_PHYNO))
 		return RT_ERR_PORT_MASK;
 
-    if((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_RTCT_ENABLE, RTL8367B_RTCT_ENABLE_PORT_MASK_MASK, portmask)) != RT_ERR_OK)
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
         return retVal;
 
-    if((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_SEL_RTCT_PARA, RTL8367B_EN_RTCT_TIMOUT_OFFSET, 1)) != RT_ERR_OK)
+    if((retVal = rtl8367b_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
         return retVal;
 
-    if((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_SEL_RTCT_PARA, RTL8367B_EN_ALL_RTCT_OFFSET, 0)) != RT_ERR_OK)
-        return retVal;
+    if( (regData == 0x0276) || (regData == 0x0597) )
+        return RT_ERR_CHIP_NOT_SUPPORTED;
 
-    if((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_SEL_RTCT_PARA, RTL8367B_DO_RTCT_COMMAND_OFFSET, 0)) != RT_ERR_OK)
-        return retVal;
+    if(regData == 0x6367)
+    {
+        for(port = 0; port < RTL8367B_PHYNO; port++)
+        {
+            if(portmask & (0x0001 << port))
+            {
+                if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xa422, 0x00f1)) != RT_ERR_OK)
+                    return retVal;
+            }
+        }
+    }
+    else
+    {
+        if((retVal = rtl8367b_setAsicRegBits(RTL8367B_REG_RTCT_ENABLE, RTL8367B_RTCT_ENABLE_PORT_MASK_MASK, portmask)) != RT_ERR_OK)
+            return retVal;
 
-    if((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_SEL_RTCT_PARA, RTL8367B_DO_RTCT_COMMAND_OFFSET, 1)) != RT_ERR_OK)
-        return retVal;
+        if((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_SEL_RTCT_PARA, RTL8367B_EN_RTCT_TIMOUT_OFFSET, 1)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_SEL_RTCT_PARA, RTL8367B_EN_ALL_RTCT_OFFSET, 0)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_SEL_RTCT_PARA, RTL8367B_DO_RTCT_COMMAND_OFFSET, 0)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367b_setAsicRegBit(RTL8367B_REG_SEL_RTCT_PARA, RTL8367B_DO_RTCT_COMMAND_OFFSET, 1)) != RT_ERR_OK)
+            return retVal;
+    }
 
     return RT_ERR_OK;
 }
@@ -837,59 +862,166 @@ ret_t rtl8367b_getAsicPortRTCTResult(rtk
     if(port >= RTL8367B_PHYNO)
 		return RT_ERR_PORT_ID;
 
-    if((retVal = rtl8367b_setAsicPHYReg(port, RTL8367B_PHY_PAGE_ADDRESS, RTL8367B_RTCT_PAGE)) != RT_ERR_OK)
+    if((retVal = rtl8367b_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
         return retVal;
 
-    if((retVal = rtl8367b_getAsicPHYReg(port, RTL8367B_RTCT_RESULT_A_REG, &regData)) != RT_ERR_OK)
+    if((retVal = rtl8367b_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
         return retVal;
 
-    if((regData & 0x4000) == 0x4000)
+    if( (regData == 0x6367) )
     {
-        pResult->channelALen = regData & 0x1FFF;
-
-        if((retVal = rtl8367b_getAsicPHYReg(port, RTL8367B_RTCT_RESULT_B_REG, &regData)) != RT_ERR_OK)
+        if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xa422, &regData)) != RT_ERR_OK)
             return retVal;
 
-        pResult->channelBLen = regData & 0x1FFF;
+        if((regData & 0x8000) == 0x8000)
+        {
+            /* Channel A */
+            if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xa436, 0x802a)) != RT_ERR_OK)
+                return retVal;
 
-        if((retVal = rtl8367b_getAsicPHYReg(port, RTL8367B_RTCT_RESULT_C_REG, &regData)) != RT_ERR_OK)
-            return retVal;
+            if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
 
-        pResult->channelCLen = regData & 0x1FFF;
+            pResult->channelAOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelAShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelAMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelALinedriver = (regData == 0x0041) ? 1 : 0;
 
-        if((retVal = rtl8367b_getAsicPHYReg(port, RTL8367B_RTCT_RESULT_D_REG, &regData)) != RT_ERR_OK)
-            return retVal;
+            /* Channel B */
+            if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xa436, 0x802e)) != RT_ERR_OK)
+                return retVal;
 
-        pResult->channelDLen = regData & 0x1FFF;
+            if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
 
-        if((retVal = rtl8367b_getAsicPHYReg(port, RTL8367B_RTCT_STATUS_REG, &regData)) != RT_ERR_OK)
-            return retVal;
+            pResult->channelBOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelBShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelBMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelBLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel C */
+            if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xa436, 0x8032)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelCOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelCShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelCMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelCLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel D */
+            if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xa436, 0x8036)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelDOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelDShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelDMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelDLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel A Length */
+            if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xa436, 0x802c)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
 
-        pResult->channelALinedriver = (regData & 0x0001);
-        pResult->channelBLinedriver = (regData & 0x0002);
-        pResult->channelCLinedriver = (regData & 0x0004);
-        pResult->channelDLinedriver = (regData & 0x0008);
+            pResult->channelALen = (regData / 2);
 
-        pResult->channelAMismatch   = (regData & 0x0010);
-        pResult->channelBMismatch   = (regData & 0x0020);
-        pResult->channelCMismatch   = (regData & 0x0040);
-        pResult->channelDMismatch   = (regData & 0x0080);
+            /* Channel B Length */
+            if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xa436, 0x8030)) != RT_ERR_OK)
+                return retVal;
 
-        pResult->channelAOpen       = (regData & 0x0100);
-        pResult->channelBOpen       = (regData & 0x0200);
-        pResult->channelCOpen       = (regData & 0x0400);
-        pResult->channelDOpen       = (regData & 0x0800);
+            if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
 
-        pResult->channelAShort      = (regData & 0x1000);
-        pResult->channelBShort      = (regData & 0x2000);
-        pResult->channelCShort      = (regData & 0x4000);
-        pResult->channelDShort      = (regData & 0x8000);
+            pResult->channelBLen = (regData / 2);
+
+            /* Channel C Length */
+            if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xa436, 0x8034)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelCLen = (regData / 2);
+
+            /* Channel D Length */
+            if((retVal = rtl8367b_setAsicPHYOCPReg(port, 0xa436, 0x8038)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367b_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelDLen = (regData / 2);
+        }
+        else
+            finish = 0;
+    }
+    else if( (regData == 0x0276) || (regData == 0x0597) )
+    {
+        return RT_ERR_CHIP_NOT_SUPPORTED;
     }
     else
-        finish = 0;
+    {
+        if((retVal = rtl8367b_setAsicPHYReg(port, RTL8367B_PHY_PAGE_ADDRESS, RTL8367B_RTCT_PAGE)) != RT_ERR_OK)
+            return retVal;
 
-    if((retVal = rtl8367b_setAsicPHYReg(port, RTL8367B_PHY_PAGE_ADDRESS, 0)) != RT_ERR_OK)
-        return retVal;
+        if((retVal = rtl8367b_getAsicPHYReg(port, RTL8367B_RTCT_RESULT_A_REG, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        if((regData & 0x4000) == 0x4000)
+        {
+            pResult->channelALen = regData & 0x1FFF;
+
+            if((retVal = rtl8367b_getAsicPHYReg(port, RTL8367B_RTCT_RESULT_B_REG, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelBLen = regData & 0x1FFF;
+
+            if((retVal = rtl8367b_getAsicPHYReg(port, RTL8367B_RTCT_RESULT_C_REG, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelCLen = regData & 0x1FFF;
+
+            if((retVal = rtl8367b_getAsicPHYReg(port, RTL8367B_RTCT_RESULT_D_REG, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelDLen = regData & 0x1FFF;
+
+            if((retVal = rtl8367b_getAsicPHYReg(port, RTL8367B_RTCT_STATUS_REG, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelALinedriver = (regData & 0x0001);
+            pResult->channelBLinedriver = (regData & 0x0002);
+            pResult->channelCLinedriver = (regData & 0x0004);
+            pResult->channelDLinedriver = (regData & 0x0008);
+
+            pResult->channelAMismatch   = (regData & 0x0010);
+            pResult->channelBMismatch   = (regData & 0x0020);
+            pResult->channelCMismatch   = (regData & 0x0040);
+            pResult->channelDMismatch   = (regData & 0x0080);
+
+            pResult->channelAOpen       = (regData & 0x0100);
+            pResult->channelBOpen       = (regData & 0x0200);
+            pResult->channelCOpen       = (regData & 0x0400);
+            pResult->channelDOpen       = (regData & 0x0800);
+
+            pResult->channelAShort      = (regData & 0x1000);
+            pResult->channelBShort      = (regData & 0x2000);
+            pResult->channelCShort      = (regData & 0x4000);
+            pResult->channelDShort      = (regData & 0x8000);
+        }
+        else
+            finish = 0;
+
+        if((retVal = rtl8367b_setAsicPHYReg(port, RTL8367B_PHY_PAGE_ADDRESS, 0)) != RT_ERR_OK)
+            return retVal;
+    }
 
     if(finish == 0)
         return RT_ERR_PHY_RTCT_NOT_FINISH;
